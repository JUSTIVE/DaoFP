{"A sculptor subtracts irrelevant stone until a sculpture emerges. A mathematician abstracts irrelevant details until a pattern emerges.":"조각가는 조각상이 나타날 때까지 불필요한 돌을 깎아냅니다. 수학자는 패턴이 나타날 때까지 불필요한 세부 사항을 추상화합니다.","We were able to define a lot of constructions using their mapping-in and mapping-out properties. Those, in turn, could be compactly written as isomorphisms between hom-sets. This pattern of natural isomorphisms between hom-sets is called an adjunction and, once recognized, pops up virtually everywhere.":"많은 구성 요소들을 매핑-인 및 매핑-아웃 속성으로 정의할 수 있었습니니다. 이것들은 결국 동형 사상들 간의 동형으로 간단하게 작성될 수 있었습니니다. 호응 집합(hom-sets) 간의 자연스러운 동형 패턴은 단사 한(Adjunction)이라고 불리며, 한 번 인식되면 거의 모든 곳에서 나타납니니다.","The definition of the exponential is the classic example of an adjunction that relates mappings-out and mappings-in. Every mapping out of a product corresponds to a unique mapping into the exponential:":"지수(exponential)의 정의는 사상들의 관계와 사상들의 삽입을 연결하는 고전적인 예인 부가(adjunction)~니다. 곱(product)에서의 모든 사상은 지수로의 유일한 사상으로 대응합니다:","\\mathcal{C}(e \\times a, b ) \\cong  \\mathcal{C} (e, b^a)":"\\mathcal{C}(e \\times a, b) \\cong \\mathcal{C}(e, b^a)","The object $b$ takes the role of the focus on the left hand side; the object $e$ becomes the observer on the right hand side.":"객체 $b$는 왼쪽 손의 초점 역할을 한다; 객체 $e$는 오른쪽 손의 관찰자가 된다.","We can spot two functors at play. They are both parameterized by $a$. On the left we have the product functor $(- \\times a)$ applied to $e$. On the right we have the exponential functor $(-)^a$ applied to $b$.":"우리는 두 개의 펑터들이 작용하는 것을 볼 수 있~니다. 이들은 둘 다 $a$로 매개변수화되어 있~니다. 왼쪽에는 $e$에 적용된 곱 펑터 $(- \\times a)$가 있~니다. 오른쪽에는 $b$에 적용된 지수 펑터 $(-)^a$가 있~습니다.","If we write these functors as:":"이 펑터들을 다음과 같이 쓰면:","L_a e = e \\times a":"L_a e = e \\times a","R_a b = b^a":"R_a b = b^a","then the natural isomorphism":"그때 자연동형사상(자연동형사상)","\\mathcal{C}(L_a e, b) \\cong \\mathcal{C}(e, R_a b)":"\\mathcal{C}(L_a e, b) \\cong \\mathcal{C}(e, R_a b)","is called the adjunction between them.":"이를 호준(adjointness) 관계라고 부릅니다.","In components, this isomorphism tells us that, given a mapping $\\phi \\in \\mathcal{C}(L_a e, b)$, there is a unique mapping $\\phi^T \\in \\mathcal{C}(e, R_a b)$ and vice versa. These mappings are sometimes called the \\emph{transpose} of each other---the nomenclature taken from matrix algebra.":"구성 요소로 이 동형 사상은 $\\phi \\in \\mathcal{C}(L_a e, b)$인 매핑(mapping)이 주어졌을 때, $\\phi^T \\in \\mathcal{C}(e, R_a b)$인 유일한 매핑이 존재함을 말해줍니다. 이러한 매핑들은 때때로 서로의 \\emph{전치(transpose)}라고 불리며, 이는 행렬 대수에서 가져온 명명법입니다.","The shorthand notation for the adjunction is $L \\dashv R$. Substituting the product functor for $L$ and the exponential functor for $R$, we can write the currying adjunction concisely as:":"부가함수관계를 간단히 나타내면 $L \\dashv R$입니다. 곱 함수자를 $L$로, 지수 함수자(지수 식 함수자)를 $R$로 대체하면, 커리 부가함수관계를 간단히 다음과 같이 쓸 수 있습니다:","(- \\times a) \\dashv (-)^a":"(- \\times a) \\dashv (-)^a","The exponential object $b^a$ is sometimes called the \\index{internal hom}\\emph{internal hom} and is written as $[a, b]$. This is in contrast to the \\emph{external hom}, which is the set $\\cat C (a, b)$. The external hom is \\emph{not} an object in $\\cat C$ (except when $\\cat C$ itself is $\\Set$). With this notation, the currying adjunction can be written as:":"지수 객체 $b^a$ 는 \\index{internal hom}\\emph{내부 호옴}이라 불리며 $[a, b]$로 표기됩니다. 이는 $\\cat C (a, b)$ 집합인 \\emph{외부 호옴}과 대조됩니다. 외부 호옴은 $\\cat C$의 객체가 \\emph{아닙니다} ($\\cat C$ 자체가 $\\Set$일 때를 제외하고). 이 표기법을 사용하면, 커링의 조합자는 다음과 같이 쓸 수 있습니다:","\\mathcal{C}(e \\times a, b) \\cong  \\mathcal{C} (e, [a, b])":"\\mathcal{C}(e \\times a, b) \\cong  \\mathcal{C} (e, [a, b])","A category in which this adjunction holds is called cartesian closed.":"이 수반(Adjunction)이 성립하는 범주를 데카르트 폐포 범주(cartesian closed category)라고 부릅니다.","Since functions play central role in every programming language, cartesian closed categories form the basis of all models of programming. We interpret the exponential $b^a$ as the function type $a \\to b$.":"함수는 모든 프로그래밍 언어에서 중심적인 역할을 하기 때문에, 데카르트 닫힌 범주(이론)은 모든 프로그래밍 모델의 기초를 이룹니다. 우리는 지수 $b^a$를 함수 유형 $a \\to b$로 해석합니다.","Here $e$ plays the role of the external environment---the $\\Gamma$ of the lambda calculus. The morphism in $\\cat C(\\Gamma \\times a, b)$ is interpreted as an expression of type $b$ in the environment $\\Gamma$ extended by a variable of type $a$. The function type $a \\to b$ therefore represents a closure that may capture a value of type $e$ from its environment.":"여기서 $e$는 외부 환경의 역할을 합니다---람다 대수의 $\\Gamma$입니다. $\\cat C(\\Gamma \\times a, b)$의 사상은 타입 $a$의 변수가 추가된 환경 $\\Gamma$에서 타입 $b$의 표현으로 해석됩니다. 따라서 함수 타입 $a \\to b$는 환경에서 타입 $e$의 값을 캡처할 수 있는 클로저를 나타냅니다.","Incidentally, the category of (small) categories $\\mathbf{Cat}$ is also cartesian closed, as reflected in this adjunction between product categories and functor categories that uses the same internal-hom notation:":"우연히도, (작은) 카테고리들의 카테고리 $\\mathbf{Cat}$ 또한 데카르트 닫힘(cartesian closed)입니다. 이는 곱 카테고리와 함자 카테고리 사이의 다음과 같은 어즌션(adjunction)에서 내부-홈(internal-hom) 표기법을 사용하는 것으로 반영됩니다:","\\mathbf{Cat} (\\cat A \\times \\cat B, \\cat C) \\cong \\mathbf{Cat} (\\cat A, [\\cat B, \\cat C])":"\\mathbf{Cat} (\\cat A \\times \\cat B, \\cat C) \\cong \\mathbf{Cat} (\\cat A, [\\cat B, \\cat C])","Here, both sides are sets of natural transformations.":"여기서, 양쪽 모두 자연 변환들의 집합입니다.","The currying adjunction relates two endofunctors, but an adjunction can be easily generalized to functors that go between different categories. Let's see some examples first.":"커링 부착(currying adjunction)은 두 내적 함자(endofunctor) 사이를 연결하지만, 부착(adjunction)은 서로 다른 범주 사이를 오가는 함자(functor)로 쉽게 일반화될 수 있습니다. 몇 가지 예를 먼저 살펴보겠습니다.","The sum and the product types were defined using bijections where one of the sides was a single arrow and the other was a pair of arrows. A pair of arrows can be seen as a single arrow in the product category.":"합형(합 타입\\textit{sum type})과 곱형(곱 타입\\textit{product type})은 한쪽이 단일 화살표이고 다른 한쪽이 두 개의 화살표로 이루어진 쌍인 전단사 함수(bijections)를 사용하여 정의되었습니 다. 두 개의 화살표 쌍은 곱 범주(product category)에서 단일 화살표로 볼 수 있습니 다.","To explore this idea, we need to define the diagonal functor $\\Delta$, which is a special mapping from $\\mathcal{C}$ to $\\mathcal{C} \\times \\mathcal{C}$. It takes an object $x$ and duplicates it, producing a pair of objects $\\langle x, x \\rangle$. It also takes an arrow $f$ and duplicates it $\\langle f, f \\rangle$.":"이 아이디어를 탐구하기 위해, $\\Delta$라는 대각 함자(영문: diagonal functor)를 정의해야 합니다. 이는 $\\mathcal{C}$에서 $\\mathcal{C} \\times \\mathcal{C}$로의 특별한 사상이며, 한 객체 $x$를 받아 이를 중복하여 객체 쌍 $\\langle x, x \\rangle$을 생성합니다. 또한, 화살표 $f$를 받아 이를 $\\langle f, f \\rangle$으로 중복합니다.","Interestingly, the diagonal functor is related to the constant functor we've seen previously. The constant functor can be though of as a functor of two variables---it just ignores the second one. We've seen this in the Haskell definition:":"흥미롭게도, 대각 펑터(diagonal functor)는 우리가 이전에 본 상수 펑터(constant functor)와 관련이 있~니다. 상수 펑터는 두 변수의 펑터로 생각할 수 있~니다---두 번째 변수를 무시할 뿐이지~요. 우리는 이것을 Haskell 정의에서 본 적이 있~습니다:","To see the connection, let's look at the product category $\\mathcal{C} \\times \\mathcal{C}$ as a functor category $[ \\mathbf{2}, \\mathcal{C}]$, in other words, the exponential object $\\mathcal{C}^{ \\mathbf{2}}$ in $\\mathbf{Cat}$. Indeed, a functor from $\\mathbf{2}$ (the stick-figure category with two objects) picks a pair of objects---which is equivalent to a single object in the product category.":"연결을 보기 위해, 곱 카테고리 $\\mathcal{C} \\times \\mathcal{C}$를 펑터 카테고리 $[ \\mathbf{2}, \\mathcal{C}]$로 보겠습니다, 즉 $\\mathbf{Cat}$에서의 지수 객체 $\\mathcal{C}^{ \\mathbf{2}}$로 보겠습니다. 실제로, $\\mathbf{2}$ (두 개의 객체를 가진 스틱 피규어 카테고리)에서의 펑터는 두 객체의 쌍을 선택하는데, 이것은 곱 카테고리에서의 단일 객체와 동등합니다.","A functor $\\mathcal{C} \\to [\\mathbf{2}, \\mathcal{C}]$ can be uncurried to $\\mathcal{C} \\times \\mathbf{2} \\to  \\mathcal{C}$. The diagonal functor ignores the second argument, the one coming from $\\mathbf{2}$: it does the same thing whether the second argument is $1$ or $2$. That's exactly what the constant functor does as well. This is why we use the same symbol $\\Delta$ for both.":"함자(펑터) $\\mathcal{C} \\to [\\mathbf{2}, \\mathcal{C}]$는 $\\mathcal{C} \\times \\mathbf{2} \\to  \\mathcal{C}$로 \"언커링\"(uncurring)될 수 있습니다. 대각 함자(다이애그널 펑터)는 두 번째 인자, 즉 $\\mathbf{2}$에서 오는 인자를 무시합니다: 두 번째 인자가 $1$이든 $2$이든 동일한 일을 합니다. 이것이 바로 상수 함자가 하는 일과 정확히 같습니다. 그래서 우리는 두 경우 모두 동일한 기호 $\\Delta$를 사용합니다.","Incidentally, this argument can be easily generalized to any indexing category, not just $\\mathbf{2}$.":"우연히도, 이 주장은 $\\mathbf{2}$뿐만 아니라 어떤 인덱싱 범주(카테고리)에도 쉽게 일반화될 수 있습니.","Recall that the sum is defined by its mapping out property. There is a one-to one correspondence between the arrows coming out of the sum $a + b$ and pairs of arrows coming from $a$ and $b$ separately. In terms of hom-sets, we can write it as:":"합(sum)이 매핑 아웃(mapping out) 속성에 의해 정의된다는 것을 기억하세요. 합 $a + b$ 에서 나오는 화살표들과 각각 $a$와 $b$에서 나오는 화살표 쌍 사이에 일대일 대응관계가 있습니다. 호멋셋(hom-sets) 용어로 표현하면 다음과 같습니다:","\\mathcal{C} (a + b, x) \\cong \\mathcal{C}( a , x) \\times \\mathcal{C}( b , x)":"\\mathcal{C} (a + b, x) \\cong \\mathcal{C}( a , x) \\times \\mathcal{C}( b , x)","where the product on the right-hand side is just a cartesian product of sets, that is the set of pairs. Moreover, we've seen earlier that this bijection is natural in $x$.":"오른쪽에 있는 곱은 단지 집합들의 데카르트 곱이었는데, 이는 쌍들의 집합입니다. 더욱이, 우리는 이 전단사가 $x$에 대해 자연스럽다는 것을 보았습니다.","We know that a pair of arrows is a single arrow in the product category. We can, therefore, look at the elements on the right-hand side as arrows in $\\mathcal{C} \\times \\mathcal{C}$ going from the object $\\langle a, b \\rangle$ to the object $\\langle x, x \\rangle$. The latter can be obtained by acting with the diagonal functor $\\Delta$ on $x$. We have:":"우리는 화살표(pair of arrows)의 쌍이 곱(category) 범주에서는 단일 화살표(single arrow)라는 것을 압니다. 따라서 오른쪽 요소들을 $\\mathcal{C} \\times \\mathcal{C}$의 화살표(arrows)로 볼 수 있으며, 이는 객체 $\\langle a, b \\rangle$에서 객체 $\\langle x, x \\rangle$로 가는 것입니다. 후자는 대각선 함자(diagonal functor) $\\Delta$를 $x$에 작용시켜 얻을 수 있습니다. 우리는 다음과 같이 갖습니다:","\\mathcal{C} (a + b, x) \\cong (\\mathcal{C} \\times \\mathcal{C})( \\langle a, b \\rangle , \\Delta x)":"\\mathcal{C} (a + b, x) \\cong (\\mathcal{C} \\times \\mathcal{C})( \\langle a, b \\rangle , \\Delta x)","This is a bijection between hom-sets in two different categories. It satisfies naturality conditions, so it's a natural isomorphism.":"이는 두 개의 서로 다른 카테고리에서 hom-집합 사이의 전단사 함수입니다. 이는 자연성 조건을 만족하므로 자연 동형사상입니다.","We can spot a pair of functors here as well. On the left we have the functor that takes a pair of objects $\\langle a, b \\rangle$ and produces their sum $a + b$:":"여기서도 함수자(functors) 한 쌍을 찾을 수 있습니다. 왼쪽에는 $\\langle a, b \\rangle$라는 객체 쌍을 받아서 그들의 합 $a + b$를 생성하는 함수자가 있습니다:","(+) \\colon \\mathcal{C} \\times \\mathcal{C} \\to \\mathcal{C}":"(+) \\colon \\mathcal{C} \\times \\mathcal{C} \\to \\mathcal{C}","On the right-hand side, we have the diagonal functor $\\Delta$ going in the opposite direction:":"오른쪽에서는 대각 함자 $\\Delta$가 반대 방향으로 가는데:","\\Delta \\colon \\mathcal{C} \\to  \\mathcal{C} \\times \\mathcal{C}":"\\Delta \\colon \\mathcal{C} \\to  \\mathcal{C} \\times \\mathcal{C}","Altogether, we have a pair of functors between a pair of categories:":"모두 합쳐서, 우리는 두 범주(category) 사이에 한 쌍의 함자(functor)를 가지고 있~니다:","and an isomorphism between the hom-sets:":"그리고 hom-집합들 간의 동형사상:","In other words, we have the adjunction:":"다른 말로 하면, 우리는 다음과 같은 adjunction(사상)을 갖습니다:","(+) \\dashv \\Delta":"(+) \\dashv \\Delta","We can apply the same reasoning to the definition of a product. This time we have a natural isomorphism between pairs of arrows and a mapping \\emph{into} the product.":"같은 논리를 곱의 정의에 적용할 수 있습니다. 이번에는 화살표(arrow)의 쌍과 곱으로 \\emph{들어가는} 사상(mapping) 사이에 자연스러운 동형사상(isomorphism)이 있습니다.","\\mathcal{C} (x, a) \\times \\mathcal{C}(x, b) \\cong  \\mathcal{C} (x, a \\times b)":"\\mathcal{C} (x, a) \\times \\mathcal{C}(x, b) \\cong  \\mathcal{C} (x, a \\times b)","Replacing pairs of arrows with arrows in the product category we get:":"쌍을 이루는 화살표들을 곱 카테고리(product category)에서 화살표들로 교체하면 다음과 같습니다:","(\\mathcal{C} \\times \\mathcal{C})( \\Delta x,  \\langle a, b \\rangle ) \\cong  \\mathcal{C} (x, a \\times b)":"(\\mathcal{C} \\times \\mathcal{C})( \\Delta x,  \\langle a, b \\rangle ) \\cong  \\mathcal{C} (x, a \\times b)","These are the two functors going in the opposite direction:":"이 두 가지 펑터는 반대 방향으로 갑니다:","and this is the isomorphism of hom-sets:":"그리고 이것이 사상 집합(hom-sets)의 동형사상입니다:","\\Delta \\dashv (\\times)":"\\Delta \\dashv (\\times)","In a bicartesian closed category products distribute over sums. We've seen one direction of the proof using universal constructions. Adjunctions combined with the Yoneda lemma give us more powerful tools to tackle this problem.":"이항 닫힌 범주에서는 곱이 합에 대해 분배됩니다(분배법칙). 우리는 이미 보편적 구성(유니버설 구성)을 사용하여 증명의 한 방향을 보았습니다. 부착(adjunction)과 요네다 보조정리를 결합하면 이 문제를 해결하기 위한 더 강력한 도구가 됩니다.","We want to show the natural isomorphism:":"자연 동형사상(natural isomorphism)을 보이고자 합니다:","(b + c) \\times a \\cong b \\times a + c \\times a":"(b + c) \\times a \\cong b \\times a + c \\times a","Instead of proving this identity directly, we'll show that the mappings out from both sides to an arbitrary object $x$ are isomorphic:":"직접적으로 이 항등식을 증명하는 대신, 양쪽에서 임의의 객체 $x$로의 사상들이 동형임을 보일 것입니다:","\\mathcal{C} ((b + c) \\times a, x) \\cong \\mathcal{C}(b \\times a + c \\times a, x)":"\\mathcal{C} ((b + c) \\times a, x) \\cong \\mathcal{C}(b \\times a + c \\times a, x)","The left hand side is a mapping out of a product, so we can apply the currying adjunction to it:":"좌변은 곱의 사상 하여 나가는 것이므로, 이를 커링 커패시티(curry adjunction)에 적용할 수 있습니다:","\\mathcal{C} ((b + c) \\times a, x) \\cong \\mathcal{C}(b + c, x^a)":"\\mathcal{C} ((b + c) \\times a, x) \\cong \\mathcal{C}(b + c, x^a)","This gives us a mapping out of a sum which, by the sum adjunction is isomorphic to the product of two mappings:":"이는 두 매핑의 곱과 동형인 합의 부속을 통해 합으로부터 매핑을 제공합니~다.","\\mathcal{C}(b + c, x^a) \\cong \\mathcal{C}(b, x^a) \\times \\mathcal{C}(c, x^a)":"\\mathcal{C}(b + c, x^a) \\cong \\mathcal{C}(b, x^a) \\times \\mathcal{C}(c, x^a)","We can now apply the inverse of the currying adjunction to both components:":"이제 currying 짝의 역함수를 두 구성 요소 모두에 적용할 수 있습니다:","\\mathcal{C}(b, x^a) \\times \\mathcal{C}(c, x^a) \\cong \\mathcal{C}(b \\times a, x) \\times \\mathcal{C}(c \\times a, x)":"\\mathcal{C}(b, x^a) \\times \\mathcal{C}(c, x^a) \\cong \\mathcal{C}(b \\times a, x) \\times \\mathcal{C}(c \\times a, x)","Using the inverse of the sum adjunction, we arrive at the final result:":"합의 부가 adjunction의 역을 사용하면, 우리는 최종 결과에 도달합니다:","\\mathcal{C}(b \\times a, x) \\times \\mathcal{C}(c \\times a, x) \\cong \\mathcal{C}(b \\times a + c \\times a, x)":"\\mathcal{C}(b \\times a, x) \\times \\mathcal{C}(c \\times a, x) \\cong \\mathcal{C}(b \\times a + c \\times a, x)","Every step in this proof was a natural isomorphism, so their composition is also a natural isomorphism. By Yoneda lemma, the two objects that form the left- and the right-hand side of distributivity law are therefore isomorphic.":"이 증명에서의 모든 단계는 자연 동형사상이었으므로, 이들의 합성 역시 자연 동형사상입니다. 요네다 보조정리에 의해 분배 법칙의 좌변과 우변에 있는 두 대상이 따라서 동형사상입니다.","A much shorter proof of this statement follows from the property of left adjoints that we'll discuss soon.":"이 명제의 훨씬 짧은 증명은 우리가 곧 논의할 왼쪽 수반(left adjoint)의 특성에서 따릅니다.","In general, an adjunction relates two functors going in opposite directions between two categories. The left functor":"일반적으로, 부여(adjunction)는 두 범주 사이에서 반대 방향으로 가는 두 함자를 연결~니다. 왼쪽 함자","L \\colon \\mathcal{D} \\to \\mathcal{C}":"L \\colon \\mathcal{D} \\to \\mathcal{C}","and the right functor:":"그리고 우함수(right functor)란:","R \\colon \\mathcal{C} \\to  \\mathcal{D}":"R \\colon \\mathcal{C} \\to  \\mathcal{D}","The adjunction $L \\dashv R$ is defined as a natural isomorphism between two hom-sets.":"수반 $L \\dashv R$은 두 호-집합 사이의 자연 동형으로 정의됩니다.","\\mathcal{C} (L x, y) \\cong \\mathcal{D}( x , R y)":"\\mathcal{C} (L x, y) \\cong \\mathcal{D}( x , R y)","In other words, we have a family of invertible functions between sets:":"다시 말해, 우리는 집합들 사이의 가역 함수들의 족을 가지고 있습니다:","\\phi_{x y} \\colon  \\mathcal{C} (L x, y) \\to \\mathcal{D}( x , R y)":"\\phi_{x y} \\colon  \\mathcal{C} (L x, y) \\to \\mathcal{D}( x , R y)","natural in both $x$ and $y$. For instance, naturality in $y$ means that, for any $f \\colon y \\to y'$ the following diagram commutes:":"$x$와 $y$ 모두에서 자명하다. 예를 들어, $y$에 대한 자명성(naturality)란 모든 $f \\colon y \\to y'$에 대하여 다음의 도식(diagram)이 가환(commutes)된다는 것을 의미한다:","or, considering that a lifting of arrows by hom-functors is the same as post-composition:":"혹은, hom-함수자(hom-functors)에 의한 화살의 올림이 사후 구성(post-composition)과 동일하다는 것을 고려하면:","The double-headed arrows can be traversed in either direction (using $\\phi^{-1}_{x y}$ when going up), since they are the components of an isomorphism.":"쌍방향 화살표(double-headed arrows)는 두 방향으로 이동할 수 있습니다 (위로 갈 때는 $\\phi^{-1}_{x y}$를 사용), 이는 그것들이 동형사상의 성분들이기 때문입니다.","Pictorially, we have two functors:":"그림으로 나타내면, 우리는 두 개의 함자(functors)를 가지고 있습니다:","and, for any pair $x$ and $y$, two isomorphic hom-sets:":"그리고, 임의의 쌍 $x$와 $y$에 대해, 두 동형 사상 집합:","These hom-sets come from two different categories, but sets are just sets. We say that $L$ is the left adjoint of $R$, or that $R$ is the right adjoint of $L$":"이 홈 세트(hoem-sets)는 두 개의 서로 다른 카테고리에서 나오지만, 세트(sets)는 단지 세트일 뿐입니다. 우리는 $L$이 $R$의 왼쪽 수반(left adjoint)이라고 하거나, $R$이 $L$의 오른쪽 수반(right adjoint)이라고 말합니다.","In Haskell, the simplified version of this could be encoded as a multi-parameter type class:":"하스켈(Haskell)에서, 이것의 단순화된 버전은 다중 매개변수 타입 클래스(multi-parameter type class)로 인코딩될 수 있습니 다:","It requires the following pragma at the top of the file:":"파일 상단에 다음과 같은 프라그마(pragma)를 요구합니다:","Therefore, in a bicartesian category, the sum is the left adjoint to the diagonal functor; and the product is its right adjoint. We can write this very concisely (or we could impress it in clay, in a modern version of cuneiform):":"따라서, \\이항수반(category)에서는 합(sum)은 대각 펑터의 왼쪽 수반(functor)이며, 곱(product)은 그 오른쪽 수반이다. 우리는 이를 매우 간결하게 쓸 수 있다 (또는 이를 점토에 새길 수도 있다. 현대적인 버전의 쐐기문자처럼).","(+) \\dashv \\Delta \\dashv (\\times)":"*동형사상*(isomorphism)은 $\\mathcal{C}$라는 \\emph{모든} 개체와 관계에 대해 동일한 역할을 합니다.따라서 $\\mathcal{C} \\cong \\mathcal{D}$는 $\\mathcal{C}$와 $\\mathcal{D}$가 \\emph{같은 구조를 가진다}는 것을 의미합니다.지금부터 카테고리 \\textbf{Sets}에 대해서만 이야기하겠습니다.앞의 유사 예시들은 형식적으로 \\emph{함수}(function)로 설명할 수 있습니다.구체적으로 다음과 같은 네 가지 형식이 있습니다:\\begin{description}  \\item[동형사상] 모든 $\\Delta \\in \\mathcal{C}$와 $\\Delta' \\in \\mathcal{C}$에 대해 $f \\circ g = \\operatorname{id}_{\\Delta}$와 $g \\circ f = \\operatorname{id}_{\\Delta'}$를 만족하는 $f:\\Delta \\to \\Delta'$와 $g:\\Delta' \\to \\Delta$가 존재합니다.  \\item[함수] 모든 $\\Delta, \\Delta' \\in \\mathcal{C}$에 대해 $f: \\Delta \\to \\Delta'$입니다.  \\item[단사함수](monomorphism) 모든 $g_1, g_2 : \\Delta \\to \\Delta'$에 대해 $f \\circ g_1 = f \\circ g_2 \\implies g_1 = g_2$를 만족하는 $f : \\Delta \\to \\Delta'$입니다.  \\item[전사함수](epimorphism) 모든 $g_1, g_2 : \\Delta' \\to \\Delta$에 대해 $g_1 \\circ f = g_2 \\circ f \\implies g_1 = g_2$를 만족하는 $f : \\Delta \\to \\Delta'$입니다.\\end{description}이제 이들의 예를 정리해 보겠습니다.","The definition of a limit also involves a natural isomorphism between hom-sets:":"극한의 정의는 hom-집합들 사이의 자연스러운 동형사상(isomorphism)을 포함합니다:","[\\cat J, \\mathcal{C}](\\Delta_x, D)  \\cong \\mathcal{C}(x, \\text{Lim} D)":"[\\cat J, \\mathcal{C}](\\Delta_x, D)  \\cong \\mathcal{C}(x, \\text{Lim} D)","The hom-set on the left is in the functor category. Its elements are cones, or natural transformations between the constant functor and the diagram functor. The one on the right is a hom-set in $\\mathcal{C}$.":"왼쪽의 hom-셋은 함자 범주(functor category)에 속합니다. 그 원소들은 원뿔(cones) 또는 상수 함자와 도형 함자(diagram functor) 사이의 자연 변환(natural transformations)입니다. 오른쪽의 것은 $\\mathcal{C}$에서의 hom-셋입니다.","In a category where all limits exist, we have the adjunction between these two functors:":"모든 극한이 존재하는 범주에서는 이 두 함자(functor) 사이에 수반(adjunction)이 있습니다:","\\Delta_{(-)} \\colon \\mathcal{C} \\to  [\\cat J, \\mathcal{C}]":"\\Delta_{(-)} \\colon \\mathcal{C} \\to  [\\cat J, \\mathcal{C}]","\\text{Lim}{(-)} \\colon  [\\cat J, \\mathcal{C}] \\to \\mathcal{C}":"\\text{Lim}{(-)} \\colon  [\\cat J, \\mathcal{C}] \\to \\mathcal{C}","Dually, the colimit is described by the following natural isomorphism:":"이중적으로, 쌍대극한(colimit)은 다음의 자연 동형(natural isomorphism)에 의해 설명됩니:","[\\cat J, \\mathcal{C}](D, \\Delta_x)  \\cong \\mathcal{C}( \\text{Colim} D, x)":"[\\cat J, \\mathcal{C}](D, \\Delta_x)  \\cong \\mathcal{C}( \\text{Colim} D, x)","We can write both adjunctions using one terse formula:":"두 부착(adjunction)을 하나의 간결한 공식으로 쓸 수 있 ~습니다:$ \\eta: Id \\rightarrow GF : F \\dashv G : G \\dashv F $","\\text{Colim} \\dashv \\Delta \\dashv \\text{Lim}":"\\text{Colim} \\dashv \\Delta \\dashv \\text{Lim}","In particular, since the product category $\\cat C \\times \\cat C$ is equivalent to $\\cat C^2$, or the functor category $[\\mathbf{2}, \\cat C]$, we can rewrite a product and a coproduct as a limit and a colimit:":"특히, $\\cat C \\times \\cat C$ 곱 카테고리(category)는 $\\cat C^2$ 또는 함자 카테고리(functor category) $[\\mathbf{2}, \\cat C]$와 동치이므로, 곱(product)과 쌍대곱(coproduct)을 극한(limit)과 공극한(colimit)으로 다시 쓸 수 있습니니다.","[\\mathbf{2}, \\cat C](\\Delta_x, \\langle a, b \\rangle) \\cong \\cat C(x, a \\times b)":"[\\mathbf{2}, \\cat C](\\Delta_x, \\langle a, b \\rangle) \\cong \\cat C(x, a \\times b)","\\cat C( a + b, x) \\cong [\\mathbf{2}, \\cat C]( \\langle a, b \\rangle, \\Delta_x)":"\\cat C( a + b, x) \\cong [\\mathbf{2}, \\cat C]( \\langle a, b \\rangle, \\Delta_x)","where $\\langle a, b \\rangle$ denotes a diagram that is the action of a functor $D \\colon \\mathbf{2} \\to \\cat C$ on the two objects of $\\mathbf{2}$.":"$\\langle a, b \\rangle$는 함수자(functor) $D \\colon \\mathbf{2} \\to \\cat C$가 $\\mathbf{2}$의 두 객체에 작용한 결과인 다이어그램(diagram)을 나타냅니다.","We compare arrows for equality, but we prefer to use isomorphisms for comparing objects.":"화살표(arrow)의 동등성을 비교하지만, 객체(object)를 비교할 때는 동형사상(isomorphism)을 사용하는 것을 선호합니다.","We have a problem when it comes to functors, though. On the one hand, they are objects in the functor category, so isomorphisms are the way to go; on the other hand, they are arrows in $\\mathbf{Cat}$ so maybe it's okay to compare them for equality?":"함자(functor)에 관한 문제는 존재합니다. 한편으로, 그들은 함자 범주(functor category)의 객체이므로 동형(Isomorphisms)이 적절합니다; 다른 한편으로, 그들은 $\\mathbf{Cat}$의 사상(arrow)이므로 동일성(equality)으로 비교해도 괜찮지 않을까요?","To shed some light on this dilemma, we should ask ourselves \\emph{why} we use equality for arrows. It's not because we like equality, but because there's nothing else for us to do in a set but to compare elements for equality. Two elements of a hom-set are either equal or not, period.":"이 딜레마에 대해 좀 더 밝히기 위해, 우리는 왜 화살들에 대해 동일성(equal)을 사용하는지 \\emph{물어봐야} 합니다. 우리가 동일성을 좋아해서가 아니라, 집합에서 우리가 할 수 있는 것이 요소들을 동일성으로 비교하는 것밖에 없기 때문입니다. 동형사슬집합의 두 요소는 동일하거나 그렇지 않거나 합니다, 끝.","That's not the case in  $\\mathbf{Cat}$ which, as we know, is a $2$-category. Here, hom-sets themselves have the structure of a category---the functor category. In a $2$-category we have arrows between arrows so, in particular, we can define isomorphisms between arrows. In $\\mathbf{Cat}$ these would be natural isomorphisms between functors.":"$\\mathbf{Cat}$에서는 그렇지 않습니다. $\\mathbf{Cat}$는 우리가 알다시피 $2$-범주($2$-category)입니다. 여기서 hom-집합들(hom-sets) 자체가 범주(category)의 구조를 가집니다---펑터 범주(functor category)입니다. $2$-범주에서는 화살표들 간의 화살표들이 있어서, 특히 화살표들 간의 동형사상(isomorphisms)을 정의할 수 있습니다. $\\mathbf{Cat}$에서는 이러한 것들이 펑터들 간의 자연 동형사상(natural isomorphisms)일 것입니다.","However, even though we have the option of replacing arrow equalities with isomorphisms, categorical laws in $\\mathbf{Cat}$ are still expressed as equalities. For instance, the composition of a functor $F$ with the identity functor is \\emph{equal} to $F$, and the same for associativity. A $2$-category in which the laws are satisfied ``on the nose'' is called \\emph{strict}, and $\\mathbf{Cat}$ is an example of a strict $2$-category.":"그러나 화살표(arrow) 등식을 동형사상(isomorphisms)으로 대체할 수 있는 선택지가 있다 하더라도, $\\mathbf{Cat}$에서의 범주적 법칙(categorical laws)은 여전히 등식으로 표현됩니다. 예를 들어, 함자(functor) $F$와 항등 함자(identity functor)의 합성은 $F$와 \\emph{동일}하며, 결합 법칙(associativity)에서도 동일합니다. 법칙들이 \"있는 그대로(on the nose)\" 만족되는 $2$-범주를 \\emph{엄격한(strict)} $2$-범주라고 하며, $\\mathbf{Cat}$은 엄격한 $2$-범주의 예입니다.","But as far as comparing categories goes, we have more options. Categories are objects in $\\mathbf{Cat}$, so it's possible to define an isomorphism of categories as a pair of functors $L$ and $R$:":"하지만 범주들을 비교하는 것에 대해서는 더 많은 선택지가 있습나다. 범주는 $\\mathbf{Cat}$의 객체들이므로 범주의 동형사상(isomorphism of categories)을 사상자(L)와 사상자(R)의 쌍으로 정의할 수 있습니다:","such that:":"그렇게 하여:","This definition involves equality of functors, though. What's worse, acting on objects, it involves equality of objects:":"이 정의는 함자의 동등성을 포함합니다. 더 나쁜 것은, 객체에 작용할 때, 그것은 객체의 동등성을 포함합니다:","This is why it's more proper to talk about a weaker notion of \\emph{equivalence} of categories, where equalities are replaced by isomorphisms:":"여기서 카테고리들의 \\emph{동등(equivalence)}의 더 약한 개념에 대해 이야기하는 것이 더 적절합니다. 이때 등식(equalities)은 동형사상(isomorphisms)으로 대체됩니다:","On objects, an equivalence of categories means that a round trip produces an object that is isomorphic, rather than equal, to the original one. In most cases, this is exactly what we want.":"대상(object)에 대해, 범주의 동치(equivalence of categories)는 왔다 갔다하는 과정이 원래의 대상과 동치(isomorphic)인, 즉 같지 않은 대상으로 만들어질 것을 의미합니다. 대부분의 경우, 이것이 우리가 정말로 원하는 것입니다.","An adjunction is also defined as a pair of functors going in opposite directions, so it makes sense to ask what the result of a round trip is.":"사상(함자, functor) 쌍은 서로 반대 방향으로 움직이기 때문에, 한 번 왕복했을 때의 결과가 무엇인지 물어보는 것도 의미가 있 ~니다.","The isomorphism that defines an adjunction works for any pair of objects $x$ and $y$":"사상을 정의하는 동형사상(isomorphism)은 모든 객체(object) 쌍 $x$와 $y$에 대해 작동합니다.","so, in particular, we can replace $y$ with $L x$":"그러므로, 특히 우리는 $y$를 $L x$로 대체할 수 있읍니다.","\\mathcal{C} (L x, L x) \\cong \\mathcal{D}( x , R (L x))":"\\mathcal{C} (L x, L x) \\cong \\mathcal{D}( x , R (L x))","We can now use the Yoneda trick and pick the identity arrow $id_{L x}$ on the left. The isomorphism maps it to a unique arrow on the right, which we'll call $\\eta_x$:":"이제 요네다 트릭을 사용할 수 있으며, 왼쪽에서 항등 화살표 $id_{L x}$를 선택합니다. 이러한 동형 사상은 이를 오른쪽의 고유한 화살표로 매핑하며, 이를 $\\eta_x$라고 부르겠습니다:","\\eta_x \\colon x \\to R ( L x)":"\\eta_x \\colon x \\to R ( L x)","Not only is this mapping defined for every $x$, but it's also natural in $x$. The natural transformation $\\eta$ is called the \\emph{unit} of the adjunction. If we observe that the $x$ on the left is the action of the identity functor on $x$, we can write:":"이 매핑(mapping)은 모든 $x$에 대해 정의될 뿐만 아니라, $x$에 대해 자연스럽~니다. 자연 변환 $\\eta$는 \\emph{adjunction의 단위(unit)}라고 불립~니다. 만약 우리가 왼쪽의 $x$가 $x$에 대한 항등 함자(identity functor)의 작용임을 관찰하면, 다음과 같이 쓸 수 있~니다:","\\eta \\colon \\text{Id}_{\\mathcal{D}} \\to R \\circ L":"\\eta \\colon \\text{Id}_{\\mathcal{D}} \\to R \\circ L","As an example, let's evaluate the unit of the coproduct adjunction:":"예를 들어, 쌍대곱수를 갖는 부여의 단위원(unit)에 대해 평가해 봅시다:","by replacing $x$ with $a + b$. We get:":"$x$를 $a + b$로 대체하면 다음을 얻습니다:","\\eta_{\\langle a, b \\rangle} \\colon \\langle a, b \\rangle \\to \\Delta(a + b)":"\\eta_{\\langle a, b \\rangle} \\colon \\langle a, b \\rangle \\to \\Delta(a + b)","This is a pair of arrows that are exactly the two injections $\\langle \\text{Left}, \\text{Right} \\rangle$.":"이는 정확히 두 개의 삽입 $\\langle \\text{Left}, \\text{Right} \\rangle$인 화살표 쌍입니다.","We can do a similar trick by replacing $x$ with $R y$:":"우리는 $x$를 $R y$로 대체하여 비슷한 트릭을 할 수 있습니니다:","\\mathcal{C} (L (R y), y) \\cong \\mathcal{D}( R y , R y)":"\\mathcal{C} (L (R y), y) \\cong \\mathcal{D}( R y , R y)","Corresponding to $id_{R y}$ on the right, we get a family of arrows on the left:":"$R y$의 항등사상($id_{R y}$)에 대응하여, 우리는 왼쪽에서의 화살표들의 가족을 얻습니다:","\\varepsilon_y \\colon L (R y) \\to y":"\\varepsilon_y \\colon L (R y) \\to y","which form another natural transformation called the \\emph{counit} of the adjunction:":"이를 통해 또 다른 자연 변환(natural transformation)을 형성하게 되며, 이를 \\emph{adjunction의 counit}이라 부릅니다:","\\varepsilon \\colon L \\circ R \\to \\text{Id}_{\\mathcal{C}}":"\\varepsilon \\colon L \\circ R \\to \\text{Id}_{\\mathcal{C}}","Notice that, if those two natural transformations were invertible, they would witness the equivalence of categories. But this kind of ``half-equivalence'' is even more interesting in the context of category theory.":"주목하길 바랍니다, 만약 그 두 자연 변환(natural transformations)이 가역적이었다면, 그것들은 범주의 동치를 증명했을 것입니다. 하지만 이러한 종류의 ``반-동치(half-equivalence)''는 범주 이론(category theory)의 맥락에서 더욱 흥미롭습니다.","As an example, let's evaluate the counit of the product adjunction:":"예를 들어, 곱 조합의 counit(보조사)에 대해 평가해 봅시다:","by replacing $x$ with $a \\times b$. We get:":"$x$를 $a \\times b$로 대체하면 우리는 다음을 얻습니다:","\\varepsilon_{\\langle a, b \\rangle} \\colon \\Delta (a \\times b) \\to \\langle a, b \\rangle":"\\varepsilon_{\\langle a, b \\rangle} \\colon \\Delta (a \\times b) \\to \\langle a, b \\rangle","This is a pair of arrows that are exactly the two projections $\\langle \\text{fst}, \\text{snd} \\rangle$.":"이것은 정확히 두 사영 $\\langle \\text{fst}, \\text{snd} \\rangle$ 인 화살표 쌍입니다.","We can use the unit/counit pair to formulate an equivalent  definition of an adjunction. To do that, we start with a pair of natural transformations:":"유닛/카운잇(unit/counit) 쌍을 사용하여 동형사상(adjunction)의 동등한 정의를 공식화할 수 있습니니다. 이를 위해, 자연 변환의 쌍을 시작합니다:","and impose additional \\emph{triangle identities}.":"그리고 추가적인 \\emph{삼각형 항등식}(triangle identities)을 부과합니다.","These identities can be derived from the standard definition of the adjunction by noticing that $\\eta$ can be used to replace an identity functor with the composite $R \\circ L$, effectively letting us insert $R \\circ L$ anywhere an identity functor would work.":"이 항등식들은 $\\eta$가 항등 함자를 $R \\circ L$ 복합 함수자로 대체할 수 있다는 사실을 알아차림으로써 표준 부여 정의에서 도출할 수 있습니. 그렇게 하면 항등 함자가 작동하는 어디에든 $R \\circ L$을 삽입할 수 있게 됩니.","Similarly, $\\varepsilon$ can be used to eliminate the composite $L \\circ R$ (i.e., replace it with identity).":"마찬가지로, $\\varepsilon$를 사용하여 합성 $L \\circ R$를 제거할 수 있습니다(즉, 이를 항등원으로 대체).","So, for instance, starting with $L$:":"그래서 예를 들어 $L$에서 시작하면:","L = L \\circ \\text{Id}_{\\mathcal{D}} \\xrightarrow{L \\circ \\eta} L \\circ R \\circ L \\xrightarrow{\\varepsilon \\circ L} \\text{Id}_{\\mathcal{C}} \\circ L = L":"L = L \\circ \\text{Id}_{\\mathcal{D}} \\xrightarrow{L \\circ \\eta} L \\circ R \\circ L \\xrightarrow{\\varepsilon \\circ L} \\text{Id}_{\\mathcal{C}} \\circ L = L","Here, we used the horizontal composition of natural transformation, with one of them being the identity transformation (a.k.a., whiskering).":"여기서 우리는 자연 변환의 수평 조성(whiskering) 중 하나를 항등 변환으로 사용하였습니다.","The first triangle identity is the condition that this chain of transformations result in the identity natural transformation. Pictorially:":"첫 번째 삼각형 항등식(트라이앵글 아이덴티티)은 이 변환의 연쇄(chain)가 항등 자연 변환(identity natural transformation)을 결과로 하게 만드는 조건입니다. 그림으로:","Similarly, we want the following chain of natural transformations to also compose to identity:":"비슷하게, 우리는 다음의 자연 변환(natural transformations)들의 체인(chain)도 항등으로 합성되기를 원합니다:","R = \\text{Id}_{\\mathcal{D}} \\circ R \\xrightarrow{\\eta \\circ R} R \\circ L \\circ R \\xrightarrow{R \\circ \\varepsilon} R \\circ \\text{Id}_{\\mathcal{C}} = R":"R = \\text{Id}_{\\mathcal{D}} \\circ R \\xrightarrow{\\eta \\circ R} R \\circ L \\circ R \\xrightarrow{R \\circ \\varepsilon} R \\circ \\text{Id}_{\\mathcal{C}} = R","or, pictorially:":"또는, 그림으로:","It turns out that an adjunction can be alternatively defined in terms of the two natural transformations, $\\eta$ and $\\varepsilon$ satisfying the  triangle identities:":"사상 $\\eta$와 $\\varepsilon$ 두 자연 변환에 의해 삼각 항등식을 만족하는 부가 정의될 수 있 ~니다:","From those, the mapping of hom-sets can be easily recovered. For instance, let's start with an arrow $f \\colon x \\to R y$, which is an element of $\\mathcal{D}( x , R y)$. We can lift it to":"이들로부터 hom-집합(hom-sets)의 사상(mapping)을 쉽게 복원할 수 있습니다. 예를 들어, $f \\colon x \\to R y$라는 화살표(arrow)로 시작해 보겠습니다. 이는 $\\mathcal{D}( x , R y)$의 원소입니다. 우리는 이를 들어올릴(lift) 수 있습니다.","L f \\colon L x \\to L (R y)":"L f \\colon L x \\to L (R y)","We can then use $\\eta$ to collapse the composite $L \\circ R$ to identity. The result is an arrow $L x \\to y$, which is an element of $ \\mathcal{C} (L x, y)$.":"그 후 우리는 $\\eta$를 사용하여 합성 $L \\circ R$을 항등원으로 축소할 수 있습니 다. 결과는 $L x \\to y$라는 화살표로, 이는 $\\mathcal{C}(L x, y)$의 요소입니 다.","The definition of the adjunction using unit and counit is more general in the sense that it can be translated to an arbitrary 2-category setting.":"단위원(unit)과 공단위원(counit)으로 정의된 대응(adjunction)의 정의는 임의의 2-범주(2-category) 설정으로 번역될 수 있다는 점에서 더욱 일반적입니다.","Let's calculate the unit and the counit of the currying adjunction:":"단위(unit)와 counit(역단위(counit))의 커링(adjunction)을 계산해 봅시다:","If we replace $b$ with $e \\times a$, we get":"만약 우리가 $b$를 $e \\times a$로 대체하면, 우리는","\\mathcal{C}(e \\times a, e \\times a ) \\cong  \\mathcal{C} (e, (e \\times a)^a)":"\\mathcal{C}(e \\times a, e \\times a ) \\cong  \\mathcal{C} (e, (e \\times a)^a)","Corresponding to the identity arrow on the left, we get the unit of the adjunction on the right:":"왼쪽의 항등 화살표(arrow)에 대응하여, 오른쪽에 수반(adjunction)의 단위(unit)가 생깁니다.","\\eta \\colon e \\to (e \\times a)^a":"\\eta \\colon e \\to (e \\times a)^a","This is a curried version of the product constructor. In Haskell, we write it as:":"이것은 곱(곱셈) 생성자의 커리된(curry) 버전입니다. Haskell에서는 이를 다음과 같이 씁니다:","The counit is more interesting. Replacing $e$ with $b^a$ we get:":"역항공리(counit)는 더 흥미롭습니다. $e$를 $b^a$로 대체하면 다음과 같이 됩니다:","\\mathcal{C}(b^a \\times a, b ) \\cong  \\mathcal{C} (b^a, b^a)":"\\mathcal{C}(b^a \\times a, b ) \\cong  \\mathcal{C} (b^a, b^a)","Corresponding to the identity arrow on the right, we get:":"오른쪽의 항등 화살표에 해당하는 것은 다음과 같습니다:","\\varepsilon \\colon b^a \\times a \\to b":"\\varepsilon \\colon b^a \\times a \\to b","which is the function application arrow.":"이는 함수 적용 화살표입니다.","In Haskell:":"하스켈(Haskell)에서:","When the adjunction is between two endofunctors, we can write an alternative Haskell definition of it using the unit and the counit:":"그 부여가 두 자기 함자(endofunctors) 사이에 있을 때, 우리는 유닛(unit)과 카운트(counit)를 사용하여 그 부여의 대안적인 Haskell 정의를 쓸 수 있습니다:","The additional two clauses \\hask{left -> right} and \\hask{right -> left} tell the compiler that, when using an instance of the adjunction, one functor can be derived from the other. This definition requires the following compile extensions:":"추가된 두 가지 조항 \\hask{left -> right} 및 \\hask{right -> left}는 조합의 인스턴스를 사용할 때 하나의 함자가 다른 함자로부터 유도될 수 있음을 컴파일러에 알려줍니다. 이 정의는 다음의 컴파일 확장 기능들을 필요로 합니다:","The two functors that form the currying adjunction can be written as:":"두 함자(functor)로 구성된 커링(adjunction) 수반 함자는 다음과 같이 쓸 수 있습니 다:","and the \\hask{Adjunction} instance for currying is:":"and the \\hask{Adjunction} 인스턴스(instance) 커링(currying)은:","The first triangle identity states that the following polymorphic function:":"첫 번째 삼각형 항등식은 다음과 같은 다형 함수(polymorphic function)를 나타냅니다:","is the identity, and so is the second one:":"첫 번째 것은 항등사상(Identity)이고 두 번째 것도 그렇습니다.","Notice that these two functions require the use of functional dependencies to be well defined. Triangle identities cannot be expressed in Haskell, so it's up to the implementor of the adjunction to prove them.":"이 두 함수는 잘 정의되기 위해 함수적 종속성(Functional Dependencies)의 사용이 필요함을 주의하세요. 삼각형 항등식(Triangle identities)은 Haskell에서 표현될 수 없기 때문에 이를 증명하는 것은 부호자의 몫입니다.","We've seen the definition of an adjunction using the isomorphism of hom-sets, and another one using the pair of unit/counit. It turns out that we can define an adjunction using just one element of this pair, as long as it satisfies certain universality condition. To see that, we will construct a new category whose objects are arrows.":"우리는 hom-집합(isomorphism of hom-sets)의 동형성을 이용한 조합(adjunction)의 정의와 unit/counit 쌍을 이용한 또 다른 정의를 보았습니다. 특정한 보편성 조건을 만족하는 한, 이 쌍의 하나의 요소만을 사용하여 조합을 정의할 수 있습니다. 이를 확인하기 위해, 우리는 화살표들을 객체로 하는 새로운 범주(category)를 구성할 것입니다.","We've seen before an example of such a category---the slice category $\\cat C/ c$ that collects all the arrows that converge on $c$. Such a category describes the view of the object $c$ from every possible angle in $\\cat C$.":"이전에 이러한 카테고리의 예시를 본 적이 있었습니다---모든 화살표가 $c$에 수렴하는 슬라이스 카테고리 $\\cat C/ c$입니다. 이러한 카테고리는 $\\cat C$에서 가능한 모든 각도에서 객체 $c$를 바라보는 관점을 설명합니다.","When dealing with an adjunction:":"수반(adjunction)을 다룰 때:","\\mathcal{C} (L d, c) \\cong \\mathcal{D}( d , R c)":"\\mathcal{C} (L d, c) \\cong \\mathcal{D}( d , R c)","we are observing the object $c$ from a narrower perspective defined by the functor $L$. Think of $L$ as defining a model of the category $\\cat D$ inside $\\cat C$. We are interested in the view of $c$ from the perspective of this model. The arrows that describe this view form the comma category $L/c$.":"우리는 함자(functor) $L$에 의해 정의된 좁은 관점에서 객체(object) $c$를 관찰하고 있습니다. $L$을 범주 $\\cat D$의 모형을 $\\cat C$ 안에 정의하는 것으로 생각해 보세요. 우리는 이 모형의 관점에서 $c$를 보는 것에 관심이 있습니다. 이 관점을 설명하는 화살표들은 쉼표 범주 $L/c$를 형성합니다.","An object in the \\index{comma category}\\emph{comma category} $L/c$ is a pair $\\langle d, f \\rangle$, where $d$ is an object of $\\cat D$ and $f \\colon L d \\to c$ is an arrow in $\\cat C$.":"\\texttt{comma 범주}\\emph{comma 범주} $L/c$의 객체는 쌍 $\\langle d, f \\rangle$로, 여기서 $d$는 $\\cat D$의 객체이고 $f \\colon L d \\to c$는 $\\cat C$의 화살표입니다.","A morphism from $\\langle d, f \\rangle$ to $\\langle d', f' \\rangle$ is an arrow $h \\colon d \\to d'$ that makes the diagram on the left commute:":"$\\langle d, f \\rangle$에서 $\\langle d', f' \\rangle$로 가는 사상(arrow)은 아래의 왼쪽 다이어그램을 가환하게 하는 사상 $h \\colon d \\to d'$입니다:","The universal arrow from $L$ to $c$ is defined as the terminal object in the comma category $L / c$. Let's unpack this definition. The terminal object is a pair $\\langle t, \\tau \\rangle$ with a unique morphism from any object $\\langle d, f \\rangle$. Such a morphism is an arrow $h \\colon d \\to t$ that satisfies the commuting condition:":"$L$에서 $c$로 가는 유니버설 화살표는 콤마 카테고리 $L / c$에서 종말 대상으로 정의됩니다. 이 정의를 풀어보겠습니다. 종말 대상은 어떤 대상 $\\langle d, f \\rangle$에서 유일한 사상을 가지는 쌍 $\\langle t, \\tau \\rangle$입니다. 이러한 사상은 다음의 교환 조건을 만족하는 화살표 $h \\colon d \\to t$입니다:","In other words, for any $f$ in the hom-set $\\cat C (L d, c)$ there is a unique element $h$ in the hom-set $\\cat D (d, t)$ such that:":"즉, $\\cat C (L d, c)$에 있는 모든 $f$에 대해 $\\cat D (d, t)$에 있는 고유한 원소 $h$가 존재합니다. 여기서:","f = \\tau \\circ L h":"f = \\tau \\circ L h","Such a one-to-one mapping between elements of two hom-sets hints at the underlying adjunction.":"이러한 두 동형 사상의 원소 간의 일대일 대응은 기저의 부여론(adjunction) 을 암시합니다.","Let's first convince ourselves that, when the functor $L$ has a right adjoint $R$, then for every $c$ there exists a universal arrow from $L$ to $c$. Indeed, this arrow is given by the pair $\\langle R c, \\varepsilon_c \\rangle$, where $\\varepsilon$ is the counit of the adjunction. First of all, the component of the counit has the right signature for the object in the comma category $L/c$:":"먼저 함자 $L$이 오른쪽 수반 함자 $R$을 가질 때, 모든 $c$에 대해 $L$에서 $c$로의 보편 화살표(universal arrow)가 존재함을 자신에게 납득시켜 봅시다. 실제로, 이 화살표는 $\\langle R c, \\varepsilon_c \\rangle$ 쌍에 의해 주어지며, 여기서 $\\varepsilon$는 수반(adjunction)의 counit 입니다. 먼저, counit의 구성 요소는 콤마 카테고리 $L/c$의 객체에 대해 올바른 서명을 가지고 있습니다.","\\varepsilon_c \\colon L (R c) \\to c":"\\varepsilon_c \\colon L (R c) \\to c","We'd like to show that $\\langle R c, \\varepsilon_c \\rangle$ is the terminal object in $L/c$. That is, for any object $\\langle d, f \\colon L d \\to c \\rangle$ there is a unique $h \\colon d \\to R c$ such that $f = \\varepsilon_c \\circ L h$:":"$\\langle R c, \\varepsilon_c \\rangle$가 $L/c$에서 말단 객체(terminal object)임을 보이고 싶습니다. 즉, 어떤 객체 $\\langle d, f \\colon L d \\to c \\rangle$에 대해서도 $f = \\varepsilon_c \\circ L h$를 만족하는 유일한 $h \\colon d \\to R c$가 존재합니다.","To prove this, let's write one of the naturality conditions for $\\phi_{d c}$ as the function of $d$:":"이를 증명하기 위해, $\\phi_{d c}$의 자연성 조건 중 하나를 $d$의 함수로 작성해 봅시다:","\\phi_{d c} \\colon \\mathcal{C} (L d, c) \\to \\mathcal{D}( d , R c)":"\\phi_{dc} \\colon \\mathcal{C} (L d, c) \\to \\mathcal{D}( d , R c)","For any arrow $h \\colon d \\to d'$ the following diagram must commute:":"어떠한 화살표 $h \\colon d \\to d'$에 대해서도 다음의 도형(diagram)이 가환(commute)해야 합니다:","We can use the Yoneda trick by setting $d'$ to $R c$.":"우리는 $d'$을 $R c$로 설정하여 Yoneda 트릭을 사용할 수 있습니.","We can now pick the special element of the hom-set $\\cat D(R c, R c)$, namely the identity arrow $id_{R c}$ and propagate it through the rest of the diagram. The upper left corner becomes $\\varepsilon_c$, the lower right corner becomes $h$, and the upper right corner becomes the adjoint to $h$, which we called $f$:":"이제 우리는 hom-set $\\cat D(R c, R c)$의 특수 요소, 즉 항등 화살표 $id_{R c}$를 선택하고 이를 다이어그램의 나머지 부분으로 전파할 수 있습니다. 왼쪽 위 모퉁이는 $\\varepsilon_c$가 되고, 오른쪽 아래 모퉁이는 $h$가 되며, 오른쪽 위 모퉁이는 $h$의 adjoint(수반사)에 해당하는 $f$가 됩니다.","The upper arrow then gives us the sought after equality $f = \\varepsilon_c \\circ L h$.":"위쪽 화살표는 우리가 추구하는 등식 $f = \\varepsilon_c \\circ L h$를 제공합니다.","The converse result is even more interesting. If, for every $c$, we have a universal arrow from $L$ to $c$, that is a terminal object $\\langle t_c, \\varepsilon_c \\rangle$ in the comma category $L/c$, then we can construct a functor $R$ that is the right adjoint to $L$. The action of this functor on objects is given by $R c = t_c$, and the family $\\varepsilon_c$ is automatically natural in $c$, and it forms the counit of the adjunction.":"반대의 결과는 더욱 흥미롭습니다. 만약 모든 $c$에 대해 $L$에서 $c$로의 유일한 화살이 존재해서 콤마 카테고리 $L/c$에서 종단 객체 $\\langle t_c, \\varepsilon_c \\rangle$를 형성한다면, 우리는 $L$의 오른쪽 수반 함자(functor)인 $R$을 구성할 수 있습니다. 이 함자의 객체에 대한 동작은 $R c = t_c$로 주어지며, $\\varepsilon_c$는 자동으로 $c$에 대해 자연스럽게 되고, 이는 수반의 공역(counit)을 형성합니다.","There is also a dual statement: An adjunction can be constructed starting from a family of universal arrows $\\eta_d$, which form initial objects in the comma category $d/R$.":"이중적 명제도 있습니 다: 상대성(Adjunction)은 $d/R$의 콤마 범주에서 초기 객체를 형성하는 유도 화살표 $\\eta_d$의 집합에서 시작하여 구성할 수 있습니다.","These results will help us prove the Freyd's adjoint functor theorem.":"이 결과들은 프레이드의 수반 함자 \\textit{정리}(Freyd's adjoint functor theorem)를 증명하는 데 도움이 될 것~입니다.","Colimits were defined as universal cocones. For every cocone---that is a natural transformation from the diagram $D \\colon \\cat J \\to \\cat C$ to the constant functor $\\Delta_x$---there is a unique factorizing morphism from the colimit $\\text{Colim}\\, D$ to $x$. This condition can be written as a one-to-one correspondence between the set of cocones and a hom-set:":"여기서 극한(Colimit)은 보편(Universal) 쌍곡선(cocone)으로 정의되었~니다. 모든 쌍곡선---즉, 도형 $D \\colon \\cat J \\to \\cat C$에서 상수 함자(Constant Functor) $\\Delta_x$로의 자연 변환---에 대해 유일한 분해 사상(Morphisms)이 극한 $\\text{Colim}\\, D$에서 $x$로 존재한~니다. 이 조건은 쌍곡선 집합과 동형 사상 집합(hom-set) 간의 일대일 대응으로 표현될 수 있~니다:","[\\cat J, \\mathcal{C}](D, \\Delta_x)  \\cong \\mathcal{C}( \\text{Colim} \\, D, x)":"[\\cat J, \\mathcal{C}](D, \\Delta_x)  \\cong \\mathcal{C}( \\text{Colim} \\, D, x)","The factorizing condition is encoded in the naturality of this isomorphism.":"이 분해 조건은 이 동형사상의 자연성(naturality)에 의해 인코딩됩니다.","It turns out that the set of cocones, which is itself an object in $\\Set$, is a limit of the following $\\Set$-valued functor $F \\colon \\cat J \\to \\Set$:":"결국 동체(cones)의 집합, 그 자체로 $\\Set$의 대상이 되는 집합은 다음과 같은 $\\Set$ 값 함수자 $F \\colon \\cat J \\to \\Set$의 극한임이 밝혀졌습니다:","F j = \\cat C(D j, x)":"F j = \\cat C(D j, x)","To show this, we'll start with the limit of $F$ and end up with the set of cocones. You may recall that a limit of a $\\Set$-valued functor is equal to a set of cones with the apex $1$ (the singleton set). In our case, each such cone describes a selection of morphisms from the corresponding hom-set $\\cat C(D j, x)$:":"이를 보여주기 위해, $F$의 극한(limit)에서 시작하여 코콘(cocones)의 집합으로 끝낼 것입니다. $\\Set$ 값을 가지는 함자(functor)의 극한이 그 꼭짓점이 1(단일집합)인 원뿔(cones)의 집합과 같다는 것을 기억할 수 있을 것입니다. 우리 경우에는, 각각의 이러한 원뿔은 해당 호므셋(hom-set) $\\cat C(D j, x)$로부터의 사상의 선택을 설명합니다:","Each of these morphisms has as target the same object $x$, so they form the sides of a cocone with the apex $x$.":"이 각각의 사상들은 동일한 대상 $x$로의 목표를 가지므로, 이들은 꼭짓점 $x$를 가진 공모형(cocone)을 구성합니다.","The commuting conditions for the cone with the apex $1$ are simultaneously the commuting condition for this cocone with the apex $x$. But these are exactly the cocones in the set $ [\\cat J, \\mathcal{C}](D, \\Delta_x)$.":"이 꼭지점이 $1$인 원뿔에 대한 가환 조건들은 동시에 이 꼭지점이 $x$인 공원뿔에 대한 가환 조건들입니다. 그러나 이것들은 정확히 집합 $[\\cat J, \\mathcal{C}](D, \\Delta_x)$에서의 공원뿔들입니다.","We can therefore replace the original set of cocones with the limit of $\\cat C (D-, x)$ to get:":"따라서 원래의 코코넬 집합을 $\\cat C (D-, x)$의 극한(limit)으로 대체할 수 있습니다:","\\text{Lim}\\; \\cat C (D-, x) \\cong \\cat C( \\text{Colim}\\,  D, x)":"\\text{한계}\\; \\cat C (D-, x) \\cong \\cat C( \\text{쌍대한계}\\,  D, x)","The limit of a (contravariant) hom-functor acting on a diagram $D$ is isomorphic to the hom-functor acting on a colimit of this diagram. This is usually abbreviated to: The hom-functor preserves colimits.":"(반변 반함자(contravariant hom-functor))가 다이어그램 $D$에 작용한 극한은 이 다이어그램의 공극한에 작용한 반함자와 동형입니다. 이는 보통 다음과 같이 약칭됩니다: 반함자는 공극한을 보존합니다.","A functor that preserves colimits is called \\index{co-continuous functor}co-continuous. Thus the contravariant hom-functor is co-continuous.":"한글로 번역한 사한계를 보존하는 함자를 \\index{co-continuous functor}공연속 함자(co-continuous)라고 합니다. 따라서 반변 공사함자(contravariant hom-functor)는 공연속 함자입니다.","Now suppose that we have the adjunction $L \\dashv R$, where $L \\colon \\cat C \\to \\cat D$ and $R$ goes in the opposite direction. We want to show that the left functor $L$ preserves colimits, that is:":"이제 $L \\colon \\cat C \\to \\cat D$이고 $R$이 반대 방향으로 가는 adjunction $L \\dashv R$이 있다고 가정합니다. 좌측 함수자 $L$이 colimit를 보존함을 보이고자 합니다, 즉:","L (\\text{Colim} \\, D) \\cong \\text{Colim} (L \\circ D)":"L (\\text{직합} \\, D) \\cong \\text{직합} (L \\circ D)","for any diagram $D \\colon \\cat J \\to \\cat C$ for which the colimit exists.":"어떤 다이어그램 $D \\colon \\cat J \\to \\cat C$의 콜리밋이 존재한다고 가정합니다.","We'll use the Yoneda lemma to show that the mappings out from both sides to an arbitrary $x$ are isomorphic:":"\\textbf{요네다 보조정리}를 사용하여 임의의 $x$에 대한 양쪽에서 나오는 사상이 동형임을 보여줍니다:","\\cat D( L (\\text{Colim} \\, D), x) \\cong \\cat D (\\text{Colim} (L \\circ D), x)":"\\cat D(L(\\text{한계} \\, D), x) \\cong \\cat D(\\text{한계}(L \\circ D), x)","We apply the adjunction to the left hand side to get:":"왼쪽 면에 adjunction을 적용하여 얻습니다:","\\cat D( L (\\text{Colim} \\, D), x) \\cong \\cat C (\\text{Colim}\\, D, R x)":"\\cat D( L (\\text{쌍극한} \\, D), x) \\cong \\cat C (\\text{쌍극한}\\, D, R x)","Preservation of colimits by the hom-functor gives us:":"쌍대함자에 의한 쌍대극한의 보존은 다음과 같은 결과를 줍니다:","\\cong \\text{Lim}\\; \\cat C(D -, R x)":"\\cong \\text{극한}\\; \\cat C(D -, R x)","Using the adjunction again, we get:":"또한 adjunction(쌍대) 을 사용하여, 우리는 다음과 같은 결과를 얻습니다:","\\cong \\text{Lim}\\; \\cat D((L \\circ D) -, x)":"\\cong \\text{Lim}\\; \\cat D((L \\circ D) -, x)","And the second application of preservation of colimits gives us the desired result:":"그리고 콜리밋(colimits) 보존의 두 번째 응용은 우리에게 원하는 결과를 제공합니다:","\\cong  \\cat D((\\text{Colim}\\;(L \\circ D), x)":"\\cong  \\cat D((\\text{Colim}\\;(L \\circ D), x)","We can use this result to reformulate our earlier proof of distributivity in a cartesian closed category. We use the fact that the product is the left adjoint of the exponential. Left adjoints preserve colimits. A coproduct is a colimit, therefore:":"이 결과를 사용하여 데카르트 닫힌 범주에서의 분배법칙에 대한 이전 증명을 재구성할 수 있습니. 우리는 곱(product)가 지수(exponential)의 왼쪽 수반함수(left adjoint)임을 이용합니. 왼쪽 수반함수는 쌍극한(colimit)을 보존합니. 쌍대곱(coproduct)은 쌍극한이므로, 따라서:","Here, the left functor is $L x = x \\times a$, and the diagram $D$ selects a pair of objects $b$ and $c$.":"여기서 왼쪽 함자(functor)는 $L x = x \\times a$이며, 다이어그램(diagram) $D$는 객체(object) $b$와 $c$의 쌍을 선택합니다.","Using a dual argument, we can show that right adjoints preserve limits, that is:":"이중 논증을 사용하면, 오른쪽 수반 함자들(right adjoints)은 극한(limits)을 보존한다는 것을 보일 수 있습니다, 즉:","R (\\text{Lim}\\, D) \\cong \\text{Lim}\\, (R \\circ D)":"R (\\text{Lim}\\, D) \\cong \\text{Lim}\\, (R \\circ D)","We start by showing that the (covariant) hom-functor preserves limits.":"우리는 (공변) hom-함수가 극한을 보존함을 보여주는 것으로 시작합니다.","\\text{Lim}\\; \\cat C( x, D-) \\cong \\mathcal{C}(x, \\text{Lim}\\,D)":"\\text{Lim}\\; \\cat C( x, D-) \\cong \\mathcal{C}(x, \\text{Lim}\\,D)","This follows from the argument that a set of cones that defines the limit is isomorphic to the limit of the $\\Set$-valued functor:":"이는 한계(limits)를 정의하는 원뿔의 집합이 $\\Set$-값 함수자(functor)의 한계와 동형(isomorphic)임을 나타내는 주장에서 따릅니다:","F j = \\cat C(x, D j)":"F j = \\cat C(x, D j)","A functor that preserves limits is called \\index{continuous functor}continuous.":"한계를 보존하는 함자를 \\index{continuous functor} 계속적 함자라고 합니다.","To show that, given the adjunction $L \\dashv R$, the right functor $R \\colon \\cat D \\to \\cat C$ preserves limits, we use the Yoneda argument:":"$L \\dashv R$의 부여(adjunction)가 주어졌을 때, 오른쪽 함자 $R \\colon \\cat D \\to \\cat C$가 극한(limits)을 보존함을 보이기 위해, 우리는 요네다(Yoneda) 주장을 사용합니다:","\\cat C(x, R (\\text{Lim}\\, D)) \\cong \\cat C (x, \\text{Lim}\\, (R \\circ D))":"\\cat C(x, R (\\text{Lim}\\, D)) \\cong \\cat C (x, \\text{Lim}\\, (R \\circ D))","Indeed, we have:":"확실히, 우리는 다음과 같습니다:","\\cat C(x, R (\\text{Lim}\\, D)) \\cong \\cat D(L x, \\text{Lim}\\, D) \\cong \\text{Lim}\\; \\cat D(L x, D-) \\cong \\cat C(x, \\text{Lim}\\, (R \\circ D))":"\\cat C(x, R (\\text{Lim}\\, D)) \\cong \\cat D(L x, \\text{Lim}\\, D) \\cong \\text{Lim}\\; \\cat D(L x, D-) \\cong \\cat C(x, \\text{Lim}\\, (R \\circ D))","\\section{Freyd's adjoint functor theorem}":"\\section{Freyd의 수반 함자 정리}","In general functors are lossy---the are not invertible. In some cases we can make up for the lost information by replacing it with the ``best guess.'' If we do it in an organized manner, we end up with an adjunction. The question is: given a functor between two categories, what are the conditions under which we can construct its adjoint.":"일반적으로 함자들(함수자들)은 정보를 잃기 쉽습니다---즉, 역함자(역함수자)가 존재하지 않습니다. 일부 경우에는 잃어버린 정보를 ``최적의 추정치(best guess)''로 대체함으로써 보완할 수 있습니다. 이를 체계적으로 수행하면, 수반(adjunction) 관계가 됩니다. 문제는: 두 카테고리(범주) 사이의 함자(함수자)가 주어졌을 때, 수반 함자(함수자)를 구성할 수 있는 조건은 무엇인가입니다.","The answer to this question is given by the Freyd's adjoint functor theorem. At first it might seem like this is a technical theorem involving a very abstract construction called the solution set condition. We'll see later that this condition translates directly to a programming technique called defunctionalization.":"이 질문에 대한 대답은 Freyd의 수반 함수 정리(adjoint functor theorem)에 의해 주어집니다. 처음에는 이것이 해 집합 조건(solution set condition)이라는 매우 추상적인 구성과 관련된 기술적 정리처럼 보일 수 있습니다. 나중에 이 조건이 함수 제거(defunctionalization)라는 프로그래밍 기법으로 직접 변환됨을 볼 것입니다.","In what follows, we'll focus our attention on constructing the right adjoint to a functor $L \\colon \\cat D \\to \\cat C$. A dual reasoning can be used to solve the converse problem of finding the left adjoint to a functor $R \\colon \\cat C \\to \\cat D$.":"이어서, 함수자 $L \\colon \\cat D \\to \\cat C$의 오른쪽 수반 함수를 구성하는 데 주의를 기울일 것입니다. 반대 문제를 해결하기 위해서는 함수자 $R \\colon \\cat C \\to \\cat D$의 왼쪽 수반 함수를 찾는 이중 논리를 사용할 수 있습니.","The first observation is that, since the left functor in an adjunction preserves colimits, we have to postulate that our functor $L$  preserves colimits. This gives us a hint that the construction of the right adjoint relies on the ability to construct colimits in $\\cat D$, and being able to somehow transport them back to $\\cat C$ using $L$.":"첫 번째 관찰은, 부여된 편함수(adjunction)에서 왼쪽 함자(함수자)가 쌍극한(colimit)을 보존하기 때문에, 우리의 함자 $L$이 쌍극한을 보존해야 한다는 점입니다. 이는 오른쪽 수반 함자를 구성하는 것이 $\\cat D$에서 쌍극한을 구성할 수 있는 능력에 의존하며, 이들을 $L$을 사용하여 어떻게든 $\\cat C$로 다시 옮길 수 있는 능력에도 의존한다는 힌트를 제공합니다.","We could demand that all colimits, large and small, exist in $\\cat D$ but this condition is too strong. Even a small category that has all colimits is automatically a preorder---that is, it can't have more than one morphism between any two objects.":"모든 쌍대극한(colimits), 큰 것과 작은 것이 $\\cat{D}$에 존재한다고 요구할 수 있지만, 이 조건은 너무 강합니다. 모든 쌍대극한을 가지는 작은 카테고리는 자동적으로 전순서(preorder)여야 합니다---즉, 두 객체 사이에 하나 이상의 사상이 존재할 수 없습니다.","But let's ignore size problems for a moment, and see how one would construct the right adjoint to a colimit-preserving functor $L$, whose source category $\\cat D$ is small and has all colimits, large and small (thus it is a preorder).":"하지만 잠시 크기 문제를 무시하고, 소스 범주 \\(\\cat D\\)가 작고 모든 쌍극한(colimit)을 가지는(따라서 전순서(preorder)입니다) 쌍극한 보존 함자 \\(L\\)의 오른쪽 수반 함자가 어떻게 구성되는지 살펴봅시다.","\\subsection{Freyd's theorem in a preorder}":"\\subsection{Freyd의 정리(Freyd's theorem) in a preorder}","The easiest way to define the right adjoint to $L$ is to construct, for every object $c$, a universal arrow from $L$ to $c$. Such an arrow is the terminal object in the comma category $L/c$---the category of arrows which originate in the image of $L$ and converge on the object $c$.":"$L$의 우측 수반(functor)(right adjoint)을 정의하는 가장 쉬운 방법은, 모든 객체 $c$에 대해 $L$에서 $c$로 가는 보편적인 화살표(universal arrow)를 구성하는 것입니다. 이러한 화살표는 콤마 카테고리(comma category) $L/c$—즉 $L$의 이미지에서 시작하여 객체 $c$에 도달하는 화살표들의 카테고리—에서의 종단 객체(terminal object)입니다.","The important observation is that this comma category describes a cocone in $\\cat C$. The base of this cocone is formed by those objects in the image of $L$ that have an unobstructed view of $c$. The arrows in the base of the cocone are the morphisms in $L/c$. These are exactly the arrows that make the sides of the cocone commute.":"중요한 관찰은 이 쉼표 범주가 $\\cat C$에서의 쌍대원뿔(cocone)을 설명한다는 것입니다. 이 쌍대원뿔의 바탕(base)은 $c$를 방해 없이 볼 수 있는 $L$의 이미지에 있는 대상들로 형성됩니다. 쌍대원뿔의 바탕에 있는 화살표들은 $L/c$의 사상(morphisms)들입니다. 이들은 쌍대원뿔의 측면을 가환하게 만드는 화살표들입니다.","The base of this cocone can be projected back to $\\cat D$. There is a projection $\\pi_c$ which maps every pair $(d, f)$ in  $L/c$ back to $d$, thus forgetting the arrow $f$. It also maps every morphism in $L/c$ to an arrow in $\\cat D$ that gave rise to it. This way $\\pi_c$ defines a diagram in $\\cat D$. The colimit of this diagram exists, because we have assumed that all colimits exist in $\\cat D$. Let's call this colimit $t_c$:":"이 꼬콘의 기초(base)는 $\\cat D$로 다시 투영될 수 있습니 다. 모든 쌍 $(d, f)$을 $L/c$에서 $d$로 되돌리는 투영 $\\pi_c$가 있습니 다. 이 투영은 화살표 $f$를 무시합니 다. 또한 $L/c$의 모든 사상(morphism)을 $\\cat D$에서 비롯된 화살표로 사상합니 다. 이러한 방법으로 $\\pi_c$는 $\\cat D$에서 다이어그램(diagram)을 정의합니 다. 이 다이어그램의 콜리밋(colimit)이 존재하는데, 이는 우리가 $\\cat D$에서 모든 콜리밋이 존재한다고 가정했기 때문입니 다. 이 콜리밋을 $t_c$라고 부르겠습니 다.","t_c = \\text{colim}\\; \\pi_c":"t_c = \\text{colim}\\; \\pi_c","Let's see if we can use this $t_c$ to construct a terminal object in $L/c$. We have to find an arrow, let's call it $\\varepsilon_c \\colon L t_c \\to c$, such that the pair $\\langle t_c, \\varepsilon_c \\rangle$ is terminal in $L/c$.":"현재 이 $t_c$를 이용하여 $L/c$에서 끝 대상(terminal object)을 구성할 수 있는지 살펴봅시다. 화살표 하나를 찾아야 합니다. 이를 $\\varepsilon_c \\colon L t_c \\to c$라고 부릅시다. 이 쌍 $\\langle t_c, \\varepsilon_c \\rangle$가 $L/c$에서 끝 대상이 되도록 해야 합니다.","Notice that $L$ maps the diagram generated by $\\pi_c$ back to the base of the cocone defined by $L/c$. The projection $\\pi_c$ did nothing more than to ignore the sides of this cocone, leaving its base intact.":"$L$이 $\\pi_c$에 의해 생성된 다이어그램을 $L/c$에 의해 정의된 코콘의 base(기저)로 다시 매핑함을 주목하세요. 투영 $\\pi_c$는 이 코콘의 면을 무시하고 기저를 그대로 두는 것 외에는 아무것도 하지 않았습니다.","We now have two cocones in $\\cat C$ with the same base: the original one with the apex $c$ and the new one obtained by applying $L$ to the cocone in $\\cat D$. Since $L$ preserves colimits, the colimit of the new cocone is $L t_c$---the image of the colimit $t_c$:":"이제 우리는 동일한 기저(base)를 가진 두 개의 코콘(cocone)을 범주 $\\cat C$에서 가지고 있습니니다: 정점(apex) $c$를 가진 원래의 코콘과 범주 $\\cat D$의 코콘에 $L$을 적용하여 얻은 새로운 코콘입니다. $L$이 쳅극(limits)을 보존(bepreserve)하므로, 새로운 코콘의 쳅극은 $L t_c$---쳅극 $t_c$의 이미지(image)입니다:","\\text{colim} \\; (L \\circ \\pi_c) = L ( \\text{colim} \\; \\pi_c) = L t_c":"\\text{colim} \\; (L \\circ \\pi_c) = L ( \\text{colim} \\; \\pi_c) = L t_c","By universal construction, we deduce that there must be a unique cocone morphism from the colimit $L t_c$ to $c$. That morphism, which we'll call $\\varepsilon_c$, makes the relevant triangles commute.":"범용적 구성(universal construction)에 의해, 우리는 유일한 코원뿔 사상(cocone morphism)이 귀한 $L t_c$에서 $c$로 존재해야 한다는 것을 추론합니다. 그 사상을 $\\varepsilon_c$라 부르기로 하며, 이 사상은 관련된 삼각형들을 교환(commute)하게 만듭니다.","What remains to be shown is that $\\langle t_c, \\varepsilon_c \\rangle$ is terminal in $L/c$, that is, for any  $\\langle d, f \\colon L d \\to c \\rangle$ there is a unique comma-category morphism $h \\colon d \\to t_c$ that makes the following triangle commute:":"보여야 할 남은 것은 $\\langle t_c, \\varepsilon_c \\rangle$가 $L/c$에서 \\emph{종단객체}(terminal object)임입니다. 즉, 임의의 $\\langle d, f \\colon L d \\to c \\rangle$에 대해, 다음 삼각형을 가환하도록 만드는 유일한 콤마-범주 사상(comma-category morphism) $h \\colon d \\to t_c$가 존재함을 보이는 것입니다:","Notice that any such $d$ is automatically part of the diagram produced by $\\pi_c$ (it's the result of $\\pi_c$ acting on $\\langle d, f \\rangle$). We know that $t_c$ is the limit of this diagram. So there must be a wire from $d$ to $t_c$ in the limiting cocone. We pick this wire as our $h$.":"이러한 $d$는 자동으로 $\\pi_c$에 의해 생성된 다이어그램의 일부가 됩니다 ($\\langle d, f \\rangle$에 $\\pi_c$가 작용한 결과입니다). 우리는 $t_c$가 이 다이어그램의 극한이라는 것을 알고 있습니다. 따라서 극한 공원뿔(limiting cocone)에서 $d$에서 $t_c$로 가는 와이어가 존재해야 합니다. 우리는 이 와이어를 우리의 $h$로 선택합니다.","The commuting condition then follows from $\\varepsilon_c$ being a cocone morphism. It is unique such morphism simply because $\\cat D$ is a preorder.":"순환 조건은 $\\varepsilon_c$가 공원 사상(cocone morphism)이기 때문에 따릅니다. $\\cat D$가 사전순서(preorder)이기 때문에 그러한 사상은 유일합니다.","This proves that there is a universal arrow $\\langle t_c, \\varepsilon_c \\rangle$ for every $c$, therefore we have a functor $R$ defined on objects as $R c = t_c$ that is the right adjoint to $L$.":"이는 모든 $c$에 대해 유일성 화살표(universal arrow) $\\langle t_c, \\varepsilon_c \\rangle$가 있음을 증명합니다. 따라서 우리는 객체에 대해 $R c = t_c$로 정의된 함자(functor) $R$을 가지며, 이는 $L$의 오른쪽 수반 함자(right adjoint)입니다.","The problem with the previous proof is that comma categories in most practical cases are large: their objects don't form a set. But maybe we can approximate the comma category by selecting a smaller but representative set of objects and arrows.":"이전 증명의 문제는 쉼표 범주(comma categories)가 대부분의 실제 상황에서 크다는 것~입니다: 그들의 객체들이 집합을 형성하지 않습니다. 그러나 아마도 우리는 더 작지만 대표적인 객체와 화살들의 집합을 선택함으로써 쉼표 범주를 근사할 수 있을~지도 모릅니다.","To select the objects we'd use a mapping from some indexing set $I$. We define a set of objects $d_i$ where $i \\in I$. Since we are trying to approximate the comma category $L/c$, we select objects together with arrows $f_i \\colon L d_i \\to c$.":"어떤 색인 집합 $I$에서 객체를 선택하기 위해 사상을 사용합니다. 객체들의 집합 $d_i$를 정의합니다, 여기서 $i \\in I$입니다. 우리가 comma category $L/c$를 근사하려고 하기 때문에, 객체들을 화살표 $f_i \\colon L d_i \\to c$와 함께 선택합니다.","The relevant part of the comma category was encoded in morphism between objects satisfying the commuting condition. We could try to specialize this condition to only apply inside our family of objects, but that would not be enough. We have to find a way to probe all other objects of the comma category.":"콤마 범주(comma category)의 관련 부분은 교환 조건(commuting condition)을 만족하는 객체(object)들 사이의 사상(morphism)으로 인코딩되었습니다. 이 조건을 우리의 객체 집합 내부에만 적용하도록 특수화하는 것을 시도할 수 있지만, 그 정도로는 충분하지 않 ~습니다. 우리는 콤마 범주의 모든 다른 객체들을 조사할 방법을 찾아야 합니다.","To do this, we reinterpret the commuting condition as a recipe for factorizing an arbitrary $f \\colon L d \\to c$ through some pair $\\langle d_i, f_i \\rangle$:":"이를 위해, 우리는 임의의 $f \\colon L d \\to c$를 쌍 $\\langle d_i, f_i \\rangle$을 통해 분해하는 방법으로 교환 조건을 재해석합니다:","A \\index{solution set}\\emph{solution set} is a family of pairs $\\langle d_i, f_i \\colon L d_i \\to c \\rangle $ indexed by a set $I$ that can be used to factor any pair $\\langle d, f \\colon L d \\to c \\rangle $. It means that there exists an index $i \\in I$ and an arrow $h \\colon d \\to d_i$ that factorizes $f$:":"A \\index{해결 집합}\\emph{해결 집합(solution set)}은 집합 $I$에 의해 인덱스된 쌍 $\\langle d_i, f_i \\colon L d_i \\to c \\rangle $의 모임으로, 이는 임의의 쌍 $\\langle d, f \\colon L d \\to c \\rangle $를 분해하는 데 사용될 수 있습니. 이는 인덱스 $i \\in I$와 $f$를 분해하는 화살표 $h \\colon d \\to d_i$가 존재함을 의미합니다:","f = f_i \\circ L h":"f = f_i \\circ L h","Another way of expressing this property is to say that there exists a \\index{weakly terminal set}\\emph{weakly terminal} set of object in the comma category $L/c$. A weakly terminal set has the property that for any object in the category there is a morphism to at least one object in the set.":"이 속성을 표현하는 또 다른 방법은 콤마 범주 $L/c$에서 \\index{약 단말 집합}\\emph{약 단말} 객체 집합이 존재한다고 말하는 것입니다. 약 단말 집합은 범주의 어떤 객체에 대해서도 그 집합에 속한 적어도 하나의 객체로 가는 사상이 존재하는 성질을 갖습니다.","Previously we've seen that having the terminal object in the comma category $L/c$ for every $c$ is enough to define the adjunction. It turns out that we can achieve the same goal using the solution set.":"이전에는 모든 $c$에 대해 comma 범주 $L/c$에서 종륙 객체(terminal object)를 갖는 것이 adjunction을 정의하기에 충분하다는 것을 보았습니다. 해결 집합(solution set)을 사용하여 동일한 목표를 달성할 수 있다는 것이 밝혀졌습니다.","The assumptions of the Freyd's adjoint functor theorem state that we have a colimit-preserving functor $L \\colon \\cat D \\to \\cat C$ from a small co-complete category. Both these conditions relate to \\emph{small} diagrams. If we can pick a solution set $\\langle d_i, f_i \\colon L d_i \\to c \\rangle $ for every $c$, then the right adjoint $R$ exists. Solution sets for different $c$'s may be different.":"Freyd의 수반 함자 정리의 가정은 작은 쌍대 완비 범주 $\\cat D$에서 $\\cat C$로의 귀한을 보존하는 함자(functor) $L \\colon \\cat D \\to \\cat C$가 있음을 명시합니다. 이 두 조건은 \\emph{작은} 도형(diagram)과 관련이 있습니다. 만약 모든 $c$에 대해 해결 집합(solution set) $\\langle d_i, f_i \\colon L d_i \\to c \\rangle $을 선택할 수 있다면, 오른쪽 수반 함자(right adjoint) $R$이 존재합니다. 다양한 $c$에 대한 해결 집합들은 서로 다를 수 있습니다.","We've seen before that in a cocomplete category the existence of a weakly terminal set is enough to define a terminal object. In our case it means that, for any $c$, we can construct the universal arrow from $L$ to $c$. And this is enough to define the whole adjunction.":"우리는 이미 쌍대완비 범주(cocomplete category)에서 약한 끝 대상(weakly terminal set)의 존재가 종말 대상(terminal object)을 정의하기에 충분하다는 것을 보았습니다. 우리의 경우, 임의의 $c$에 대해 $L$에서 $c$로 가는 보편 화살표(universal arrow)를 구성할 수 있다는 것을 의미합니다. 그리고 이것만으로 전체 부수 함자(adjunction)를 정의하기에 충분합니다.","A dual version of the adjoint functor theorem can be used to construct the left adjoint.":"부수 함자 정리(adjoint functor theorem)의 쌍대 버전은 왼쪽 부수 함자를 구성하는 데 사용할 수 있습니다.","Every programming language lets us define functions, but not all languages support higher level functions (functions taking functions as arguments, or returning functions) or anonymous functions (a.k.a., lambdas). It turns out that, even in such languages, higher order functions can be implemented using the process called defunctionalization. This technique is based on the adjoint functor theorem. Moreover, defunctionalization can be used whenever passing functions around is impractical, for instance in distributed systems.":"모든 프로그래밍 언어는 함수를 정의할 수 있게 해줍니다, 하지만 모든 언어가 고급 함수(함수를 인수로 받거나 함수를 반환하는 함수)나 익명 함수(일명 람다)를 지원하지는 않습니다. 심지어 그런 언어들에서도 고차 함수는 디펑셔널화(defunctionalization)라는 과정을 통해 구현될 수 있습니다. 이 기법은 부속 함자 정리(adjoint functor theorem)에 기초합니다. 더욱이, 디펑셔널화는 예를 들어 분산 시스템과 같이 함수를 전달하는 것이 실용적이지 않을 때 사용할 수 있습니다.","The idea behind defunctionalization is that the function type is defined as the right adjoint to the product.":"디펑셔널라이제이션(defunctionalization) 뒤에 있는 아이디어는 함수 타입이 곱(product)의 오른쪽 수반자(right adjoint)로 정의된다는 것입니다.","\\cat C(e \\times a, b) \\cong \\cat C(e, b^a)":"\\cat C(e \\times a, b) \\cong \\cat C(e, b^a)","The adjoint functor theorem can be used to approximate this adjoint.":"좌수 준수성 정리(Adjoint functor theorem)은 이 보조 함자(adjoint)를 근사하는 데 사용할 수 있습니다.","In general, any finite program can only have a finite number of function definitions. These functions (together with the environments they capture) form the solution set that we can use to construct the function type. In practice, we do it only for a small subset of functions which occur as arguments to, or are returned from, other functions.":"일반적으로, 유한한 프로그램은 오직 유한한 수의 함수 정의만 가질 수 있습니니다. 이러한 함수(그리고 그것들이 캡처하는 환경들)는 우리가 함수 타입을 구성할 때 사용할 수 있는 해 집합을 형성합니다. 실제로, 우리는 다른 함수에 대한 인자로 나타나거나, 다른 함수로부터 반환되는 작은 부분 집합의 함수들에 대해서만 그것을 수행합니다.","A typical example of the usage of higher order functions is in continuation passing style. For instance, here's a function that calculates the sum of the elements of a list. But instead of returning the sum it calls a continuation \\hask{k}:":"고차 함수의 사용 예로 전형적인 것은 연속 전달 방식(Continuation Passing Style)입니다. 예를 들어, 이는 리스트의 요소들의 합을 계산하는 함수입니다. 하지만 합을 반환하는 대신에 연속 \\hask{k}을 호출합니다:","If the list is empty, the function calls the continuation with zero. Otherwise it calls itself recursively, with two arguments: the tail of the list \\hask{is}, and a new continuation:":"목록이 비어 있으면 함수는 계속 함수(continuation)를 0과 함께 호출합니다. 그렇지 않으면 두 개의 인수를 사용하여 자신을 재귀적으로 호출합니다: 목록의 꼬리 \\hask{is}, 그리고 새로운 계속 함수(continuation):","This new continuation calls the previous continuation \\hask{k}, passing it the sum of the head of the list and its argument \\hask{s} (which is the accumulated sum).":"이 새로운 연속(continuation)은 이전 연속 \\hask{k}를 호출하면서 리스트의 첫 요소와 그 인자 \\hask{s} (즉, 누적 합)을 더한 값을 전달합니다.","Notice that this lambda is a closure: It's a function of one variable \\hask{s}, but it also has access to \\hask{k} and \\hask{i} from its environment.":"이 람다(lambda)를 클로저(closure)라고 하는 이유를 주목하십시오: 이는 하나의 변수 \\hask{s}의 함수지만, 그 환경에서 \\hask{k} 및 \\hask{i}에도 접근할 수 있습니다.","To extract the final sum, we call our recursive function with the trivial continuation, the identity:":"최종 합계를 추출하기 위해 우리는 자명한 연속(continuation), 항등 함수를 사용하여 재귀 함수(recursive function)를 호출합니다:","Anonymous functions are convenient, but nothing prevents us from using named functions. However, if we want to factor out the continuations, we have to be explicit about passing in the environments.":"익명 함수는 편리하나, 명명된 함수를 사용하는 것을 막는 것은 없습다. 그러나, 만약 후속 작업을 분리하고자 한다면, 환경을 전달하는 것에 대해 명확하게 해야 합니다.","For instance, we can replace our first lambda with the function \\hask{more}, but we have to explicitly pass it the environment of the type \\hask{(Int, Int -> r)}:":"예를 들어, 우리는 첫 번째 람다를 함수 \\hask{more}로 대체할 수 있지만, 타입 \\hask{(Int, Int -> r)}의 환경을 명시적으로 전달해야 합니다.","The other lambda, the identity, uses an empty environment:":"다른 람다(λ), 즉 항등함수(identity)는 빈 환경을 사용합니다:","Here's the implementation of our algorithm using named functions:":"다음은 명명된 함수들을 사용한 우리의 알고리즘 구현입니다:","In fact, if all we are interested in is calculating the sum, we can replace the polymorphic type \\hask{r} with \\hask{Int} with no other changes.":"사실 우리가 관심 있는 것이 합계를 계산하는 것이라면, 다형성 타입 \\hask{r}를 \\hask{Int}로 바꾸고 다른 변경은 하지 않아도 됩니다.","This implementation still uses higher order functions. In order to eliminate them, we have to analyze what it means to pass a function as an argument. Such a function can only be used in one way: it can be applied to its arguments. This property of a function type is expressed as the counit of the currying adjunction:":"이 구현은 여전히 고차 함수를 사용합니다. 이를 없애기 위해, 함수를 인수로 전달하는 것이 무엇을 의미하는지 분석해야 합니다. 그런 함수는 오직 한 가지 방식으로만 사용할 수 있습니다: 인수에 적용될 수 있습니다. 함수 타입의 이러한 특성은 커링(kKurrying) 조합의 counit으로 표현됩니다:","or, in Haskell, as a higher-order function:":"또는, Haskell에서처럼, 고차 함수(higher-order function)로:","This time we are interested in constructing the counit from first principles. We've seen that this can be accomplished using the comma category. In our case, an object of the comma category for the product functor $L_a = (-) \\times a$ is a pair":"이번에는 초항(훔초항, counit)을 기본 원리부터 구성하는 데 관심이 있습니다. 우리는 쉼표 범주(comma category)를 사용하여 이를 달성할 수 있다는 것을 보았습니다. 우리의 경우, 곱 함자 $L_a = (-) \\times a$의 쉼표 범주의 객체는 쌍입니다.","(e, f \\colon (e \\times a) \\to b)":"(e, f \\colon (e \\times a) \\to b)","or, in Haskell:":"혹은, Haskell에서:","A morphism in this category between $(e, f)$ and $(e', f')$ is an arrow $h \\colon e \\to e'$, which satisfies the commuting condition:":"이 범주에서 $(e, f)$와 $(e', f')$ 사이의 사상(morphism)은 $e \\to e'$로 가는 화살표(arrow) $h$이며, 다음의 교환 조건을 만족합니다:","f' \\circ h = f":"f' \\circ h = f","We interpret this morphism as ``reducing'' the environment. The arrow $f'$ is able to produce the same output of the type $b$ using a potentially smaller environment given by $h (e)$. For instance $e$ may contain variables that are irrelevant for computing $b$ from $a$, and $h$ projects them out.":"우리는 이 사상을 환경을 ``축소하는'' 것으로 해석합니다. 화살표 $f'$는 $h(e)$로 주어진 잠재적으로 더 작은 환경을 사용하여 동일한 유형 $b$의 출력을 생성할 수 있습니다. 예를 들어 $e$는 $a$로부터 $b$를 계산하는 데 관련 없는 변수를 포함할 수 있으며, $h$는 해당 변수들을 제외합니다.","In fact, we performed this kind of reduction when defining \\hask{more} and \\hask{done}. In principle, we could have passed \\hask{is} to both functions, since it's accessible at the point of call. But we know that they don't need it.":"사실, 우리는 \\hask{more}와 \\hask{done}을 정의할 때 이러한 종류의 축소를 수행했습니. 원칙적으로, 우리는 \\hask{is}를 두 함수에 모두 전달할 수 있었습니, 왜냐하면 호출 시점에서 접근할 수 있기 때문입니다. 하지만 그들이 그것을 필요로 하지 않는다는 것을 알고 있습니다.","Formally, we could define the function object $a \\to b$ as the colimit of the diagram defined by the comma category. Such a colimit is essentially a giant coproduct of all environments modulo identifications given by comma-category morphisms. These identification do the job of reducing the environment needed by $a \\to b$ to the bare minimum.":"형식적으로, 우리는 함수 객체 $a \\to b$를 코마 범주에 의해 정의된 도표의 콜리밋(colimit)으로 정의할 수 있습니니다. 이러한 콜리밋은 본질적으로 코마 범주 사상(comma-category morphisms)에 의해 주어진 동일시로 표현된 모든 환경의 거대한 쌍대곱(coproduct)입니다. 이러한 동일시는 $a \\to b$가 필요한 환경을 최소한으로 줄이는 역할을 합니다.","In our example, the continuations we're interested in are functions \\hask{Int -> Int}. In fact we are not interested in generating the generic function type \\hask{Int -> Int}; just the minimal one that would accommodate our two functions \\hask{more} and \\hask{done}. We can do it by creating a very small solution set.":"우리의 예제에서, 우리가 관심 있는 연속 함수들은 함수 \\hask{Int -> Int}입니다. 사실 우리는 일반적인 함수 유형 \\hask{Int -> Int}을 생성하는 데 관심이 있는 것이 아니라 \\hask{more}와 \\hask{done}이라는 두 함수를 수용할 수 있는 최소한의 함수 유형에만 관심이 있습니다. 이를 통해 매우 작은 해집합을 생성하여 해결할 수 있습니다.","In our case the solution set consists of pairs $(e_i, f_i \\colon L_a e_i \\to b)$ such that any pair $(e, f \\colon L_a e \\to b)$ can be factorized through one of the $f_i$'s. More precisely, the only two environments we're interested in are \\hask{(Int, Int ->Int)} for \\hask{more}, and the empty environment \\hask{()} for \\hask{done}.":"우리의 경우 해집합은 $(e_i, f_i \\colon L_a e_i \\to b)$의 쌍으로 구성되어 있으며, 어떤 쌍 $(e, f \\colon L_a e \\to b)$도 $f_i$ 중 하나를 통해 인수분해될 수 있는 한입니다. 더 정확히 말하자면, 우리가 관심 있는 두 환경은 \\hask{(Int, Int ->Int)}로 \\hask{more}에 해당하고, 빈 환경 \\hask{()}로 \\hask{done}에 해당합니다.","In principle, our solution set should allow for the factorization of every object of the comma category, that is a pair of the type:":"원칙적으로, 우리의 해 집합은 콤마 카테고리의 모든 객체들을 다음과 같은 형태의 쌍으로 분해할 수 있어야 합니다:","but here we are only interested in two specific functions. Also, we are not concerned about the uniqueness of the representation so, instead of using a colimit (as we did for the adjoint functor theorem), we'll just use a coproduct of all the environments of interest. We end up with the following data type that is the sum of the two environments we're interested in:":"하지만 여기서는 두 가지 특정한 함수들에만 관심이 있습니. 또한 표현의 유일성에 대해서는 신경 쓰지 않기 때문에, (어울림 함자 정리에서 했던 것처럼) 공극(limit)를 사용하지 않고, 관심 있는 모든 환경의 쌍대곱(coproduct)을 사용할 것입니다. 그 결과 우리는 우리가 관심 있는 두 환경의 합집합인 다음과 같은 데이터 타입을 얻게 됩니다:","Notice that we have recursively encoded the \\hask{Int -> Int} part of the environment (the one we used for \\hask{more}) as \\hask{Kont}.":"우리가 \\hask{Int -> Int} 환경의 일부(우리가 \\hask{more}에 사용했던 부분)를 \\hask{Kont}로 재귀적으로 인코딩한 것을 주목하십시오.","If you look at this definition carefully, you will discover that it's the definition of a list of \\hask{Int}, modulo some renamings. Every call to \\hask{More} pushes another integer on the \\hask{Kont} stack. This interpretation agrees with our intuition that recursive algorithms require some kind of a runtime stack.":"이 정의를 자세히 살펴보면, 몇 가지 이름만 바뀐 \\hask{Int} 목록의 정의라는 것을 알 수 있을 것입니다. \\hask{More}에 대한 모든 호출은 \\hask{Kont} 스택에 또 다른 정수를 푸시(push)합니다. 이 해석은 재귀 알고리즘이 어떤 형태로든 런타임 스택을 필요로 한다는 우리의 직관과 일치합니다.","We are now ready to implement our approximation to the counit of the adjunction. It's composed from the bodies of the two functions, with the understanding that recursive calls also go through \\hask{apply}:":"이제 adjunction의 counit에 대한 우리의 근삿값을 구현할 준비가 되었습니다. 이는 두 함수의 본체로 구성되며, 재귀 호출도 \\hask{apply}를 거친다는 이해를 바탕으로 합니다.","The main algorithm can now be rewritten without any higher order functions or lambdas:":"주요 알고리즘을 이제 고차 함수나 람다 없이 다시 작성할 수 있습니:","The main advantage of defunctionalization is that it can be used in distributed environments. Arguments to remote functions, as long as they are data structures and not functions, can be serialized and send along the wire. All that's needed is for the receiver have access to \\hask{apply}.":"융역활(literal translation)화(defunctionalization)의 주요 장점은 분산 환경에서도 사용할 수 있다는 점입니다. 원격 함수의 인자가 데이터 구조이고 함수가 아닌 경우, 이를 직렬화(serialize)하여 전송할 수 있습니다. 수신자가 \\hask{apply}에 접근할 수 있으면 됩니다.","\\section{Free/Forgetful Adjunctions}":"\\section{자유/망각 수반(Functor) 관계}","The two functors in the adjunction play different roles: the picture of the adjunction is not symmetric. Nowhere is this illustrated better than in the case of the free/forgetful adjunctions.":"Adjunction에서 두 functor는 서로 다른 역할을 합니다: adjunction의 그림은 대칭적이지 않습니다. 이는 자유/망각 adjunctions의 경우에서 가장 잘 설명됩니다.","A forgetful functor is a functor that ``forgets'' some of the structure of its source category. This is not a rigorous definition but, in most cases, it's pretty obvious what structure is being forgotten. Very often the target category is just the category of sets, which is considered the epitome of structurelessness. The result of the forgetful functor in that case is called the ``underlying'' set, and the functor itself is often called $U$.":"망각 함자(미국어: forgetful functor)는 원천 범주에서 일부 구조를 \"망각\"하는 함자(영문 용어: functor)입니다. 이는 엄격한 정의는 아니지만, 대부분의 경우 무엇이 망각되는 구조인지 명확합니다. 매우 자주 목적 범주는 구조가 없다고 간주되는 집합의 범주(영문 용어: category of sets)가 됩니다. 그 경우 망각 함자의 결과는 \"기본\" 집합(영문 용어: underlying set)이라고 불리며, 함자 자체는 종종 $U$라고 불립니다.","More precisely, we say that a functor forgets \\emph{structure} if the mapping of hom-sets is not surjective, that is, there are arrows in the target hom-set that have no corresponding arrows in the source hom-set. Intuitively, it means that the arrows in the source have some structure to preserve, so there are fewer of them; and that structure is absent in the target.":"보다 정확하게, 우리는 한 함자가 \\emph{구조}(structure)를 잊어버린다고 말합니다. 만약 hom-집합의 사상이 전사(mapping of hom-sets is not surjective)하지 않다면, 다시 말해, 대상 hom-집합에는 근원 hom-집합에 해당하는 사상들이 없는 사상들이 존재한다면 그렇습니다. 직관적으로, 이것은 근원에 있는 사상들이 유지해야 하는 어떤 구조(structure)를 가지고 있기 때문에 그 수가 적다는 것을 의미하며, 그 구조가 대상에는 없다는 것을 의미합니다.","The left adjoint to a forgetful functor is called a \\emph{free functor}.":"잊어버리는 함자(Forgetful functor)에 대한 왼쪽 수반 함자(adjoint functor)를 \\emph{자유 함자}(free functor)라고 부릅니다.","A classic example of a free/forgetful adjunction is the construction of the free monoid.":"자유/망각 adjunction(부착)의 고전적인 예는 자유 모노이드(free monoid)의 구성입니다.","Monoids in a monoidal category $\\mathcal{C}$ form their own category $\\mathbf{Mon}(\\mathcal{C})$. Its objects are monoids, and its arrows are the arrows in $\\mathcal{C}$ that preserve the monoidal structure.":"모노이드(monoid) 단일 범주 $\\mathcal{C}$에서 모노이드들은 그들 자체의 범주 $\\mathbf{Mon}(\\mathcal{C})$를 형성합니다. 그 객체들은 모노이드들이고, 그 화살표들은 모노이드 구조를 보존하는 $\\mathcal{C}$ 내의 화살표들입니다.","The following diagram explains what it means for $f$ to be a monoid morphism, going from a monoid $(M_1, \\eta_1, \\mu_1)$ to a monoid $(M_2, \\eta_2, \\mu_2)$:":"다음 다이어그램은 $f$가 모노이드 사상(monoid morphism)이라는 것이 무엇을 의미하는지 설명하며, 모노이드 $(M_1, \\eta_1, \\mu_1)$에서 모노이드 $(M_2, \\eta_2, \\mu_2)$로 가는 과정을 보여 줍니다:","A monoid morphism $f$ must map unit to unit, which means that:":"모노이드 사상 $f$는 단위원을 단위원으로 사상해야 하며, 이는 다음을 의미합니다:","f \\circ \\eta_1 = \\eta_2":"f \\circ \\eta_1 = \\eta_2","and it must map multiplication to multiplication:":"곱셈을 곱셈에 매핑해야 합니다.","f \\circ \\mu_1 = \\mu_2 \\circ (f \\otimes f)":"f \\circ \\mu_1 = \\mu_2 \\circ (f \\otimes f)","Remember, the tensor product $\\otimes$ is functorial, so it can lift pairs of arrows, as in $f \\otimes f$.":"기억하세요, 텐서곱 $\\otimes$는 함자적(funtorial)입니다, 따라서 $f \\otimes f$와 같이 화살표 쌍(pair of arrows)을 들어올릴 수 있습니다.","In particular, the category $\\mathbf{Set}$ is monoidal, with cartesian product and the terminal object providing the monoidal structure.":"특히, 범주 $\\mathbf{Set}$는 모노이드(Category)이며, 이는 곱집합(cartesian product)과 종단 객체(terminal object)가 모노이드 구조를 제공합니다.","Monoids in $\\mathbf{Set}$ are sets with additional structure. They form their own category $\\mathbf{Mon}(\\mathbf{Set})$ and there is a forgetful functor $U$ that simply maps the monoid to the set of its elements. When we say that a monoid is a set, we mean the underlying set.":"모노이드는 $\\mathbf{Set}$에서 추가 구조를 가진 집합입니다. 이들은 자신들만의 범주 $\\mathbf{Mon}(\\mathbf{Set})$를 형성하며, 모노이드를 그 요소들의 집합으로 단순히 매핑하는 망각 함자 $U$가 있습니다. 우리가 모노이드를 집합이라고 할 때, 우리는 기본 집합을 의미합니다.","We want to construct the free functor":"우리는 자유 함자(free functor)를 구성하고 싶습니다.","F \\colon \\mathbf{Set} \\to \\mathbf{Mon}(\\mathbf{Set})":"F \\colon \\mathbf{Set} \\to \\mathbf{Mon}(\\mathbf{Set})","that is adjoint to the forgetful functor $U$.":"$U$ 망각 함자(forgotful functor)에 수반되는 ~니다.","We start with an arbitrary set $X$ and an arbitrary monoid $m$. On the right-hand side of the adjunction we have the set of functions between two sets, $X$ and $U m$. On the left-hand side, we have a set of highly constrained structure-preserving monoid morphisms from $F X$ to $m$. How can these two sets be isomorphic?":"임의의 집합 $X$와 임의의 모노이드 $m$로 시작합니다. 오른쪽의 adjunction(펑터의 쌍대 관계)에서는 두 집합, $X$와 $U m$ 사이의 함수들의 집합을 가집니다. 왼쪽에서는 $F X$에서 $m$으로의 구조 보존 모노이드 사상들의 집합을 가집니다. 이 두 집합이 어떻게 동형일 수 있을까요?","In  $\\mathbf{Mon}(\\mathbf{Set})$, monoids are just sets of elements, and a monoid morphism is a function between such sets, satisfying additional constraints: preserving unit and multiplication.":"$\\mathbf{Set}$에서 모노이드(monods)는 단지 요소들의 집합일 뿐이며, 모노이드 사상(morphism)은 이러한 집합들 사이의 함수로, 단위와 곱셈을 유지하는 추가적인 제약을 만족합니다.","Arrows in $\\mathbf{Set}$, on the other hand, are just functions with no additional constraints. So, in general, there are fewer arrows between monoids than there are between their underlying sets.":"$\\mathbf{Set}$에서의 화살표들은 단순히 아무런 추가적인 제약이 없는 함수들입니다. 따라서 일반적으로 모노이드들 사이의 화살표들은 그 기저 집합들 사이의 화살표들보다 더 적습니다.","Here's the idea: if we want to have a one to one matching between arrows, we want $F X$ to be much larger than $X$. This way, there will be many more functions from it to $m$---so many that, even after rejecting the ones that don't preserve the structure, we'll still have enough to match every function $f \\colon X \\to U m$.":"이 아이디어는 다음과 같습니다: 만약 화살표들 사이에 일대일 대응(one to one matching)을 원한다면, $F X$가 $X$보다 훨씬 더 커야 합니다. 이렇게 하면 $F X$에서 $m$으로 가는 함수들이 매우 많아질 것입니다---그래서 구조를 보존하지 않는 함수들을 제외하더라도, 여전히 $f \\colon X \\to U m$인 모든 함수와 대응될 수 있는 충분한 함수들이 남게 됩니다.","We'll construct the monoid $F X$ starting from the set $X$, and adding more and more elements as we go. We'll call the initial set $X$ the \\index{generators of a monoid}\\emph{generators} of $F X$. We'll construct a monoid morphism $g \\colon F X \\to m$ starting from the original function $f$ and extending it to more and more elements.":"집합 $X$에서 시작하여 점점 더 많은 요소들을 추가하면서 모노이드(monid) $F X$를 구성할 것입니다. 초기 집합 $X$를 $F X$의 \\index{모노이드의 생성자}\\emph{생성자}라고 부를 것입니다. 원래 함수 $f$에서 시작하여 점점 더 많은 요소들로 확장하여 모노이드 준동형사상(morphism) $g \\colon F X \\to m$을 구성할 것입니다.","On generators, $x \\in X$, $g$ works the same as $f$:":"생성자에 대해, $x \\in X$, $g$는 $f$와 동일하게 작동합니다:","g x = f x":"g x = f x","Since $F X$ is supposed to be a monoid, it has to have a unit. We can't pick one of the generators to be the unit, because it would impose constraints on the part of $g$ that is already fixed by $f$---it would have to map it to the unit $e'$ of $m$. So we'll just add an extra element $e$ to $F X$ and call it the unit. We'll define the action of $g$ on it by saying that it is mapped to the unit $e'$ of $m$:":"$F X$가 모노이드(monoid)라면 단위원(unit)이 있어야 합니다. 기존의 생성자들 중 하나를 단위원으로 선택할 수는 없습니다. 왜냐하면 이는 이미 $f$에 의해 고정된 $g$의 부분에 제약을 부여하게 되기 때문입니다---$g$는 이를 $m$의 단위원 $e'$로 매핑해야 합니다. 따라서 우리는 $F X$에 추가 요소 $e$를 추가하고 이를 단위원으로 지정할 것입니다. $g$의 작용을 정의할 때, 이를 $m$의 단위원 $e'$로 매핑한다고 말할 것입니다:","g e = e'":"g e = e'","We also have to define monoidal multiplication in $F X$. Let's start with a product of two generators $a$ and $b$. The result of the multiplication cannot be another generator because, again, that would constrain the part of $g$ that's fixed by $f$---products must be mapped to products. So we have to make all products of generators new elements of $F X$. Again, the action of $g$ on those products is fixed:":"우리는 $F X$에서 모노이달(monoidal) 곱셈을 정의해야 합니다. 두 생성자 $a$와 $b$의 곱으로 시작해 봅시다. 곱셈의 결과는 다른 생성자가 될 수 없습니다. 왜냐하면, 그렇게 되면 $f$에 의해 고정된 $g$의 부분이 제약되기 때문입니다---곱셈은 곱셈으로 매핑되어야 합니다. 그래서 생성자의 모든 곱을 $F X$의 새로운 요소로 만들어야 합니다. 다시 말해, 이러한 곱에 대한 $g$의 작용은 고정됩니다:","g (a \\cdot b)  = g a \\cdot g b":"g (a \\cdot b)  = g a \\cdot g b","Continuing with this construction, any new multiplication produces a new element of $F X$, except when it can be reduced to an existing element by applying monoid laws. For instance, the new unit $e$ times a generator $a$ must be equal to $a$. But we have made sure that $e$ is mapped to the unit of $m$, so the product $g e \\cdot g a$ is automatically equal to $g a$.":"이 구성을 계속해서, 모든 새로운 곱셈은 $F X$의 새로운 요소를 생성합니다. 단, 모노이드 법칙(monoid laws)을 적용해서 기존 요소로 축소될 수 있는 경우는 제외입니다. 예를 들어, 새로운 단위 $e$와 생성자(generator) $a$의 곱은 반드시 $a$와 같아야 합니다. 하지만 우리가 $e$를 $m$의 단위로 매핑했기 때문에, 곱 $g e \\cdot g a$는 자동으로 $g a$와 같습니다.","Another way of looking at this construction is to think of the set $X$ as an alphabet. The elements of $F X$ are then strings of characters from this alphabet. The generators are single-letter strings, $``a\"$, $``b\"$, and so on. The unit is an empty string , $``\"$. Multiplication is string concatenation, so  $``a\"$ times $``b\"$ is a new string  $``ab\"$. Concatenation is automatically associative and unital, with the empty string as the unit.":"이 구성을 바라보는 또 다른 방법은 집합 \\( X \\)를 알파벳으로 생각하는 것입니다. 그러면 \\( F X \\)의 요소들은 이 알파벳에서 나온 문자들의 문자열이 됩니다. 생성자는 한 글자의 문자열입니다, ``a\", ``b\" 등입니다. 단위(element)는 빈 문자열, ``\" 입니다. 곱셈은 문자열 연결(concatenation)입니다, 그래서 ``a\" 곱하기 ``b\"는 새로운 문자열 ``ab\"입니다. 연결은 자동적으로 결합적(associative)이고 단위적(unital)이며, 빈 문자열이 단위입니다.","The intuition behind free functors is that they generate structure ``freely,'' as in ``with no additional constraints.'' They also do it lazily: instead of performing operations, they just record them. They create generic domain-specific programs that can be executed later by specific interpreters.":"자유 함자의 직관은 \"추가적인 제약이 없이\" 구조를 \"자유롭게\" 생성한다는 것입니다. 또한 게으르게 동작합니다: 연산을 수행하는 대신, 그것들을 기록합니다. 특정 해석기에 의해 나중에 실행될 수 있는 일반적인 도메인-특정 프로그램을 생성합니다.","The free monoid ``remembers to do the multiplication'' at a later time. It stores the arguments to multiplication in a string, but doesn't perform the multiplication. It's only allowed to simplify its records based on generic monoidal laws. For instance, it doesn't have to store the command to multiply by the unit. It can also ``skip the parentheses'' because of associativity.":"자유 모노이드(free monoid)는 곱셈을 나중에 수행하기 위해 기억합니다. 곱셈의 인수들을 문자열로 저장하지만, 실제로 곱셈을 수행하지 않습니다. 일반적인 모노이드(monodial) 법칙에 기반하여 기록을 단순화할 수만 있습니다. 예를 들어, 단위로 곱하는 명령어는 저장하지 않아도 됩니다. 또한 결합법칙에 따라 괄호를 생략할 수도 있습니다.","In Haskell, monoids are defined using the following typeclass:":"하스켈(Haskell)에서는 모노이드(monoid)가 다음의 타입 클래스(typeclass)를 사용하여 정의됩니다:","Here, \\hask{mappend} is the curried form of the mapping from the product: \\hask{(m, m) -> m}. The \\hask{mempty} element corresponds to the arrow from the terminal object (unit of the monoidal category), or simply and element of \\hask{m}.":"여기서 \\hask{mappend}는 곱셈의 커링형태인 \\hask{(m, m) -> m}의 매핑입니다. \\hask{mempty} 요소는 종말 객체(모노이달 범주의 단위)에서의 화살표에 해당하거나 단순히 \\hask{m}의 요소입니다.","A free monoid generated by some type \\hask{a}, which serves as a set of generators, is represented by a list type \\hask{[a]}. An empty list serves as the unit; and monoid multiplication is implemented as list concatenation, traditionally written in infix form:":"어떤 타입 \\hask{a}에 의해 생성된 자유 모노이드(free monoid)는 리스트 타입 \\hask{[a]}로 표현됩니다. 빈 리스트는 항등원 역할을 하며, 모노이드 곱셈은 리스트 연결로 구현되며, 전통적으로 중위 표기법으로 씁니다.","A list is an instance of a \\hask{Monoid}:":"목록은 \\hask{Monoid}의 인스턴스입니 다:","To show that it's a free monoid, we have to be able to construct a monoid morphism from the list of \\hask{a} to an arbitrary monoid \\hask{m}, provided we have an (unconstrained) mapping from \\hask{a} to (the underlying set of) \\hask{m}. We can't express all of this in Haskell, but we can define the function:":"모노이드(자유 모노이드)임을 보이기 위해서는 \\hask{a}의 리스트에서 임의의 모노이드 \\hask{m}로 가는 모노이드 사상(morphism)을 구성할 수 있어야 합니다. 단, \\hask{a}에서 \\hask{m}(의 기본 집합)으로의 제약 없는 매핑이 주어졌을 때입니다. 이러한 모든 것을 Haskell에서는 표현할 수는 없지만, 함수를 정의할 수는 있습니다:","This function transforms the elements of the list to monoidal values using \\hask{f} and then folds them using \\hask{mappend}, starting with the unit \\hask{mempty}.":"이 함수는 리스트의 요소들을 \\hask{f}를 사용하여 모노이드(monoidal) 값으로 변환한 후, 단위 \\hask{mempty}로 시작하여 \\hask{mappend}를 사용하여 접습니다.","It's easy to see that an empty list is mapped to the monoidal unit. It's not too hard to see that a concatenation of two lists is mapped to the monoidal product of the results. So, indeed, \\hask{foldMap} is a monoid morphism.":"빈 리스트는 모노이드 단위로 매핑된다는 것을 쉽게 알 수 있 ~니다. 또한 두 리스트의 연결은 결과의 모노이드 곱으로 매핑된다는 것도 어렵지 않게 알 수 있 ~니다. 그래서, 참으로, \\hask{foldMap}은 모노이드 사상 ~입니다.","Following the intuition of a free monoid being a domain-specific program for multiplying stuff, \\hask{foldMap} provides an \\emph{interpreter} for this program. It performs all the multiplications that have been postponed. Note that the same program may be interpreted in many different ways, depending on the choice of the concrete monoid and the function \\hask{f}.":"자유 모노이드(free monoid)의 직관에 따라 \\hask{foldMap}은 이 프로그램의 \\emph{인터프리터(interpreter)}를 제공합니다. 이는 연기된 모든 곱셈을 수행합니다. 같은 프로그램이 선택된 구체적인 모노이드와 함수 \\hask{f}에 따라 여러 가지 방식으로 해석될 수 있다는 점에 유의하십시오.","We'll come back to free monoids as lists in the chapter on algebras.":"자유 모노이드(free monoids)에 대해서는 대수(chapter on algebras) 장에서 다시 다루겠습니다.","We can define composition of adjunctions by taking advantage of the composition of functors that define them. Two adjunctions, $L \\dashv R$ and $L' \\dashv R'$, are composable if they share the category in the middle:":"두 adjunction (짝맞춤) $L \\dashv R$와 $L' \\dashv R'$는 그들을 정의하는 함자(함수)의 합성을 이용하여 구성할 수 있습니 다(정의할 수 있습니다). 두 adjunction, $L \\dashv R$와 $L' \\dashv R'$,는 중간의 카테고리를 공유하는 경우에 구 성가능합니 다.","By composing the functors we get a new adjunction $(L' \\circ L) \\dashv (R \\circ R')$.":"함수자들을 합성함으로써 우리는 새로운 수반(adjunction) $(L' \\circ L) \\dashv (R \\circ R')$을 얻게 됩니다.","Indeed, let's consider the hom-set:":"실제로, 다음의 사상 집합(hom-set)을 생각해봅시다:","\\mathcal{C}(L' (L e), c)":"\\mathcal{C}(L' (L e), c)","Using the $L' \\dashv R'$ adjunction, we can transpose $L'$ to the right, where it becomes $R'$:":"$L' \\dashv R'$ 수반(adjunction)을 사용하여 $L'$를 오른쪽으로 변환할 수 있으며, 이는 $R'$이 됩니다.","\\mathcal{D}(L e, R' c)":"\\mathcal{D}(L e, R' c)","and using $L \\dashv R$ we can similarly transpose $L$:":"그리고 $L \\dashv R$을(를) 사용하여 $L$을 유사하게 전치할 수 있습니다:","\\mathcal{E}( e, R(R' c))":"\\mathcal{E}( e, R(R' c))","Combining these two isomorphisms, we get the composite adjunction:":"이 두 아이소몰피즘(isomorphisms)을 결합하여, 우리는 다음의 복합 부여(compound adjunction)를 얻습니다:","\\mathcal{C}((L' \\circ L) e, c) \\cong \\mathcal{E}( e, (R \\circ R') c)":"\\mathcal{C}((L' \\circ L) e, c) \\cong \\mathcal{E}( e, (R \\circ R') c)","Because functor composition is associative, the composition of adjunctions is also associative. It's easy to see that a pair of identity functors forms a trivial adjunction that serves as the identity with respect to composition of adjunctions. Therefore we can define a category $\\mathbf{Adj}(\\mathbf{Cat})$ in which objects are categories and arrows are adjunctions (by convention, pointing in the direction of the left adjoint).":"함자(funct or)의 합성은 결합법칙이 성립하기 때문에, 수반작용(adjunctions)의 합성도 결합법칙이 성립합니다. 항등 함자(identity functors) 한 쌍이 자명한 수반작용(trivial adjunction)을 구성하여 수반작용의 합성에 대해 항등원 역할을 한다는 것을 쉽게 알 수 있습니다. 따라서 객체가 범주(categories)이고 화살표가 수반작용(adjunctions)인 범주 $\\mathbf{Adj}(\\mathbf{Cat})$를 정의할 수 있습니다 (관례에 따라 왼쪽 수반 방향을 가리킵니다).","Adjunctions can be defined purely in terms of functors and natural transformations, that is 1-cells and 2-cells in the 2-category $\\mathbf{Cat}$. There is nothing special about $\\mathbf{Cat}$, and in fact adjunctions can be defined in any 2-category. Moreover, the category of adjunctions is itself a 2-category.":"Adjunction(수반 작용)은 전적으로 함자(functors)와 자연 변환(natural transformations), 즉 2-범주(2-category) $\\mathbf{Cat}$ 내의 1-셀(1-cells) 및 2-셀(2-cells)로 정의될 수 있습니. $\\mathbf{Cat}$에 대해서 특별한 점은 없으며, 실제로 수반 작용(adjunctions)은 어떤 2-범주 내에서도 정의될 수 있습니. 또한, 수반 작용의 범주는 그 자체로 2-범주 입니.","Category theory is about structuring our knowledge. In particular, it can be applied to the knowledge of category theory itself. Hence we see a lot of mixing of abstraction levels in category theory. The structures that we see at one level can be grouped into higher-level structures which exhibit even higher levels of structure, and so on.":"범주 이론(Category theory)은 우리의 지식을 구조화하는 것입니다. 특히, 이것은 범주 이론 자체에 관한 지식에 적용될 수 있습니다. 따라서 범주 이론에서는 추상화 수준의 많은 혼합을 볼 수 있습니다. 한 수준에서 보는 구조들은 더 높은 수준의 구조로 그룹화될 수 있으며, 이는 더 높은 수준의 구조를 보이는 등의 방식으로 이어집니다.","In programming we are used to building hierarchies of abstractions. Values are grouped into types, types into kinds. Functions that operate on values are treated differently than functions that operate on types. We often use different syntax to separate levels of abstractions. Not so in category theory.":"프로그래밍에서는 추상화 계층을 구축하는 데 익숙합니다. 값들은 타입(형)으로 그룹화되며, 타입들은 종류(킨드)로 그룹화됩니다. 값에 작동하는 함수들은 타입에 작동하는 함수들과 다르게 처리됩니다. 추상화 수준을 구분하기 위해 종종 다른 구문을 사용합니다. 범주 이론에서는 그렇지 않습니다.","A set, categorically speaking, can be described as a discrete category. Elements of the set are objects of this category and, other than the obligatory identity morphisms, there are no arrows between them.":"한 집합(set)은 범주론적으로 말하면 이산 범주(discrete category)로 묘사될 수 있습니. 집합의 원소들은 이 범주의 객체들이며, 필수적인 항등 사상(identity morphisms)을 제외하고는 그들 사이에 아무런 화살표(arrows)가 없습니다.","The same set can then be seen as an object in the category $\\mathbf{Set}$. Arrows in this category are functions between sets.":"같은 집합은 카테고리 $\\mathbf{Set}$의 객체로 볼 수 있습니 다. 이 카테고리에서 화살표는 집합들 간의 함수입니다.","The category $\\mathbf{Set}$, in turn, is an object in the category $\\mathbf{Cat}$. Arrows in $\\mathbf{Cat}$ are functors.":"카테고리 $\\mathbf{Set}$는 다시 카테고리 $\\mathbf{Cat}$의 객체입니다. $\\mathbf{Cat}$의 화살표는 함자(functor)입니다.","Functors between any two categories $\\mathcal{C}$ and $\\mathcal{D}$ are objects in the functor category $[\\mathcal{C}, \\mathcal{D}]$. Arrows in this category are natural transformations.":"두 범주 $\\mathcal{C}$와 $\\mathcal{D}$ 사이의 함자는 함자 범주 $[\\mathcal{C}, \\mathcal{D}]$의 객체들입니다. 이 범주의 화살표는 자연 변환입니다.","We can define functors between functor categories, product categories, opposite categories, and so on, ad infinitum.":"펑터 범주(functor categories), 곱 범주(product categories), 반대 범주(opposite categories) 사이의 펑터를 무한히 정의할 수 있습니.","Completing the circle, hom-sets in every category are sets. We can define mappings and isomorphisms between them, reaching across disparate categories. Adjunctions are possible because we can compare hom-sets that live in different categories.":"원을 완성하면서, 모든 범주에서 \\textbf{hom-집합들}은 집합들입니다. 우리는 이들 사이의 함수와 \\textbf{동형사상들}(isomorphisms)을 정의할 수 있으며, 이는 서로 다른 범주를 가로지를 수 있습니다. \\textbf{에쥑션들}(Adjunctions)은 다른 범주에 속한 \\textbf{hom-집합들}을 비교할 수 있기 때문에 가능합니다."}