{"\\chapter{Functors}":"\\chapter{함자(Functors)}","\\section{Categories}":"\\section{카테고리(Categories)}","So far we've only seen one category---that of types and functions. So let's quickly gather the essential info about a category.":"지금까지 우리는 오직 한 가지 범주---타입과 함수들의 범주만을 보았습니다. 그러니 범주에 관한 필수 정보를 빠르게 모아봅시다.","A category is a collection of objects and arrows that go between them. Every pair of composable arrows can be composed. The composition is associative, and there is an identity arrow looping back on every object.":"카테고리는 객체들과 그것들 사이를 오가는 화살표들의 모음입니다. 모든 조합 가능한 화살표 쌍은 조합될 수 있습니다. 조합은 결합 법칙을 따르며, 모든 객체마다 되돌아오는 항등 화살표(identity arrow)가 있습니다.","The fact that types and functions form a category can be expressed in Haskell by defining composition as:":"타입(types)과 함수(functions)가 범주(category)를 형성한다는 사실은 합성을 다음과 같이 정의하여 Haskell에서 표현될 수 있습니:\n","The composition of two functions \\hask{g} after \\hask{f} is a new function that first applies \\hask{f} to its argument and then applies \\hask{g} to the result.":"두 함수 \\hask{g}와 \\hask{f}의 합성은 먼저 \\hask{f}를 인수에 적용하고 그 결과에 \\hask{g}를 적용하는 새로운 함수입니다.","The identity is a polymorphic ``do nothing'' function:":"정체성(Identity)은 다형적인 \"아무 것도 하지 않는\" 함수입니다:","You can easily convince yourself that such composition is associative, and composing with \\hask{id} does nothing to a function.":"자신을 쉽게 설득할 수 있습니 다, 이러한 합성은 결합 법칙을 따르며, \\hask{id} 와 합성 하는 것은 함수에 아무것도 하지 않는 다는 것을.","Based on the definition of a category, we can come up with all kinds of weird categories. For instance, there is a category that has no objects and no arrows. It satisfies all the condition of a category vacuously. There's another that contains a single object and a single arrow (can you guess what arrow it is?). There's one with two unconnected objects, and one where the two objects are connected by a single arrow (plus two identity arrows), and so on. These are example of what I call \\index{stick-figure category}stick-figure categories---categories with a small handful of objects and arrows.":"범주의 정의를 바탕으로, 우리는 여러 가지 이상한 범주들을 생각해낼 수 있습니니다. 예를 들어, 객체도 없고 화살표도 없는 범주가 있습니니다. 이는 범주의 모든 조건을 공허하게 충족합니니다. 또 다른 예로, 단일 객체와 단일 화살표만을 포함하는 범주가 있습니니다 (그 화살표가 무엇인지 추측할 수 있겠습니까?). 연결되지 않은 두 객체를 가진 범주가 있습니니다, 두 객체가 단일 화살표로 연결된 범주가 있습니니다 (플러스 두 개의 항등 화살표(identity arrows)), 등등. 이러한 예는 내가 \\index{stick-figure category}stick-figure category(막대 인형 범주)라고 부르는 것들로, 소수의 객체와 화살표를 가진 범주입니니다.","\\subsection{Category of sets}":"\\subsection{집합의 범주(Category of sets)}","We can also strip a category of all arrows (except for the identity arrows). Such a bare-object category is called a \\index{discrete category}\\emph{discrete} category or a set\\footnote{Ignoring ``size'' issues.}. Since we associate arrows with structure, a set is a category with no structure.":"우리는 또한 모든 화살표(항등 화살표는 제외)를 제거할 수 있습니다. 이러한 단순-객체 범주를 \\index{이산 범주}\\emph{이산} 범주(discrete category) 또는 집합(set)\\footnote{``크기'' 문제는 무시합니다.}이라고 합니다. 우리는 화살표를 구조와 연관시키므로, 집합은 구조가 없는 범주입니다.","Sets form their own category called $\\mathbf{Set}$\\footnote{Again, ignoring ``size'' issues, in particular the non-existence of the set of all sets.}. The objects in that category are sets, and the arrows are functions between sets. Such functions are defined as special kind of relations, which themselves are defined as sets of pairs.":"집합들은 그들 자신의 범주 $\\mathbf{Set}$\\footnote{다시 말해, ``크기'' 문제, 특히 모든 집합의 집합의 존재하지 않음을 무시함.}를 형성합니다. 그 범주의 객체들은 집합들이며, 화살표들은 집합들 간의 함수(함수, functions)입니다. 이러한 함수들은 특별한 종류의 관계(관계, relations)로 정의되며, 이 관계들은 그 자체로 쌍들의 집합으로 정의됩니다.","To the lowest approximation, we can model programming in the category of sets. We often think of types as sets of values, and functions as set-theoretical functions. There's nothing wrong with that. In fact all of categorical construction we've described so far have their set-theoretical roots. The categorical product is a generalization of the cartesian product of sets, the sum is the disjoint union, and so on.":"대략적으로, 우리는 집합의 범주에서 프로그래밍을 모델링할 수 있습니 다. 우리는 종종 타입(type)을 값들의 집합으로, 함수를 집합이론적 함수(set-theoretical functions)로 생각합니다. 그것은 잘못이 아닙니다. 실제로 지금까지 설명한 모든 범주론적 구성(categorical construction)은 집합이론적 뿌리(set-theoretical roots)를 가지고 있습니다. 범주론적 곱(categorical product)은 집합의 데카르트 곱(cartesian product)의 일반화이고, 합(sum)은 분리 합집합(disjoint union) 등입니다.","What category theory offers is more precision: the fine distinction between the structure that is absolutely necessary, and the superfluous details.":"Category 이론이 제공하는 것은 더 높은 정밀도입니다: 필수적인 구조와 불필요한 세부사항 간의 미세한 차이를 구분합니다.","A set-theoretical function, for instance, doesn't fit the definition of a function we work with as programmers. Our functions must have underlying algorithms because they have to be computable by some physical systems, be it computers or a human brains.":"집합 이론적 함수(set-theoretical function), 예를 들면, 우리가 프로그래머로서 사용하는 함수의 정의에는 맞지 않습니다. 우리의 함수들은 반드시 기본적인 알고리즘을 가져야 합니다. 왜냐하면, 그것들은 어떤 물리적 시스템(컴퓨터 또는 인간의 뇌)에 의해 계산 가능해야 하기 때문이다.","\\subsection{Opposite categories}":"\\subsection{반대 범주(Opposite categories)}","In programming, the focus is on the category of types and functions, but we can use this category as a starting point to construct other categories.":"프로그래밍에서 초점은 타입과 함수의 범주(category) 에 맞춰져 있지만, 이 범주를 출발점으로 삼아 다른 범주들을 구성할 수 있습니 다.","One such category is called the \\emph{opposite} category. This is the category in which all the original arrows are inverted: what is called the source of an arrow in the original category is now called its target, and vice versa.":"그러한 카테고리 중 하나는 \\emph{반대(opposite)} 카테고리라고 불립니다. 이는 모든 원래 화살표들이 반전된 카테고리입니다: 원래 카테고리에서 화살표의 출발지(source)라고 불리는 것이 이제 화살표의 도착지(target)라고 불리며, 반대의 경우도 마찬가지입니다.","The opposite of a category $\\mathcal{C}$ is called $\\mathcal{C}^{op}$. We've had a glimpse of this category when we discussed duality. The objects of $\\mathcal{C}^{op}$ are the same as those of $\\mathcal{C}$.":"카테고리 $\\mathcal{C}$의 반대는 $\\mathcal{C}^{op}$라고 합니다. 이는 우리가 쌍대(duality)를 논의했을 때 살펴보았습니다. $\\mathcal{C}^{op}$의 객체(objects)는 $\\mathcal{C}$의 객체와 동일합니다.","Whenever there is an arrow $f \\colon a \\to b$ in $\\mathcal{C}$, there is a corresponding arrow $f^{op} \\colon b \\to a$ in $\\mathcal{C}^{op}$.":"Whenever there is an arrow $f \\colon a \\to b$ in $\\mathcal{C}$, there is a corresponding arrow $f^{op} \\colon b \\to a$ in $\\mathcal{C}^{op}$.\n화살표 $f \\colon a \\to b$가 $\\mathcal{C}$ 안에 있을 때, $\\mathcal{C}^{op}$ 안에는 대응하는 화살표 $f^{op} \\colon b \\to a$가 있습니다.","The composition $g^{op} \\circ f^{op}$ of two such arrows $f^{op} \\colon a \\to b$ and $g^{op} \\colon b \\to c$ is given by the arrow $f \\circ g$ (notice the reversed order).":"두 화살표 $f^{op} \\colon a \\to b$ 와 $g^{op} \\colon b \\to c$의 합성 $g^{op} \\circ f^{op}$은 화살표 $f \\circ g$로 주어집니다 (순서가 반대로 되어 있는 것을 주의하세요).","The terminal object in  $\\mathcal{C}$ is the initial object in $\\mathcal{C}^{op}$, the product in  $\\mathcal{C}$ is the sum in $\\mathcal{C}^{op}$, and so on.":"$\\mathcal{C}$에서의 종단 대상(terminal object)은 $\\mathcal{C}^{op}$에서의 시작 대상(initial object)입니다, $\\mathcal{C}$에서의 곱(product)은 $\\mathcal{C}^{op}$에서의 합(sum)입니다, 그리고 계속해서 그렇습니다.","\\subsection{Product categories}":"\\subsection{곱 카테고리(Product categories)}","Given two categories $\\mathcal{C}$ and $\\mathcal{D}$, we can construct a product category $\\mathcal{C} \\times \\mathcal{D}$. The objects in this category are pairs of objects $\\langle c, d \\rangle $, and the arrows are pairs of arrows.":"두 범주 $\\mathcal{C}$와 $\\mathcal{D}$가 주어졌을 때, 우리는 곱 범주 $\\mathcal{C} \\times \\mathcal{D}$를 구성할 수 있습니 다. 이 범주에서 대상(objects)들은 쌍으로 된 대상들 $\\langle c, d \\rangle $이며, 사상(arrows)들은 쌍으로 된 사상들입니다.","If we have an arrow $f \\colon c \\to c'$ in $\\mathcal{C}$ and an arrow $g \\colon d \\to d'$ in $\\mathcal{D}$ then there is a corresponding arrow $\\langle f, g \\rangle$ in $\\mathcal{C} \\times \\mathcal{D}$.  This arrow goes from $\\langle c, d \\rangle $ to $\\langle c', d' \\rangle $, both being objects in $\\mathcal{C} \\times \\mathcal{D}$. Two such arrows can be composed if their components are composable in, respectively, $\\mathcal{C}$ and $\\mathcal{D}$. An identity arrow is a pair of identity arrows.":"만약 $\\mathcal{C}$에서 화살표 $f \\colon c \\to c'$와 $\\mathcal{D}$에서 화살표 $g \\colon d \\to d'$가 있다면, $\\mathcal{C} \\times \\mathcal{D}$에서 이에 대응하는 화살표 $\\langle f, g \\rangle$가 존재합니다. 이 화살표는 $\\mathcal{C} \\times \\mathcal{D}$의 객체 $\\langle c, d \\rangle$에서 $\\langle c', d' \\rangle$로 갑니다. 이러한 두 화살표는 각각 $\\mathcal{C}$와 $\\mathcal{D}$에서 그 구성 요소들이 합성 가능할 때 합성할 수 있습니다. 항등 화살표는 항등 화살표의 쌍입니다.","The two product categories we're most interested in are $\\mathcal{C} \\times \\mathcal{C}$ and $\\mathcal{C}^{op} \\times \\mathcal{C}$, where $\\mathcal{C}$ is our familiar category of types and functions.":"우리가 가장 관심있는 두 가지 곱 카테고리(product categories)는 $\\mathcal{C} \\times \\mathcal{C}$와 $\\mathcal{C}^{op} \\times \\mathcal{C}$입니다. 여기서 $\\mathcal{C}$는 우리가 익숙한 유형(types)과 함수들(functions)의 카테고리(category)입니다.","In both of these categories, objects are pairs of objects from $\\mathcal{C}$. In the first category, $\\mathcal{C} \\times \\mathcal{C}$, a morphism from $\\langle a, b \\rangle $ to $\\langle a', b' \\rangle $ is a pair $\\langle f \\colon a \\to a', g \\colon b \\to b' \\rangle $. In the second category, $\\mathcal{C}^{op} \\times \\mathcal{C}$, a morphism is a pair $\\langle f \\colon a' \\to a, g \\colon b \\to b' \\rangle $, in which the first arrow goes in the opposite direction.":"두 카테고리 모두에서, 대상은 $\\mathcal{C}$의 대상 쌍입니다. 첫 번째 카테고리인 $\\mathcal{C} \\times \\mathcal{C}$에서는 $\\langle a, b \\rangle $에서 $\\langle a', b' \\rangle $으로의 사상(morphism)은 $\\langle f \\colon a \\to a', g \\colon b \\to b' \\rangle $ 쌍입니다. 두 번째 카테고리인 $\\mathcal{C}^{op} \\times \\mathcal{C}$에서는 사상(morphism)이 $\\langle f \\colon a' \\to a, g \\colon b \\to b' \\rangle $ 쌍인데, 여기서 첫 번째 화살표는 반대 방향으로 갑니다.","\\subsection{Slice categories}":"\\subsection{슬라이스 범주(Slice categories)}","In a neatly organized universe, objects are always objects and arrows are always arrows. Except that sometimes sets of arrows can be thought of as objects. But slice categories break this neat separation: they turn individual arrows into objects.":"정돈된 우주에서는, 오브젝트는 항상 오브젝트이고 화살표(arrow)는 항상 화살표입니다. 그러나 가끔 화살표의 집합을 오브젝트로 생각할 수 있습니다. 그러나 슬라이스 카테고리(slice categories)는 이 깔끔한 구분을 깨뜨립니다: 개별 화살표를 오브젝트로 바꿉니다.","A slice category $\\cat C/c$ describes how a particular object $c$ is seen from the perspective of its category $\\cat C$. It's the totality of arrows pointing at $c$. But to specify an arrow we need to specify both of its ends. Since one of these ends is fixed to be $c$, we only have to specify the other.":"슬라이스 범주(slice category) $\\cat C/c$는 특정 객체 $c$가 그 범주 $\\cat C$의 관점에서 어떻게 보이는지를 설명합니다. 이는 $c$를 가리키는 모든 화살표의 총체입니다. 하지만 화살표를 명시하기 위해서는 그 양 끝을 모두 명시해야 합니다. 이 중 한 끝은 $c$로 고정되어 있으므로, 우리는 다른 한쪽만 지정하면 됩니다.","An object in the  \\index{slice category}\\emph{slice category} $\\mathcal{C}/c$ (also known as an \\index{over category}over-category) is a pair $\\langle e, p \\rangle$, with $p \\colon e \\to c$.":"\\index{슬라이스 카테고리}\\emph{슬라이스 카테고리} $\\mathcal{C}/c$ (또는 \\index{오버 카테고리}오버-카테고리로도 알려짐)에서 객체는 쌍 $\\langle e, p \\rangle$으로, $p \\colon e \\to c$을 가지고 있읍니다.","An arrow between two objects $\\langle e, p \\rangle$ and $\\langle e', p' \\rangle$ is an arrow $f \\colon e \\to e'$ of $\\cat C$ which makes the following triangle commute:":"두 객체 $\\langle e, p \\rangle$와 $\\langle e', p' \\rangle$ 사이의 사상은 $\\cat C$의 사상 $f \\colon e \\to e'$으로서 다음 삼각형을 교환되게 하는 것입니다:\n","\\subsection{Coslice categories}":"\\subsection{코슬라이스 카테고리(Coslice categories)}","There is a dual notion of a \\index{coslice category}coslice category $c / \\mathcal{C}$, also known as an \\index{under-category}under-category. It's a category of arrows emanating from a fixed object $c$. Objects in this category are pairs $\\langle a, i \\colon c \\to a \\rangle$. Morphisms in $c / \\mathcal{C}$ are arrows that make the relevant  triangles commute.":"이중적으로 \\index{coslice category}코슬라이스 범주 $c / \\mathcal{C}$의 개념이 있습니다. 이는 \\index{under-category}언더-카테고리로도 알려져 있습니다. 이는 고정된 객체 $c$로부터 나오는 화살표들의 범주입니다. 이 범주의 객체들은 쌍 $\\langle a, i \\colon c \\to a \\rangle$입니다. $c / \\mathcal{C}$의 사상들은 관련된 삼각형이 가환하도록 만드는 화살표들입니다.","In particular, if the category $\\mathcal{C}$ has a terminal object $1$, then the coslice $1 / \\mathcal{C}$ has, as objects, global elements of all the objects of $\\mathcal{C}$.":"특히, 범주 $\\mathcal{C}$가 종말 대상(terminal object) $1$을 가지고 있다면, 코슬라이스 범주(coslice) $1 / \\mathcal{C}$는 $\\mathcal{C}$의 모든 대상들의 전역 원소(global elements)들을 대상으로 가집니다.","Morphisms of $1/  \\mathcal{C}$ that correspond to arrows $f \\colon a \\to b$ map the set of global elements of $a$ to the set of global elements of $b$.":"$1/  \\mathcal{C}$의 사상들(morphisms)은 화살표 $f \\colon a \\to b$에 해당하며, $a$의 전역 원소들(global elements)을 $b$의 전역 원소들로 매핑합니다.","In particular, the construction of a coslice category from the category of types and functions justifies our intuition of types as sets of values, with values represented by global elements of types.":"특히 타입과 함수의 카테고리에서 코슬라이스 카테고리(coslice category)를 구성하는 것은 타입을 값들의 집합으로 직관하는 우리의 생각을 정당화하며, 값들은 타입의 전역 요소(global elements)로 표현됩니다.","\\section{Functors}":"\\section{함수자(Functors)}","We've seen examples of functoriality when discussing algebraic data types. The idea is that such a data type ``remembers'' the way it was created, and we can manipulate this memory by applying an arrow to its ``contents.''":"우리는 대수 데이터 타입(algebraic data types)을 논의할 때 함수적(functorial)인 예들을 보았습니다. 이러한 데이터 타입의 아이디어는 생성된 방식을 ``기억''하며, 우리는 그의 ``내용물''에 화살을 적용하여 이 기억을 조작할 수 있습니다.","In some cases this intuition is very convincing: we think of a product type as a pair that ``contains'' its ingredients. After all, we can retrieve them using projections.":"어떤 경우에는 이 직관이 매우 설득력 있습니. 우리는 곱 타입(product type)을 그 성분을 '포함하는' 쌍으로 생각합니다. 결국, 우리는 투영(projections)을 사용하여 그것들을 검색할 수 있습니.","This is less obvious in the case of function objects. You can visualize a function object as secretly storing all possible results and using the function argument to index into them. A function from \\hask{Bool} is obviously equivalent to a pair of values, one for \\hask{True} and one for \\hask{False}. It's a known programming trick to implement some functions as lookup tables. It's called \\emph{memoization}.":"This is less obvious in the case of function objects. You can visualize a function object as secretly storing all possible results and using the function argument to index into them. A function from \\hask{Bool} is obviously equivalent to a pair of values, one for \\hask{True} and one for \\hask{False}. It's a known programming trick to implement some functions as lookup tables. It's called \\emph{memoization(메모이제이션)}.","Even though it's not practical to memoize functions that take, say, natural numbers as arguments; we can still conceptualize them as (infinite, or even uncountable) lookup tables.":"비록 자연수를 인수로 취하는 함수를 메모이제이션(memoize)하는 것이 실용적이지 않다 해도; 우리는 여전히 그것들을 (무한하거나 심지어 셀 수 없을 정도로 큰) 조회 테이블(lookup tables)로 개념화할 수 있습니.","If you can think of a data type as a container of values, it makes sense to apply a function to transform all these values, and create a transformed container. When this is possible, we say that the data type is \\emph{functorial}.":"만약 데이터 타입을 값들의 컨테이너로 생각할 수 있다면, 이 값들을 변환하는 함수를 적용하여 변환된 컨테이너를 만들면 의미가 있습니다. 이게 가능할 때, 우리는 그 데이터 타입이 \\emph{함자적(functorial)}이라고 합니다.","Again, function types require some more suspension of disbelief. You visualize a function object as a lookup table, keyed by some type. If you want to use another, related type as your key, you need a function that translates the new key to the original key. This is why functoriality of the function object has one of the arrows reversed:":"다시 말해, 함수 타입(function types)은 약간의 불신을 유보해야 합니다. 함수 객체(function object)를 특정 타입에 의해 키로 설정된 조회 테이블(lookup table)로 시각화합니다. 만약 다른, 관련된 타입을 키로 사용하고 싶다면, 새로운 키를 원래 키로 변환하는 함수가 필요합니다. 이것이 함수 객체의 함자성(functoriality)이 하나의 화살표를 반대로 가지는 이유입니다:","You are applying the transformation to a function \\hask{h :: a -> b} that has a ``receptor'' that responds to values of type \\hask{a}, and you want to use it to process input of type \\hask{a'}. This is only possible if you have a converter from \\hask{a'} to \\hask{a}, namely \\hask{f :: a' -> a}.":"You are applying the transformation to a function \\hask{h :: a -> b} that has a ``receptor'' that responds to values of type \\hask{a}, and you want to use it to process input of type \\hask{a'}. This is only possible if you have a converter from \\hask{a'} to \\hask{a}, namely \\hask{f :: a' -> a}.\n\n함수 \\hask{h :: a -> b}에 변환을 적용하고 있으며, 이 함수는 타입 \\hask{a} 값을 반응하는 \"수용체\"를 가지고 있다. 그리고 당신은 이를 타입 \\hask{a'}의 입력을 처리하는 데 사용하고자 합니다. 이는 오직 \\hask{a'}로부터 \\hask{a}로 변환하는 변환기 \\hask{f :: a' -> a}를 가지고 있을 때만 가능합니다.","The idea of a data type ``containing'' values of another type can be also expressed by saying that one data type is paremeterized by another. For instance, the type \\hask{List a} is parameterized by the type \\hask{a}.":"데이터 타입이 다른 타입의 값을 ``포함''한다는 개념은 하나의 데이터 타입이 다른 타입에 의해 매개화(파라미터라이즈)된다고 말함으로써 표현될 수 있습니\n다. 예를 들어, 타입 \\hask{List a}는 타입 \\hask{a}에 의해 매개화됩니다.","In other words, \\hask{List} maps the type \\hask{a} to the type \\hask{List a}. \\hask{List} by itself, without the argument, is called a \\emph{type constructor}.":"다시 말해, \\hask{List}는 타입 \\hask{a}를 타입 \\hask{List a}로 매핑합니다. \\hask{List} 자체는 인자가 없을 때 \\emph{타입 생성자(type constructor)}라고 불립니다.","\\subsection{Functors between categories}":"\\subsection{함자(Functor) 사이의 사상}","In category theory, a type constructor is modeled as a mapping of objects to objects. It's a function on objects. This is not to be confused with arrows between objects, which are part of the structure of the category.":"범주론(category theory)에서, 타입 생성자(type constructor)는 객체를 객체로 매핑하는 것으로 모델링됩니다. 이는 객체에 대한 함수(function)입니다. 이는 범주의 구조의 일부인 객체 간의 화살표(arrows)와 혼동해서는 안 됩니다.","In fact, it's easier to imagine a mapping \\emph{between} categories. Every object in the source category is mapped to an object in the target category. If $a$ is an object in $\\mathcal{C}$, there is a corrsponding object $F a$ in $\\mathcal{D}$.":"사실, 카테고리 \\emph{사이의} 매핑을 상상하는 것이 더 쉽습니다. 원본 카테고리의 모든 객체는 대상 카테고리의 객체에 매핑됩니다. 만약 $a$가 $\\mathcal{C}$의 객체라면, 이에 상응하는 객체 $F a$가 $\\mathcal{D}$에 있습니다.","A functorial mapping, or a \\emph{functor}, not only maps objects but also arrows between them. Every arrow":"함자적 매핑(functorial mapping), 또는 \\emph{함자(functor)}는 객체뿐만 아니라 그 사이의 화살표도 매핑합니다. 모든 화살표","in the first category has a corresponding arrow in the second category:":"첫 번째 카테고리(category)에는 두 번째 카테고리(category)에서 대응되는 화살표(arrow)가 있습니다.","We use the same letter, here $F$, to name both, the mapping of objects and the mapping of arrows.":"우리는 같은 문자인 $F$를 사용하여 객체의 사상과 화살표의 사상을 모두 이름 붙입니다.","If categories distill the essence of \\emph{structure}, then functors are mappings that preserve this structure. Objects that are related in the source category are related in the target category.":"만약 범주(category)들이 \\emph{구조(structure)}의 본질을 추출해낸다면, 펑터(functor)들은 이 구조를 보존하는 사상(mapping)들입니다. 원본 범주에서 관련된 객체(object)들은 대상 범주에서 관련됩니다.","The structure of a category is defined by arrows and their composition. Therefore a functor must preserve composition. What is composed in one category:":"한 범주의 구조는 화살(화살표)과 그들의 합성으로 정의되니다. 따라서 펑터(functer)는 합성을 보존해야 합니다. 한 범주에서 합성된 것은:","should remain composed in the second category:":"두 번째 카테고리에서 구성되어야 합니다:","We can either compose two arrows in $\\mathcal{C}$ and map the composite to $\\mathcal{D}$, or we can map individual arrows and then compose them in $\\mathcal{D}$. We demand that the result be the same.":"우리는 $\\mathcal{C}$에서 두 화살표를 합성한 후 $\\mathcal{D}$로 매핑할 수 있으며, 또는 개별 화살표를 매핑한 후 $\\mathcal{D}$에서 합성할 수 있습니다. 우리는 그 결과가 동일하도록 요구합니다.","Finally, a functor must preserve identity arrows:":"마지막으로, 함자(펑터, functor)는 항등 화살(아이덴티티 애로우, identity arrows)를 보존해야 합니다:","These conditions taken together define what it means for a functor to preserve the structure of a category.":"이 조건들을 함께 취하면 함자(functor)가 범주의 구조를 보존한다는 것이 무엇을 의미하는지 정의합니다.","It's also important to realize what conditions are \\emph{not} part of the definition. For instance, a functor is allowed to map multiple objects into the same object. It can also map multiple arrows into the same arrow, as long as the endpoints match.":"유의할 점은 어떤 조건들이 정의의 일부가 \\emph{아닌지} 이해하는 것 또한 중요합니다. 예를 들어, 함자(functor)는 여러 객체를 동일한 객체에 대응시키는 것을 허용합니다. 또한 시작점과 끝점이 맞는다면 여러 사상(arrow)을 동일한 사상으로 맵핑하는 것도 가능합니다.","In the extreme, any category can be mapped to a singleton category with one object and one arrow.":"극단적으로, 모든 범주는 하나의 객체(object)와 하나의 화살표(arrow)로 구성된 단일 요소 범주(singleton category)에 매핑될 수 있습니다.","Also, not all object or arrows in the target category must be covered by a functor. In the extreme, we can have a functor from the singleton category to any (non-empty) category. Such a functor picks a single object together with its identity arrow.":"또한, 모든 대상(객체, object) 또는 사상(화살표, arrows)이 대상 범주(target category)에서 함자(functor)에 의해 커버될 필요는 없습니니다. 극단적으로, 우리는 단일 집합 범주(singleton category)에서 어떤(비어있지 않은, non-empty) 범주로의 함자를 가질 수 있습니니다. 이러한 함자는 하나의 대상(객체)과 그것의 항등 사상(identity arrow)를 선택합니니다.","A \\index{constant functor}\\emph{constant functor} $\\Delta_c$ is an example of a functor that maps all objects from the source category to a single object $c$ in the target category, and all arrows from the source category to a single identity arrow $id_c$.":"A \\index{constant functor}\\emph{상수 함자}(constant functor) $\\Delta_c$는 원천 범주에서 모든 대상을 목표 범주의 단일 대상 $c$로, 원천 범주의 모든 화살을 목표 범주의 단일 항등 화살 $id_c$로 사상하는 함자의 예입니다.","In category theory, functors are often used to create models of one category inside another. The fact that they can merge multiple objects and arrows into one means that they produce simplified views of the source category. They ``abstract'' some aspects of the source category.":"범주 이론에서, 함수자(functors)는 한 범주의 모델을 다른 범주 안에 만드는 데 자주 사용됩니다. 함수자가 여러 객체와 화살표를 하나로 병합할 수 있다는 사실은 그들이 원천 범주의 단순화된 뷰를 생성한다는 것을 의미합니다. 그들은 원천 범주의 일부 측면을 ``추상화''합니다.","The fact that they may only cover parts of the target category means that the models are embedded in a larger environment.":"그들이 목표 범주(target category)의 일부만을 다룰 수 있다는 사실은 모델들이 더 큰 환경에 내재되어 있음을 의미합니다.","Functors from some minimalistic, stick-figure, categories can be used to define patterns in larger categories.":"어떤 최소한의 스틱 피규어(stick-figure) 범주로부터의 함자(Functors)는 더 큰 범주에서 패턴을 정의하는 데 사용될 수 있습니다.","\\]":"content:]\n\\documentclass{article}\n\\usepackage[utf8]{inputenc}\n\\usepackage{amsmath, amssymb, amsthm}\n\\usepackage{tikz-cd}\n\\usepackage{hyperref}\n\n\\theoremstyle{definition}\n\\newtheorem{definition}{정의}[section]\n\n\\title{카테고리 이론}\n\\author{저자 이름}\n\\date{\\today}\n\n\\begin{document}\n\n\\maketitle\n\n\\begin{abstract}\n이 논문은 카테고리 이론(Category Theory)의 기본 개념에 대해 소개합니다. 집합과 함수에서부터 시작하여, 범주, 사상, 그리고 자연 변환에 이르기까지 설명합니다.\n\\end{abstract}\n\n\\section{서론}\n카테고리 이론은 현대 수학의 여러 분야에서 유용한 도구입니다. 이 이론은 수학적 구조와 이들 사이의 관계를 추상화하여 다룹니다. \n\n\\section{기본 개념}\n\\subsection{범주}\n범주(category) \\(\\mathcal{C}\\)는 다음의 데이터로 구성됩니다:\n1. 객체(object)의 모임 \\(\\text{Ob}(\\mathcal{C})\\)\n2. 각 객체 쌍 \\(X, Y \\in \\text{Ob}(\\mathcal{C})\\)에 대해, \\(X\\)에서 \\(Y\\)로 가는 사상(morphism) \\(f: X \\rightarrow Y\\)의 모임 \\(\\text{Hom}(X,Y)\\)\n\n사상들은 다음의 두 가지 연산을 만족해야 합니다:\n1. 결합 법칙(Composition): 모든 사상 \\(f: X \\rightarrow Y\\)와 \\(g: Y \\rightarrow Z\\)에 대해, \\(g \\circ f: X \\rightarrow Z\\)가 정의됩니다.\n2. 항등원(Identity): 각 객체 \\(X \\in \\text{Ob}(\\mathcal{C})\\)에 대해, 항등 사상(identity morphism) \\(\\text{id}_X: X \\rightarrow X\\)가 존재하여야 합니다.\n\n\\subsection{함자}\n함자(functor) \\(F: \\mathcal{C} \\rightarrow \\mathcal{D}\\)는 두 범주 \\(\\mathcal{C}\\)와 \\(\\mathcal{D}\\) 사이의 구조를 보존하는 매핑(mapping)을 제공합니다. 함자는 다음의 데이터로 이루어져 있습니다:\n1. 각 객체 \\(X \\in \\text{Ob}(\\mathcal{C})\\)에 대해, \\(\\mathcal{D}\\)의 객체 \\(F(X)\\)가 존재합니다.\n2. 각 사상 \\(f: X \\rightarrow Y\\)에 대해, \\(\\mathcal{D}\\)의 사상 \\(F(f): F(X) \\rightarrow F(Y)\\)가 존재합니다.\n\n그리고 함자는 다음의 두 성질을 만족해야 합니다:\n1. 함자 \\(F\\)는 사상의 결합을 보존합니다: \\(F(g \\circ f) = F(g) \\circ F(f)\\)\n2. 함자 \\(F\\)는 항등 사상을 보존합니다: \\(F(\\text{id}_X) = \\text{id}_{F(X)}\\)\n\n\\subsection{자연 변환}\n두 함자 \\(F, G: \\mathcal{C} \\rightarrow \\mathcal{D}\\) 사이의 자연 변환(natural transformation) \\(\\eta\\)는 각 객체 \\(X \\in \\text{Ob}(\\mathcal{C})\\)에 대해, \\(\\mathcal{D}\\)의 사상 \\(\\eta_X: F(X) \\rightarrow G(X)\\)로 구성됩니다. 이 사상들은 다음의 자연성 조건을 만족해야 합니다:\n모든 사상 \\(f: X \\rightarrow Y\\)에 대해, \\(G(f) \\circ \\eta_X = \\eta_Y \\circ F(f)\\)\n\n\\end{document}\n","\\end{exercise}":"\\end{연습문제}","\\section{Functors in Programming}":"\\section{프로그래밍에서의 펑터}","Endofunctors are the class of functors that are the easiest to express in a programming language. These are functors that map a category (here, the category of types and functions) to itself.":"Endofunctors는 프로그래밍 언어에서 가장 쉽게 표현할 수 있는 함수자(functors) 클래스입니다. 이 함수자는 카테고리(여기서는 타입과 함수들의 카테고리)를 자기 자신으로 매핑하는 함수자입니다.","\\subsection{Endofunctors}":"\\subsection{엔도펑터(Endofunctors)}","The first part of the endofunctor is the mapping of types to types. This is done using type constructors, which are type-level functions.":"첫 번째 부분에서는 endofunctor의 타입을 타입으로 매핑합니다. 이는 타입 수준 함수인 타입 생성자(type constructors)를 사용해 수행됩니다.","The list type constructor, \\hask{List}, maps an arbitrary type \\hask{a} to the type \\hask{List a}.":"목록 타입 생성자, \\hask{List},는 임의의 타입 \\hask{a}를 타입 \\hask{List a}로 매핑합니다.","The \\hask{Maybe} type constructor maps \\hask{a} to \\hask{Maybe a}.":"\\hask{Maybe} 타입 생성자는 \\hask{a}를 \\hask{Maybe a}로 맵핑합니다.","The second part of an endofunctor is the mapping of arrows. Given a function \\hask{a -> b}, we want to be able to define a function \\hask{List a -> List b}, or \\hask{Maybe a -> Maybe b}. This is the ``functoriality'' property of these data types that we have discussed before. Functoriality lets us \\index{lifting}\\emph{lift} an arbitrary function to a function between transformed types.":"Endofunctor의 두 번째 부분은 사상(mapping)입니다. 함수 \\hask{a -> b}가 주어졌을 때, 우리는 \\hask{List a -> List b} 또는 \\hask{Maybe a -> Maybe b}를 정의할 수 있어야 합니다. 이것이 우리가 전에 논의했던 이 데이터 타입들의 ``함수자성(functoriality)'' 속성입니다. 함수자성은 임의의 함수를 변형된 타입들 사이의 함수로 \\index{lifting}\\emph{승격(lift)}할 수 있게 해줍니다.","Functoriality can be expressed in Haskell using a \\index{\\hask{class}}\\emph{typeclass}. In this case, the typeclass is parameterized by a type constructor \\hask{f} (in Haskell we use lower case names for type-constructor variables). We say that \\hask{f} is a \\hask{Functor} if there is a corresponding mapping of functions called \\hask{fmap}:":"Functoriality는 \\index{\\hask{class}}\\emph{타입클래스(typeclass)}를 사용하여 Haskell에서 표현될 수 있습니다. 이 경우, 타입클래스는 타입 생성자(type constructor) \\hask{f}에 의해 매개변수화(parameterized) 됩니다 (Haskell에서는 타입 생성자 변수의 이름으로 소문자를 사용합니다). 우리는 \\hask{f}가 \\hask{Functor}라고 말합니다, 만약 \\hask{f}에 해당하는 함수 매핑(mappings of functions)인 \\hask{fmap}이 있다면:","The compiler knows that \\hask{f} is a type constructor because it's applied to types, as in \\hask{f a} and \\hask{f b}.":"컴파일러는 \\hask{f}가 타입 생성자(type constructor)임을 알고 있습니다. 왜냐하면 이것이 타입들에 적용되기 때문입니다. 예를 들어 \\hask{f a}와 \\hask{f b}에서처럼 말입니다.","To prove to the compiler that a particular type constructor is a \\hask{Functor}, we have to provide the implementation of \\hask{fmap} for it. This is done by defining an \\index{\\hask{instance}}\\emph{instance} of the typeclass \\hask{Functor}. For example:":"특정 타입 생성자가 \\hask{Functor}임을 컴파일러에 증명하기 위해 우리는 해당 생성자에 대한 \\hask{fmap}의 구현을 제공해야 합니다. 이는 \\index{\\hask{instance}}\\emph{인스턴스(instance)}를 타입클래스(typeclass) \\hask{Functor}의 인스턴스로 정의함으로써 이루어집니다. 예를 들어:","A functor must also satisfy some laws: it must preserve composition and identity. These laws cannot be expressed in Haskell, but should be checked by the programmer. We have previously seen a definition of \\hask{badMap} that didn't satisfy the identity laws, yet it would be accepted by the compiler. It would define an ``unlawful'' instance of \\hask{Functor} for the list type constructor \\hask{[]}.":"함자(Functor)는 몇 가지 법칙을 만족해야 합니다: 함자는 합성과 항등을 보존해야 합니다. 이러한 법칙들은 Haskell에 표현될 수 없지만, 프로그래머에 의해 확인되어야 합니다. 우리는 이전에 항등 법칙을 만족하지 않지만 컴파일러에 의해 받아들여질 수 있는 \\hask{badMap}의 정의를 보았습니다. 이는 리스트 타입 생성자 \\hask{[]}에 대한 ``불법적인'' \\hask{Functor} 인스턴스를 정의할 것입니다.","There are some elementary functors that might seem trivial, but they serve as building blocks for other functors.":"어떤 초등 함자들(functors)이 있는데, 이것들은 사소해 보일 수 있지만 다른 함자들의 구성 요소로서 역할을 합니다.","We have the identity endofunctor that maps all objects to themselves, and all arrows to themselves.":"우리는 모든 객체를 자기 자신에게, 그리고 모든 화살을 자기 자신에게 매핑하는 항등 종함자(identity endofunctor)를 가지고 있읍니다.","We also have a constant functor $\\Delta_c$ that maps all objects to a single object $c$, and all arrows to the identity arrow on this object. In Haskell, it's a family of functors parameterized by the target object \\hask{c}:":"우리는 또한 모든 객체를 단일 객체 $c$로 매핑하고, 모든 화살표를 이 객체에 대한 항등 화살표로 매핑하는 상수 함자 $\\Delta_c$를 가지고 있습니\n다. Haskell에서는, 이는 대상 객체 \\hask{c}에 의해 매개변수화된 함자들의 모음입니다:","This type constructor ignores its second argument.":"이 타입 생성자는 두 번째 인수를 무시합니다.","\\subsection{Bifunctors}":"\\subsection{이항자(Bifunctors)}","We have also seen data constructors that take two types as arguments: the product and the sum. They were functorial as well, but instead of lifting a single function, they lifted a pair of functions. In category theory, we would define these as functors from the product category $\\mathcal{C} \\times \\mathcal{C}$ to $\\mathcal{C}$.":"우리 또한 두 타입을 인자로 받는 데이터 생성자를 보았습니다: 곱(product)과 합(sum)입니다. 이것들은 역시 함수자적(functorial)인 특성을 지니고 있었지만, 단일 함수를 올리는 대신 함수 쌍을 올렸습니다. 범주 이론(category theory)에서는, 이를 곱 범주(product category) $\\mathcal{C} \\times \\mathcal{C}$ 에서 $\\mathcal{C}$로 가는 함수자(functors)로 정의합니다.","Such functors map a pair of objects to an object, and a pair of arrows to an arrow.":"이러한 함자(functors)는 객체의 쌍을 객체에 대응시키고, 화살표(arrows)의 쌍을 화살표에 대응시킵니다.","In Haskell, we treat such functors as members of a separate class called \\hask{Bifunctor}.":"Haskell에서는 이러한 펑터(functor)들을 \\hask{Bifunctor}라는 별도의 클래스의 멤버로 취급합니다.","Again, the compiler deduces that \\hask{f} is a two-argument type constructor because it sees it applied to two types, e.g., \\hask{f a b}.":"다시 한 번, 컴파일러는 \\hask{f}가 두 개의 인자를 가지는 타입 생성자(type constructor)라는 것을 추론합니다. 왜냐하면 그것이 두 개의 타입에 적용되는 것을 보기 때문입니다, 예를 들어 \\hask{f a b}.","To prove to the compiler that a particular type constructor is a \\hask{Bifunctor}, we define an instance. For example, bifunctoriality of a pair can be defined as:":"컴파일러에게 특정 타입 생성자가 \\hask{Bifunctor}임을 증명하기 위해 인스턴스를 정의합니다. 예를 들어, 쌍(pair)의 이항 함자성(bifunctoriality)은 다음과 같이 정의될 수 있습니다:","\\subsection{Contravariant functors}":"\\subsection{반변 함자(Contravariant functors)}","Functors from the opposite category $\\mathcal{C}^{op}$ are called \\emph{contravariant}. They have the property of lifting arrows that go in the opposite direction. Regular functors are sometimes called \\index{covariant functor}\\emph{covariant}.":"반대 범주 $\\mathcal{C}^{op}$에서 오는 함자들을 \\emph{반변 함수자}(contravariant)라고 합니다. 이들은 반대 방향으로 가는 사상을 들어올리는 특성을 갖고 있습니다. 일반적인 함자들은 때때로 \\index{covariant functor}\\emph{공변 함수자}(covariant)라고 합니다.","In Haskell, contravariant functors form the typeclass \\hask{Contravariant}:":"In Haskell, contravariant functors form the typeclass \\hask{Contravariant}:","It's often convenient to think of functors in terms of producers and consumers. In this picture, a (covariant) functor is a producer. You can turn a producer of \\hask{a}'s to a producer of \\hask{b}'s by applying (using \\hask{fmap}) a function \\hask{a->b}. Conversely, to turn a consumer of \\hask{a}'s to a consumer of \\hask{b}'s you need a function going in the opposite direction, \\hask{b->a}.":"종종 함수자(functor)들을 생산자(producer)와 소비자(consumer)의 측면에서 생각하는 것이 편리합니다. 이 관점에서, (공변) 함수자(covariant functor)는 생산자입니다. \\hask{fmap}을 사용하여 \\hask{a->b} 함수를 적용함으로써 \\hask{a}의 생산자를 \\hask{b}의 생산자로 바꿀 수 있습니다. 반대로, \\hask{a}의 소비자를 \\hask{b}의 소비자로 바꾸기 위해서는 반대 방향으로 가는 함수, 즉 \\hask{b->a}가 필요합니다.","Example: A predicate is a function returning \\hask{True} or \\hask{False}:":"예제: 술어(predicate)는 \\hask{True} 또는 \\hask{False}를 반환하는 함수입니다.","It's easy to see that it's a contravariant functor:":"이것이 반변함자(contravariant functor)라는 것을 쉽게 알 수 있습니니다:","The only non-trivial examples of contravariant functors are variations on the theme of function objects.":"유일한 비자명(非自明, non-trivial) 준공변 함자(contravariant functor)의 예는 함수 객체(function objects) 주제의 변형입니다.","One way to tell if a given function type is covariant or contravariant in one of the type arguments is by assigning polarities to the types used in its definition. We say that the return type of a function is in a \\emph{positive} position, so it's covariant; and the argument type is in the \\emph{negative} position, so it's contravariant. But if you put the whole function object in the negative position of another function, then its polarities get reversed.":"한 가지 방법으로 주어진 함수 타입이 타입 인자 중 하나에서 공변(covariant)인지 반공변(contravariant)인지 확인할 수 있습니(다). 타입의 정의에서 사용된 타입들에 극성을 할당함으로써 말입니(다). 함수의 반환 타입이 \\emph{양의} 위치에 있다고 말하는데, 이는 공변(다). 그리고 인자 타입은 \\emph{음의} 위치에 있기 때문에 반공변(다). 그러나 전체 함수 객체를 다른 함수의 음의 위치에 놓으면, 그 극성은 반전됩니(다).","Consider this data type:":"다음 데이터 타입을 고려하십시오:","It has \\hask{a} in a double-negative, therefore a positive position. This is why it's a covariant \\hask{Functor}. It's a producer of \\hask{a}'s:":"이것은 이중 부정(double-negative) 속에서 \\hask{a}를 가지고 있으므로, 긍정적 위치에 있습니다. 이것이 바로 공변(covariant) \\hask{펑터(Functor)}인 이유입니다. 이것은 \\hask{a}'s를 만들어내는 것입니다:","Notice that parentheses are important here. A similar function \\hask{a -> Bool -> Bool} has \\hask{a} in a \\emph{negative} position. That's because it's a function of \\hask{a} returning a function \\hask{(Bool -> Bool)}. Equivalently, you may uncurry it to get a function that takes a pair: \\hask{(a, Bool) -> Bool}. Either way, \\hask{a} ends up in the negative position.":"여기서 괄호가 중요함을 주목하십시오. 유사한 함수 \\hask{a -> Bool -> Bool}는 \\hask{a}를 \\emph{negative} 위치에 두었습니다. 이는 \\hask{a}의 함수가 \\hask{(Bool -> Bool)}의 함수를 반환하기 때문입니다. 동등하게, 이를 언커리(uncurry)하여 쌍을 받는 함수: \\hask{(a, Bool) -> Bool}로 만들 수 있습니다. 어느 쪽이든, \\hask{a}는 결국 negative 위치에 있습니다.","\\subsection{Profunctors}":"\\subsection{Profunctors}\n\\subsection{프로펑터들(Profunctors)}","We've seen before that the function type is functorial. It lifts two functions at a time, just like \\hask{Bifunctor}, except that one of the functions goes in the opposite direction.":"우리는 함수 유형이 함수자적(functorial)이라는 것을 이전에 보았습니다. 이는 \\hask{Bifunctor}처럼 한 번에 두 개의 함수를 올리지만, 그 중 하나의 함수는 반대 방향으로 갑니다.","In category theory this corresponds to a functor from a product of two categories, one of them being the opposite category: it's a functor from $\\mathcal{C}^{op} \\times \\mathcal{C}$. Functors from $\\mathcal{C}^{op} \\times \\mathcal{C}$ to $\\mathbf{Set}$ are called \\emph{profunctors}.":"범주 이론(category theory)에서는 이는 두 개의 범주의 곱(product)에서 하나가 반대 범주(opposite category)인 함자(functor)에 해당합니다: 이는 $\\mathcal{C}^{op} \\times \\mathcal{C}$에서의 함자입니다. $\\mathcal{C}^{op} \\times \\mathcal{C}$에서 $\\mathbf{Set}$로 가는 함자를 \\emph{프로펑터(profunctors)}라고 부릅니다.","In Haskell, profunctors form a typeclass:":"Haskell에서, 프로펑터(profunctors)는 타입클래스(typeclass)를 형성합니다:","You can think of a profunctor as a type that's simultaneously a producer and a consumer. It consumes one type and produces another.":"프로펀터(profunctor)를 동시에 생산자(producer)와 소비자(consumer)인 타입(type)으로 생각할 수 있습니다. 이는 하나의 타입을 소비하고 다른 타입을 생산합니다.","The function type, which can be written as an infix operator \\hask{(->)}, is an instance of \\hask{Profunctor}":"함수 타입은, 중위 연산자 \\hask{(->)}로 쓸 수 있는데, 이는 \\hask{Profunctor}의 인스턴스입니다.","This is in accordance with our intuition that a function \\hask{a->b} consumes arguments of the type \\hask{a} and produces results of the type \\hask{b}.":"이는 함수 \\hask{a->b}가 \\hask{a} 타입의 인수를 받아들이고 \\hask{b} 타입의 결과를 생성한다는 우리의 직관과 일치합니다.","In programming, all non-trivial profunctors are variations on the function type.":"프로그래밍에서 모든 비트리비얼(non-trivial) 프로펑터(profunctors)는 함수 타입의 변형입니다.","\\section{The Hom-Functor}":"\\section{Hom-함수자(Hom-Functor)}","Arrows between any two objects form a set. This set is called a hom-set and is usually written using the name of the category followed by the names of the objects:":"어떤 두 객체 간의 화살표들은 하나의 집합을 이룹니다. 이 집합을 hom-집합(hom-set)이라고 부르며, 보통 범주의 이름과 객체들의 이름을 사용하여 작성합니다:","We can interpret the hom-set $\\mathcal{C}(a, b)$ as all the ways $b$ can be observed from $a$.":"우리는 hom-집합 $\\mathcal{C}(a, b)$을 $a$로부터 $b$를 관찰할 수 있는 모든 방법으로 해석할 수 있습니 다.","Another way of looking at hom-sets is to say that they define a mapping that assigns a set $\\mathcal{C}(a, b)$ to every pair of objects. Sets themselves are objects in the category $\\mathbf{Set}$. So we have a mapping between categories.":"또 다른 방법으로 hom-sets(사상 집합)을 바라보면 그것들이 객체의 모든 쌍에게 집합 $\\mathcal{C}(a, b)$를 할당하는 사상을 정의한다고 말할 수 있습니니다. 집합들 자체는 범주 $\\mathbf{Set}$ 내의 객체들입니다. 따라서 우리는 범주들 사이의 사상을 가집니다.","This mapping is functorial. To see that, let's consider what happens when we transform the two objects $a$ and $b$. We are interested in a transformation that would map the set $\\mathcal{C}(a, b)$ to the set $\\mathcal{C}(a', b')$. Arrows in $\\mathbf{Set}$ are regular functions, so it's enough to define their action on individual elements of a set.":"이 사상(mapping)은 함자적(functorial)입니다. 이를 확인하기 위해 두 객체(object) $a$와 $b$를 변환할 때 일어나는 일을 고려해 봅시다. 우리는 집합 $\\mathcal{C}(a, b)$를 집합 $\\mathcal{C}(a', b')$로 사상하는 변환에 관심이 있습니다. $\\mathbf{Set}$의 화살표(arrows)는 일반적인 함수이므로, 집합의 개별 요소들에 대한 그들의 작용(action)을 정의하는 것으로 충분합니다.","An element of $\\mathcal{C}(a, b)$ is an arrow $h \\colon a \\to b$ and an element of $\\mathcal{C}(a', b')$ is an arrow $h' \\colon a' \\to b'$. We know how to transform one into another: we need to pre-compose $h$ with an arrow $g' \\colon a' \\to a$ and post-compose it with an arrow $g \\colon b \\to b'$.":"$\\mathcal{C}(a, b)$의 원소는 $a \\to b$의 화살표 $h$이며 $\\mathcal{C}(a', b')$의 원소는 $a' \\to b'$의 화살표 $h'$입니다. 우리는 하나를 다른 것으로 변환하는 방법을 알고 있습니다: $h$를 $a' \\to a$의 화살표 $g'$로 사전 합성(pre-compose)하고 $b \\to b'$의 화살표 $g$로 사후 합성(post-compose)해야 합니다.","In other words, the mapping that takes a pair $\\langle a, b \\rangle$ to the set $\\mathcal{C}(a, b)$ is a \\emph{profunctor}:":"즉, 쌍 $\\langle a, b \\rangle$를 집합 $\\mathcal{C}(a, b)$로 매핑(mapping)하는 것은 \\emph{프로펀터(profunctor)}입니다:","Frequently, we are interested in varying only one of the objects, keeping the other fixed. When we fix the source object and vary the target, the result is a functor  that is written as:":"자주 우리는 한 개체만을 변경하면서 다른 하나는 고정시키는 것에 관심을 가집니다. 소스 객체를 고정시키고 타겟을 변경할 때, 그 결과는 다음과 같이 작성되는 함자(functor)입니다:","The action of this functor on an arrow $g \\colon b \\to b'$ is written as:":"이 함자의 화살표 $g \\colon b \\to b'$에 대한 작용은 다음과 같이 씁니다:","and is given by post-composition:":"그리고 이는 후합성과( post-composition )에 의해 제공됩니다:","Varying $b$ means switching focus from one object to another, so the complete functor $\\mathcal{C}(a, -)$ combines all the arrows emanating from $a$ into a coherent view of the category from the perspective of $a$. It is ``the world according to $a$.''":"$b$를 변화시키는 것은 하나의 객체에서 다른 객체로 초점을 전환하는 것을 의미하므로, 완비 함자(complete functor) $\\mathcal{C}(a, -)$는 $a$에서 발생하는 모든 화살표를 $a$의 관점에서 범주를 일관된 시각으로 결합시켜 줍니다. 이는 ``$a$에 따른 세계''입니다.","Conversely, when we fix the target and vary the source of the hom-functor, we get a contravariant functor:":"반대로, 타겟(target)을 고정하고 hom-함자(hom-functor)의 소스(source)를 변화시키면, 우리는 반공변 함자(contravariant functor)를 얻게 됩니다:","whose action on an arrow $g' \\colon a' \\to a$ is written as:":"그 화살표 $g' \\colon a' \\to a$에 대한 작용은 다음과 같이 작성됩니다:","and is given by pre-composition:":"그리고 전치성합성(pre-composition)에 의해 주어집니다:","The functor $\\mathcal{C}(-, b)$ organizes all the arrows pointing at $b$ into one coherent view. It is the picture of $b$ ``as it's seen by the world.''":"함자(Functor) $\\mathcal{C}(-, b)$는 $b$를 향하는 모든 화살표를 하나의 일관된 관점으로 조직합니다. 이는 $b$가 ``세상으로부터 보는 모습''입니다.","We can now reformulate the results from the chapter on isomorphisms. If two objects $a$ and $b$ are isomorphic, than their hom-sets are also isomorphic. In particular:":"이제 동형사상(이소몰피즘)에 관한 챕터의 결과를 재구성할 수 있습니 다. 두 객체 $a$와 $b$가 동형사상이라면 그들의 hom-집합 또한 동형사상 입니다. 특히:","and":"content:그리고","We'll discuss naturality conditions in the next chapter.":"다음 장에서 자연성 조건(naturality conditions)에 대해 논의할 것입니다.","Another way of looking at the hom-functor $\\cat C(a, -)$ is as an oracle that  provides answers to the question: ``Is $a$ connected to me?'' If the set $\\cat C(a, x)$ is empty, the answer is negative: ``$a$ is not connected to $x$.'' Otherwise, every element of the set $\\cat C(a, x)$ is a proof that such connection exists.":"다르게 hom-함수자(Hom-Functor) $\\cat C(a, -)$를 보는 방법은 ``$a$는 나와 연결이 되어 있는가?'' 라는 질문에 답을 제공하는 오라클로서 보는 것입니다. 만약 집합 $\\cat C(a, x)$가 비어 있다면, 답은 부정적입니다: ``$a$는 $x$와 연결되어 있지 않습니다.'' 그렇지 않다면, 집합 $\\cat C(a, x)$의 모든 요소는 그러한 연결이 존재한다는 증거입니다.","Conversely, the contravariant functor $\\cat C (-, a)$ answers the question: ``Am I connected to $a$?''":"반대로, 반변 함수자 $\\cat C (-, a)$는 질문에 답합니다: ``나는 $a$와 연결되어 있습니까?''","Taken together, the profunctor $\\cat C(x, y)$ establishes a \\index{proof-relevant relation}\\emph{proof-relevant} relation between objects. Every element of the set $\\cat C(x, y)$ is a proof that $x$ is connected to $y$. If the set is empty, the two objects are unrelated.":"종합하면, 함자 범주(profunctor) $\\cat C(x, y)$는 객체들 사이에 \\index{증명-관련 관계}\\emph{증명-관련}(proof-relevant) 관계를 설정합니다. 집합 $\\cat C(x, y)$의 모든 요소는 $x$가 $y$와 연결되어 있다는 증거입니다. 만약 집합이 비어 있다면, 두 객체는 관계가 없습니다.","\\section{Functor Composition}":"\\section{함자 합성(Functor Composition)}","Just like we can compose functions, we can compose functors. Two functors are composable if the target category of one is the source category of the other.":"함수들을 합성할 수 있는 것처럼, 함자(functor)들도 합성할 수 있습니 다. 두 함자(functor)는 하나의 목표 범주(target category)가 다른 하나의 원천 범주(source category)와 동일할 때 합성 가능합니 다.","On objects, functor composition of $G$ after $F$ first applies $F$ to an object, then applies $G$ to the result; and similarly on arrows.":"대상에 대해서, $F$ 이후 $G$의 함자 합성은 먼저 $F$를 대상에 적용하고, 그 결과에 $G$를 적용합니다; 화살표에 대해서도 마찬가지입니다.","Obviously, you can only compose composable functors. However all \\emph{endofunctors} are composable, since their target category is the same as the source category.":"당연히, 합성할 수 있는 함자(functors)만 합성할 수 있습니 다. 그러나 모든 \\emph{종함자}(endofunctors)는 합성 가능합 니다, 왜냐하면 그들의 도착 범주(target category)가 출발 범주(source category)와 동일하기 때문입니다.","In Haskell, a functor is a parameterized data type, so the composition of two functors is again a parameterized data type. On objects, we define:":"하스켈(Haskell)에서는 펑터(functor)가 매개 변수가 있는 데이터 타입(datatype)입니다. 그래서 두 펑터의 합성(composition)은 다시 매개 변수가 있는 데이터 타입입니다. 객체(objects)에서는 다음과 같이 정의합니다:","The compiler figures out that \\hask{f} and \\hask{g} must be type constructors because they are applied to types: \\hask{f} is applied to the type parameter \\hask{a}, and \\hask{g} is applied to the resulting type.":"컴파일러는 \\hask{f}와 \\hask{g}가 타입 생성자(type constructors)여야 한다는 것을 알아냅니다. \\hask{f}는 타입 매개변수(type parameter) \\hask{a}에 적용되고, \\hask{g}는 그 결과 타입에 적용됩니다.","Alternatively, you can tell the compiler that the first two arguments to \\hask{Compose} are type constructors. You do this by providing a \\index{kind signatures}\\emph{kind signature}, which requires a language extension \\hask{KindSignatures} that you put at the top of the source file:":"Alternatively, you can tell the compiler that the first two arguments to \\hask{Compose} are type constructors. You do this by providing a \\index{kind signatures}\\emph{kind signature}(종류 서명), which requires a language extension \\hask{KindSignatures}(종류 서명들) that you put at the top of the source file:","You should also import the \\hask{Data.Kind} library that defines \\hask{Type}:":"\\hask{Type}을 정의하는 \\hask{Data.Kind} 라이브러리도 임포트해야 합니다:","A kind signature is just like a type signature, except that it can be used to describe functions operating on types.":"A kind 서명(signature)은 단지 타입 서명(signature)과 같으며, 타입에 작용하는 함수들을 설명하는 데 사용할 수 있습니다.","Regular types have the kind \\hask{Type}. Type constructors have the kind \\hask{Type -> Type}, since they map types to types.":"정규 타입들은 \\hask{타입(Type)} 종류(kind)를 가집니다. 타입 생성자(type constructors)는 \\hask{타입 -> 타입(Type -> Type)} 종류(kind)를 가지는데, 이는 그들이 타입들을 타입들로 매핑하기 때문입니다.","\\hask{Compose} takes two type constructors and produces a type constructor, so its kind signature is:":"\\hask{Compose}는 두 타입 생성자(type constructors)를 받아 하나의 타입 생성자를 생성하므로, 이는 다음과 같은 형태 서명을 가집니다:","and the full definition is:":"그리고 전체 정의는:","Any two type constructors can be composed this way. There is no requirement, at this point, that they be functors.":"어떠한 두 가지 타입 생성자(type constructors)도 이러한 방식으로 합성할 수 있습니다. 이때 그들이 함자(functors)일 필요는 없습니다.","However, if we want to lift a function using the composition of type constructors, \\hask{g} after \\hask{f}, then they must be functors. This requirement is encoded as a constraint in the instance declaration:":"그러나, 타입 생성자(type constructors)의 합성을 사용하여 함수를 올리려면, \\hask{f} 이후 \\hask{g}가, 이들은 반드시 함자(functors)여야 합니다. 이 요구 사항은 인스턴스 선언(instance declaration)에서 제약으로 인코딩됩니다:","The constraint \\hask{(Functor g, Functor f)} expresses the condition that both type constructors be instances of the \\hask{Functor} class. The constraints are followed by a double arrow.":"제약 조건 \\hask{(Functor g, Functor f)} 는 두 타입 생성자가 \\hask{Functor} 클래스의 인스턴스임을 나타냅니다. 제약 조건 뒤에는 이중 화살표가 옵니다.","The type constructor whose functoriality we are establishing is \\hask{Compose f g}, which is a partial application of \\hask{Compose} to two functors.":"형식 생성자(타입 생성자) 중에서 우리가 함자성(functoriality)을 확립하고 있는 것은 \\hask{Compose f g}이며, 이는 두 함자(functor)에 대한 \\hask{Compose}의 부분 적용(partial application)입니다.","In the implementation of \\hask{fmap}, we pattern match on the data constructor \\hask{Compose}. Its argument \\hask{gfa} is of the type \\hask{g (f a)}. We use one \\hask{fmap} to ``get under'' \\hask{g}. Then we use \\hask{(fmap h)} to get under \\hask{f}. The compiler knows which \\hask{fmap} to use by analyzing the types.":"\\hask{fmap}의 구현에서, 데이터 생성자 \\hask{Compose}에 대해 패턴 매칭을 수행합니다. 그 인수 \\hask{gfa}는 \\hask{g (f a)} 타입입니다. 우리는 \\hask{fmap} 하나를 사용하여 \\hask{g} \"아래로 들어갑니다\". 그런 다음 \\hask{(fmap h)}를 사용하여 \\hask{f} 아래로 들어갑니다. 컴파일러는 타입을 분석하여 어떤 \\hask{fmap}을 사용할지 결정합니다.","You may visualize a composite functor as a container of containers. For instance, the composition of \\hask{[]} with \\hask{Maybe} is a list of optional values.":"복합 함자를 용기의 용기로 시각화할 수 있습니다. 예를 들어, \\hask{[]}와 \\hask{Maybe}의 조합은 선택적 값들의 리스트입니다.","\\subsection{Category of categories}":"\\subsection{카테고리들의 카테고리(Category of categories)}","We can view functors as arrows between categories. As we've just seen, functors are composable and it's easy to check that this composition is associative. We also have an identity (endo-) functor for every category. So categories themselves seem to form a category, let's call it $\\mathbf{Cat}$.":"함수자(functor)들을 범주들 사이의 화살표로 볼 수 있습나다. 우리가 방금 본 것처럼, 함수자들은 합성 가능하며 이 합성이 결합법칙을 만족하는지 확인하기 쉽습니다. 또한 모든 범주마다 항등(자기-) 함수자(identity (endo-) functor)가 있습니다. 따라서 범주들 자체가 하나의 범주를 형성하는 것처럼 보이며, 이를 $\\mathbf{Cat}$이라고 부르겠습니다.","And this is where mathematicians start worrying about ``size'' issues. It's a shorthand for saying that there are paradoxes lurking around. So the correct incantation is that $\\mathbf{Cat}$ is a category of \\emph{small} categories. But as long as we are not engaged in proofs of existence, we can ignore size problems.":"And this is where mathematicians start worrying about ``size'' issues. It's a shorthand for saying that there are paradoxes lurking around. So the correct incantation is that $\\mathbf{Cat}$ is a category of \\emph{small} categories. But as long as we are not engaged in proofs of existence, we can ignore size problems.\n그리고 여기서 수학자들은 ``크기'' 문제에 대해 걱정하기 시작합니다. 이것은 역설이 숨어 있다는 것을 말하는 약칭입니다. 그래서 올바른 표현은 $\\mathbf{Cat}$이 \\emph{작은} 범주의 범주라는 것입니다. 그러나 우리가 존재 증명에 관여하지 않는 한, 크기 문제를 무시할 수 있습니다.","\\end{document}":"\\end{document}"}