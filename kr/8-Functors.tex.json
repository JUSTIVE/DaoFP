{
	"\\chapter{Functors}": "\\chapter{펑터(Functors)}",
	"\\section{Categories}": "\\section{카테고리}",
	"So far we've only seen one category---that of types and functions. So let's quickly gather the essential info about a category.": "지금까지 우리는 하나의 범주 --- 타입과 함수들 --- 만을 보았습니다. 그래서 범주에 관한 필수 정보를 빠르게 모아보겠습니다.",
	"A category is a collection of objects and arrows that go between them. Every pair of composable arrows can be composed. The composition is associative, and there is an identity arrow looping back on every object.": "카테고리란 객체와 그들 사이를 연결하는 화살표들로 구성된 집합입니다. 모든 짝의 결합 가능한 화살표들은 결합될 수 있습니다. 결합은 결합 법칙(associative)을 따르며, 각 객체에는 그 객체로 돌아오는 항등 화살표(identity arrow)가 있습니다.",
	"The fact that types and functions form a category can be expressed in Haskell by defining composition as:": "타입과 함수가 카테고리를 형성한다는 사실은 다음과 같이 합성(composition)을 정의함으로써 Haskell에서 표현될 수 있습니다:",
	"The composition of two functions \\hask{g} after \\hask{f} is a new function that first applies \\hask{f} to its argument and then applies \\hask{g} to the result.": "두 함수 \\hask{f} 뒤에 \\hask{g}를 합성한 것은 먼저 \\hask{f}를 그 인수에 적용한 다음, \\hask{g}를 그 결과에 적용하는 새로운 함수입니다.",
	"The identity is a polymorphic ``do nothing'' function:": "정체성(Identity)은 다형(polymorphic)적인 ``아무 것도 하지 않는'' 함수(function)입니다:",
	"You can easily convince yourself that such composition is associative, and composing with \\hask{id} does nothing to a function.": "여러분은 이러한 합성이 결합법칙(associative)을 만족하며, \\hask{id}와 합성하는 것은 함수에 아무런 영향을 미치지 않는다는 것을 쉽게 확인할 수 있습니다.",
	"Based on the definition of a category, we can come up with all kinds of weird categories. For instance, there is a category that has no objects and no arrows. It satisfies all the condition of a category vacuously. There's another that contains a single object and a single arrow (can you guess what arrow it is?). There's one with two unconnected objects, and one where the two objects are connected by a single arrow (plus two identity arrows), and so on. These are example of what I call \\index{stick-figure category}stick-figure categories---categories with a small handful of objects and arrows.": "카테고리(category)의 정의를 바탕으로, 우리는 온갖 종류의 이상한 카테고리를 생각해낼 수 있습니 다. 예를 들어, 객체(object)와 화살표(arrow)가 없는 카테고리가 있습니다. 이는 모든 카테고리의 조건을 자명하게 만족합니다. 또 다른 예로, 단일 객체와 단일 화살표를 가진 카테고리도 있습니다 (어떤 화살표일지 짐작할 수 있습니까?). 두 개의 연결되지 않은 객체를 가진 카테고리도 있으며, 두 객체가 단일 화살표로 연결된 카테고리(그리고 두 개의 항등 화살표(identity arrow)도 포함됩니다)가 있습니다. 이들은 제가 \\index{stick-figure category}막대 그림 카테고리(stick-figure category)라 부르는 것의 예입니다---작은 수의 객체와 화살표를 가진 카테고리들입니다.",
	"\\subsection{Category of sets}": "\\subsection{집합의 범주(Category of sets)}",
	"We can also strip a category of all arrows (except for the identity arrows). Such a bare-object category is called a \\index{discrete category}\\emph{discrete} category or a set\\footnote{Ignoring ``size'' issues.}. Since we associate arrows with structure, a set is a category with no structure.": "우리는 또한 모든 화살을 (항등 화살을 제외하고) 제거할 수 있습니니다. 이러한 단순 객체 범주(bare-object category)를 \\index{discrete category}\\emph{이산(discrete)} 범주(discrete category) 또는 집합이라고 합니니다\\footnote{``크기'' 문제를 무시하고}. 화살을 구조(structure)와 연관시키기 때문에, 집합은 구조가 없는 범주입니니다.",
	"Sets form their own category called $\\mathbf{Set}$\\footnote{Again, ignoring ``size'' issues, in particular the non-existence of the set of all sets.}. The objects in that category are sets, and the arrows are functions between sets. Such functions are defined as special kind of relations, which themselves are defined as sets of pairs.": "집합들은 자신들만의 범주(영문 용어: category)를 형성하며, 이를 $\\mathbf{Set}$이라 부릅니다\\footnote{다시 말해, \"크기\" 문제(특히 모든 집합들의 집합의 비존재)를 무시합니다.}. 그 범주의 대상(영문 용어: objects)들은 집합들이고, 화살표(영문 용어: arrows)는 집합들 사이의 함수들입니다. 이러한 함수들은 특별한 종류의 관계로 정의되며, 그 관계들은 쌍들의 집합으로 정의됩니다.",
	"To the lowest approximation, we can model programming in the category of sets. We often think of types as sets of values, and functions as set-theoretical functions. There's nothing wrong with that. In fact all of categorical construction we've described so far have their set-theoretical roots. The categorical product is a generalization of the cartesian product of sets, the sum is the disjoint union, and so on.": "최소 근사치로, 우리는 집합(category of sets) 범주에서 프로그래밍을 모델링할 수 있습니. 우리는 종종 타입을 값들의 집합(set)으로 생각하고, 함수를 집합-이론적 함수(set-theoretical functions)로 생각합니다. 이는 아무런 문제가 없습니다. 사실 지금까지 묘사한 모든 범주론적 구성은 그들의 집합-이론적 뿌리를 가지고 있습니다. 범주론적 곱(product)은 집합의 데카르트 곱(cartesian product)의 일반화이며, 합(sum)은 분리합(disjoint union)이고, 그 외 등등이 있습니다.",
	"What category theory offers is more precision: the fine distinction between the structure that is absolutely necessary, and the superfluous details.": "범주 이론이 제공하는 것은 더 정확해진다는 점입니다: 반드시 필요한 구조와 불필요한 세부 사항 사이의 미세한 구분을 제공합니다.",
	"A set-theoretical function, for instance, doesn't fit the definition of a function we work with as programmers. Our functions must have underlying algorithms because they have to be computable by some physical systems, be it computers or a human brains.": "집합이론적 함수(set-theoretical function)는 예를 들어, 우리가 프로그래머로서 작업하는 함수의 정의에 맞지 않습니 다. 우리의 함수는 어떤 물리적 시스템에 의해 컴퓨팅될 수 있어야 하기 때문에 기본적인 알고리즘을 가져야 합니 다. 컴퓨터든 인간의 뇌든 상관없이 말입니다.",
	"\\subsection{Opposite categories}": "\\subsection{반대 범주(Opposite categories)}",
	"In programming, the focus is on the category of types and functions, but we can use this category as a starting point to construct other categories.": "프로그래밍에서는 유형(타입)과 함수의 범주에 중점을 둡니다 (category of types and functions), 그러나 이 범주를 출발점으로 사용하여 다른 범주들을 구성할 수 있습니니다.",
	"One such category is called the \\emph{opposite} category. This is the category in which all the original arrows are inverted: what is called the source of an arrow in the original category is now called its target, and vice versa.": "하나의 그러한 범주는 \\emph{역} 범주(opposite category)라고 불립니다. 이 범주에서 모든 원래 화살표(arrows)들이 뒤집혀집니다: 원래 범주에서 화살표의 출발지(source)라고 불리던 것이 이제는 그 목표지(target)로 불리며, 그 반대도 마찬가지입니다.",
	"The opposite of a category $\\mathcal{C}$ is called $\\mathcal{C}^{op}$. We've had a glimpse of this category when we discussed duality. The objects of $\\mathcal{C}^{op}$ are the same as those of $\\mathcal{C}$.": "카테고리 $\\mathcal{C}$의 반대(대칭) 카테고리(opposite category)를 $\\mathcal{C}^{op}$이라 합니다. 우리는 이 카테고리에 대해 이중성(duality)을 논할 때 잠깐 다뤘습니다. $\\mathcal{C}^{op}$의 객체(objects)는 $\\mathcal{C}$의 객체들과 동일합니다.",
	"Whenever there is an arrow $f \\colon a \\to b$ in $\\mathcal{C}$, there is a corresponding arrow $f^{op} \\colon b \\to a$ in $\\mathcal{C}^{op}$.": "$\\mathcal{C}$에서 $f \\colon a \\to b$라는 화살표가 있을 때, $\\mathcal{C}^{op}$에서는 그에 대응하는 화살표 $f^{op} \\colon b \\to a$가 있습니다.",
	"The composition $g^{op} \\circ f^{op}$ of two such arrows $f^{op} \\colon a \\to b$ and $g^{op} \\colon b \\to c$ is given by the arrow $f \\circ g$ (notice the reversed order).": "두 화살표 $f^{op} \\colon a \\to b$ 와 $g^{op} \\colon b \\to c$의 합성 $g^{op} \\circ f^{op}$은 화살표 $f \\circ g$에 의해 주어집니다 (순서가 반대로 된 것을 주목하세요).",
	"The terminal object in  $\\mathcal{C}$ is the initial object in $\\mathcal{C}^{op}$, the product in  $\\mathcal{C}$ is the sum in $\\mathcal{C}^{op}$, and so on.": "$\\mathcal{C}$의 종말 대상(terminal object)은 $\\mathcal{C}^{op}$의 시작 대상(initial object)이며, $\\mathcal{C}$의 곱(product)은 $\\mathcal{C}^{op}$의 합(sum)과 같고, 그 외에도 그렇습니다.",
	"\\subsection{Product categories}": "\\subsection{곱 카테고리들(Product categories)}",
	"Given two categories $\\mathcal{C}$ and $\\mathcal{D}$, we can construct a product category $\\mathcal{C} \\times \\mathcal{D}$. The objects in this category are pairs of objects $\\langle c, d \\rangle $, and the arrows are pairs of arrows.": "두 범주 $\\mathcal{C}$와 $\\mathcal{D}$가 주어지면, 우리는 곱 범주 $\\mathcal{C} \\times \\mathcal{D}$를 구성할 수 있습니다. 이 범주의 대상들은 대상들의 쌍 $\\langle c, d \\rangle $이며, 화살표들은 화살표들의 쌍입니다.",
	"If we have an arrow $f \\colon c \\to c'$ in $\\mathcal{C}$ and an arrow $g \\colon d \\to d'$ in $\\mathcal{D}$ then there is a corresponding arrow $\\langle f, g \\rangle$ in $\\mathcal{C} \\times \\mathcal{D}$.  This arrow goes from $\\langle c, d \\rangle $ to $\\langle c', d' \\rangle $, both being objects in $\\mathcal{C} \\times \\mathcal{D}$. Two such arrows can be composed if their components are composable in, respectively, $\\mathcal{C}$ and $\\mathcal{D}$. An identity arrow is a pair of identity arrows.": "만약 $\\mathcal{C}$에서의 사상(arrow) $f \\colon c \\to c'$와 $\\mathcal{D}$에서의 사상 $g \\colon d \\to d'$가 주어지면 $\\mathcal{C} \\times \\mathcal{D}$에서는 이들에 대응하는 사상 $\\langle f, g \\rangle$이 있습니니다. 이 사상은 $\\mathcal{C} \\times \\mathcal{D}$의 객체 $\\langle c, d \\rangle $에서 $\\langle c', d' \\rangle $로 갑니다. 이러한 두 사상은 각각 $\\mathcal{C}$와 $\\mathcal{D}$에서 그 성분들이 결합(composable)될 경우 합성(composed)될 수 있습니다. 항등 사상(identity arrow)은 항등 사상들의 쌍입니다.",
	"The two product categories we're most interested in are $\\mathcal{C} \\times \\mathcal{C}$ and $\\mathcal{C}^{op} \\times \\mathcal{C}$, where $\\mathcal{C}$ is our familiar category of types and functions.": "우리가 가장 관심있는 두 가지 곱(product) 범주(categories)는 $\\mathcal{C} \\times \\mathcal{C}$와 $\\mathcal{C}^{op} \\times \\mathcal{C}$입니다. 여기서 $\\mathcal{C}$는 우리가 익숙한 타입과 함수의 범주(category)입니다.",
	"In both of these categories, objects are pairs of objects from $\\mathcal{C}$. In the first category, $\\mathcal{C} \\times \\mathcal{C}$, a morphism from $\\langle a, b \\rangle $ to $\\langle a', b' \\rangle $ is a pair $\\langle f \\colon a \\to a', g \\colon b \\to b' \\rangle $. In the second category, $\\mathcal{C}^{op} \\times \\mathcal{C}$, a morphism is a pair $\\langle f \\colon a' \\to a, g \\colon b \\to b' \\rangle $, in which the first arrow goes in the opposite direction.": "이 두 범주(카테고리)의 경우, 객체는 $\\mathcal{C}$에서 온 객체들의 쌍입니다. 첫 번째 범주인 $\\mathcal{C} \\times \\mathcal{C}$에서는 $\\langle a, b \\rangle $에서 $\\langle a', b' \\rangle $로 가는 사상(모르피즘, morphism)은 $\\langle f \\colon a \\to a', g \\colon b \\to b' \\rangle $이라는 쌍입니다. 두 번째 범주인 $\\mathcal{C}^{op} \\times \\mathcal{C}$에서는 사상(모르피즘, morphism)은 $\\langle f \\colon a' \\to a, g \\colon b \\to b' \\rangle $이라는 쌍입니다. 여기서 첫 번째 화살표(arrow)는 반대 방향으로 갑니다.",
	"\\subsection{Slice categories}": "\\subsection{슬라이스 카테고리(Slice categories)}",
	"In a neatly organized universe, objects are always objects and arrows are always arrows. Except that sometimes sets of arrows can be thought of as objects. But slice categories break this neat separation: they turn individual arrows into objects.": "잘 정돈된 우주에서는, 객체는 항상 객체이고 화살표는 항상 화살표입니다. \n하지만 때때로 화살표의 집합을 객체로 생각할 수 있습니다. \n그러나 분할 범주(slice categories)는 이 깔끔한 구분을 깨뜨립니다: \n그들은 개별 화살표를 객체로 바꿉니다.",
	"A slice category $\\cat C/c$ describes how a particular object $c$ is seen from the perspective of its category $\\cat C$. It's the totality of arrows pointing at $c$. But to specify an arrow we need to specify both of its ends. Since one of these ends is fixed to be $c$, we only have to specify the other.": "A slice category $\\cat C/c$는 특정 객체 $c$가 그의 범주 $\\cat C$의 관점에서 어떻게 보이는지를 설명합니다. 이는 $c$를 가리키는 모든 화살들의 총합이다. 그러나 하나의 화살을 명시하기 위해 우리는 그 끝점들 모두를 명시해야 합니다. 이 끝점들 중 하나는 $c$로 고정되어 있기 때문에, 우리는 다른 하나만 명시하면 됩니다.",
	"An object in the  \\index{slice category}\\emph{slice category} $\\mathcal{C}/c$ (also known as an \\index{over category}over-category) is a pair $\\langle e, p \\rangle$, with $p \\colon e \\to c$.": "\\index{쪼개진 범주}\\emph{쪼개진 범주} $\\mathcal{C}/c$ (또는 \\index{오버 범주}오버 범주로도 알려져 있음) 내의 객체는 $p \\colon e \\to c$인 $\\langle e, p \\rangle$의 쌍입니다.",
	"An arrow between two objects $\\langle e, p \\rangle$ and $\\langle e', p' \\rangle$ is an arrow $f \\colon e \\to e'$ of $\\cat C$ which makes the following triangle commute:": "두 객체 $\\langle e, p \\rangle$ 및 $\\langle e', p' \\rangle$ 사이의 화살표는 다음 삼각형이 가환하게 만드는 $\\cat C$의 화살표 $f \\colon e \\to e'$입니다:",
	"\\subsection{Coslice categories}": "\\subsection{코슬라이스 카테고리(Coslice categories)}",
	"There is a dual notion of a \\index{coslice category}coslice category $c / \\mathcal{C}$, also known as an \\index{under-category}under-category. It's a category of arrows emanating from a fixed object $c$. Objects in this category are pairs $\\langle a, i \\colon c \\to a \\rangle$. Morphisms in $c / \\mathcal{C}$ are arrows that make the relevant  triangles commute.": "이중 개념의 \\index{coslice category}코슬라이스 범주 $c / \\mathcal{C}$가 존재합니다. 이는 \\index{under-category}언더-카테고리(under-category)라고도 알려져 있습니다. 이것은 고정된 객체 $c$에서 나오는 화살표들의 범주입니다. 이 범주의 객체들은 $\\langle a, i \\colon c \\to a \\rangle$ 쌍들입니다. $c / \\mathcal{C}$의 사상들은 관련된 삼각형을 가환시키는 화살표들입니다.",
	"In particular, if the category $\\mathcal{C}$ has a terminal object $1$, then the coslice $1 / \\mathcal{C}$ has, as objects, global elements of all the objects of $\\mathcal{C}$.": "특히, 범주(category) $\\mathcal{C}$가 종말 객체(terminal object) $1$을 가진다면, 코슬라이스(coslice) $1 / \\mathcal{C}$는 $\\mathcal{C}$의 모든 객체의 글로벌 원소(global elements)를 객체로 가집니다.",
	"Morphisms of $1/  \\mathcal{C}$ that correspond to arrows $f \\colon a \\to b$ map the set of global elements of $a$ to the set of global elements of $b$.": "$1/\\mathcal{C}$의 사상(Morphisms)은 $f \\colon a \\to b$에 해당하며, $a$의 전역 원소(global elements) 집합을 $b$의 전역 원소 집합으로 매핑합니다.",
	"In particular, the construction of a coslice category from the category of types and functions justifies our intuition of types as sets of values, with values represented by global elements of types.": "특히, 타입과 함수들의 범주(category)로부터 코슬라이스 범주(coslice category)를 구성하는 것은 타입을 값들의 집합으로 이해하는 우리의 직관을 정당화하며, 타입의 전역 원소로 값이 표현됩니다.",
	"\\section{Functors}": "\\section{함자(Functors)}",
	"We've seen examples of functoriality when discussing algebraic data types. The idea is that such a data type ``remembers'' the way it was created, and we can manipulate this memory by applying an arrow to its ``contents.''": "우리는 대수 데이터 유형을 논의할 때 함자성(functoriality) 예제를 보았습니다. 이러한 데이터 유형은 생성된 방식을 ``기억''하며, 화살표를 그 ``내용''에 적용하여 이 기억을 조작할 수 있습니다.",
	"In some cases this intuition is very convincing: we think of a product type as a pair that ``contains'' its ingredients. After all, we can retrieve them using projections.": "어떤 경우에는 이 직관이 매우 설득력 있슴니다: 우리는 곱 유형(product type)을 그것의 구성 요소들을 ``포함하는'' 쌍으로 생각합니다. 결국, 투영(projection)을 사용하여 그들을 검색할 수 있슴니다.",
	"This is less obvious in the case of function objects. You can visualize a function object as secretly storing all possible results and using the function argument to index into them. A function from \\hask{Bool} is obviously equivalent to a pair of values, one for \\hask{True} and one for \\hask{False}. It's a known programming trick to implement some functions as lookup tables. It's called \\emph{memoization}.": "This is less obvious in the case of function objects. You can visualize a function object as secretly storing all possible results and using the function argument to index into them. A function from \\hask{Bool} is obviously equivalent to a pair of values, one for \\hask{True} and one for \\hask{False}. It's a known programming trick to implement some functions as lookup tables. It's called \\emph{memoization}(메모이제이션).",
	"Even though it's not practical to memoize functions that take, say, natural numbers as arguments; we can still conceptualize them as (infinite, or even uncountable) lookup tables.": "비록 자연수를 인수로 취하는 함수들을 메모이즈(memoize)하는 것이 실용적이지는 않지만; 우리는 여전히 이를 (무한, 또는 심지어 셀 수 없는) 조회 테이블(lookup tables)로 개념화할 수 있습니다.",
	"If you can think of a data type as a container of values, it makes sense to apply a function to transform all these values, and create a transformed container. When this is possible, we say that the data type is \\emph{functorial}.": "데이터 타입을 값들의 컨테이너(container of values)로 생각할 수 있다면, 이 값들을 변환하는 함수를 적용하여 변환된 컨테이너를 생성하는 것이 합리적입니다. 이것이 가능할 때, 우리는 그 데이터 타입이 \\emph{함자적}(functorial)이라고 말합니다.",
	"Again, function types require some more suspension of disbelief. You visualize a function object as a lookup table, keyed by some type. If you want to use another, related type as your key, you need a function that translates the new key to the original key. This is why functoriality of the function object has one of the arrows reversed:": "다시 말해, 함수 타입(function types)은 더 많은 믿음의 보류를 요구합니다. 당신은 함수 객체(function object)를 어떤 타입으로 키(Key)된 조회 테이블(lookup table)로 시각화합니다. 만약 당신이 키로서 다른, 관련된 타입을 사용하고 싶다면, 새로운 키를 원래 키로 변환하는 함수를 필요로 합니다. 이것이 함수 객체의 함자성(functoriality)이 하나의 화살표를 반대로 가지는 이유입니다:",
	"You are applying the transformation to a function \\hask{h :: a -> b} that has a ``receptor'' that responds to values of type \\hask{a}, and you want to use it to process input of type \\hask{a'}. This is only possible if you have a converter from \\hask{a'} to \\hask{a}, namely \\hask{f :: a' -> a}.": "content:당신은 \\hask{a} 타입의 값을 받는 ``수용체''를 가진 함수 \\hask{h :: a -> b}에 변환을 적용하려고 합니다, 그리고 \\hask{a'} 타입의 입력을 처리하는 데 사용하고자 합니다. 이는 \\hask{a'}에서 \\hask{a}로 변환하는 \\hask{f :: a' -> a} 컨버터가 있을 때에만 가능합니다.",
	"The idea of a data type ``containing'' values of another type can be also expressed by saying that one data type is paremeterized by another. For instance, the type \\hask{List a} is parameterized by the type \\hask{a}.": "어떤 데이터 타입이 다른 타입의 값을 \"포함\"하는 아이디어는 하나의 데이터 타입이 다른 타입에 의해 파라미터화된다고 말할 수 있습니. 예를 들어, 타입 \\hask{List a}는 타입 \\hask{a}에 의해 파라미터화되어 있습니.",
	"In other words, \\hask{List} maps the type \\hask{a} to the type \\hask{List a}. \\hask{List} by itself, without the argument, is called a \\emph{type constructor}.": "다시 말해, \\hask{List}는 타입 \\hask{a}를 타입 \\hask{List a}로 매핑합니다. 인자 없이 단독으로 사용하는 \\hask{List}는 \\emph{타입 생성자}(type constructor)라고 불립니다.",
	"\\subsection{Functors between categories}": "\\subsection{함자들(Functors) 사이의 범주들}",
	"In category theory, a type constructor is modeled as a mapping of objects to objects. It's a function on objects. This is not to be confused with arrows between objects, which are part of the structure of the category.": "범주 이론(category theory)에서, 타입 생성자(type constructor)는 객체들의 대응(mapping)으로 모델링 됩니다. 이는 객체들에 대한 함수입니다. 이는 범주의 구조의 일부인 객체들 간의 화살표(arrow)와 혼동해서는 안 됩니다.",
	"In fact, it's easier to imagine a mapping \\emph{between} categories. Every object in the source category is mapped to an object in the target category. If $a$ is an object in $\\mathcal{C}$, there is a corrsponding object $F a$ in $\\mathcal{D}$.": "사실, \\emph{카테고리 사이의} 매핑을 상상하는 것이 더 쉽습니다. 출발 카테고리(source category)의 모든 객체(object)는 목표 카테고리(target category)의 객체로 매핑됩니다. 만약 $a$가 $\\mathcal{C}$의 객체라면, 해당하는 객체 $F a$가 $\\mathcal{D}$에 있습니다.",
	"A functorial mapping, or a \\emph{functor}, not only maps objects but also arrows between them. Every arrow": "함자적 사상(funtorial mapping) 또는 \\emph{함자(functor)}는 객체(object)들 뿐만 아니라 그들 사이의 화살표(arrow)들도 매핑한답니다. 모든 화살표",
	"f \\colon a \\to b": "f \\colon a \\to b",
	"in the first category has a corresponding arrow in the second category:": "첫 번째 카테고리에 있는 화살표는 두 번째 카테고리에 대응되는 화살표를 가지고 있습니 다:",
	"F f \\colon F a \\to F b": "F f \\colon F a \\to F b",
	"We use the same letter, here $F$, to name both, the mapping of objects and the mapping of arrows.": "우리는 객체의 대응(mapping)과 화살표의 대응(mapping) 모두에 대해 동일한 문자 $F$를 사용합니다.",
	"If categories distill the essence of \\emph{structure}, then functors are mappings that preserve this structure. Objects that are related in the source category are related in the target category.": "범주(카테고리)가 \\emph{구조}(structure)의 본질을 정제한 것이라면, 함자(푼터)는 이 구조를 보존하는 사상입니다. 원천 범주(source category)에서 관련된 객체들은 목표 범주(target category)에서도 관련되어 있습니다.",
	"The structure of a category is defined by arrows and their composition. Therefore a functor must preserve composition. What is composed in one category:": "범주의 구조는 화살표와 그것들의 합성(compostion)에 의해 정의됩니다. 따라서 함자(functor)는 합성을 보존해야 합니다. 한 범주에서 합성된 것은:",
	"h = g \\circ f": "h = g \\circ f",
	"should remain composed in the second category:": "두 번째 카테고리에서도 구성된 상태로 유지되어야 합니다.",
	"F h = F (g \\circ f) = F g \\circ F f": "\\( F h = F (g \\circ f) = F g \\circ F f \\)",
	"We can either compose two arrows in $\\mathcal{C}$ and map the composite to $\\mathcal{D}$, or we can map individual arrows and then compose them in $\\mathcal{D}$. We demand that the result be the same.": "우리는 $\\mathcal{C}$에서 두 화살표를 합성한 후 이를 $\\mathcal{D}$로 매핑할 수 있거나, 개별 화살표들을 매핑한 후 $\\mathcal{D}$에서 합성할 수 있습니다. 우리는 그 결과가 동일하다고 요구합니다.",
	"Finally, a functor must preserve identity arrows:": "마지막으로, 함자(functor)는 항등 화살(identity arrows)을 보존해야 합니다:",
	"F\\, id_a = id_{F a}": "F\\, id_a = id_{F a}",
	"These conditions taken together define what it means for a functor to preserve the structure of a category.": "이 조건들을 종합하여 함자(functor)가 범주의 구조를 보존한다는 것이 무엇을 의미하는지 정의합니다.",
	"It's also important to realize what conditions are \\emph{not} part of the definition. For instance, a functor is allowed to map multiple objects into the same object. It can also map multiple arrows into the same arrow, as long as the endpoints match.": "아울러 어떤 조건들이 정의의 일부가 \\emph{아님}을 인식하는 것도 중요합니다. 예를 들어, 함자(functor)는 여러 객체를 동일한 객체로 매핑할 수 있습니다. 또한 끝점이 맞는 한 여러 화살표를 동일한 화살표로 매핑할 수도 있습니다.",
	"In the extreme, any category can be mapped to a singleton category with one object and one arrow.": "극단적으로, 어떠한 범주(category)도 하나의 객체와 하나의 화살표(arrow)를 가진 단일체 범주(singleton category)로 매핑될 수 있습니다.",
	"Also, not all object or arrows in the target category must be covered by a functor. In the extreme, we can have a functor from the singleton category to any (non-empty) category. Such a functor picks a single object together with its identity arrow.": "또한, 대상 범주(target category)의 모든 객체(object) 또는 화살표(arrow)가 함자(functor)에 의해 포함될 필요는 없습니. 극단적으로, 단일 객체 범주(singleton category)로부터 어떠한 (비어 있지 않은) 범주로도 함자가 존재할 수 있습니. 이러한 함자(functor)는 하나의 객체(object)와 그것의 항등 화살표(identity arrow)를 선택합니.",
	"A \\index{constant functor}\\emph{constant functor} $\\Delta_c$ is an example of a functor that maps all objects from the source category to a single object $c$ in the target category, and all arrows from the source category to a single identity arrow $id_c$.": "A \\index{constant functor}\\emph{상수 함자(constant functor)} $\\Delta_c$는 원천 범주의 모든 객체를 대상 범주의 단일 객체 $c$로 매핑하고, 원천 범주의 모든 화살표를 단일 관념 화살표(identity arrow) $id_c$로 매핑하는 함자의 예입니다.",
	"In category theory, functors are often used to create models of one category inside another. The fact that they can merge multiple objects and arrows into one means that they produce simplified views of the source category. They ``abstract'' some aspects of the source category.": "범주 이론에서 함자(함수자)(functors)는 종종 하나의 범주를 다른 범주 안에 모델링하기 위해 사용됩니다. 여러 객체와 화살표를 하나로 병합할 수 있는 사실은 그것들이 원본 범주의 단순화된 뷰(view)를 생성함을 의미합니다. 그것들은 원본 범주의 일부 측면을 ``추상화''합니다.",
	"The fact that they may only cover parts of the target category means that the models are embedded in a larger environment.": "그들이 타겟 카테고리의 일부만 다룰 수 있다는 사실은 모델들이 더 큰 환경에 내재되어 있음을 의미합니다.",
	"Functors from some minimalistic, stick-figure, categories can be used to define patterns in larger categories.": "Functors(함자)는 어떤 최소한의 막대-그림, 범주들로부터 더 큰 범주들 속의 패턴들을 정의하는 데 사용할 수 있습니.",
	"\\end{exercise}": "\\end{exercise}",
	"\\section{Functors in Programming}": "\\section{프로그래밍에서의 함자(Functors)}",
	"Endofunctors are the class of functors that are the easiest to express in a programming language. These are functors that map a category (here, the category of types and functions) to itself.": "Endofunctors는 프로그래밍 언어로 가장 쉽게 표현할 수 있는 함수자(functors)의 종류입니다. 이러한 함수자는 카테고리(여기서는 타입과 함수들의 카테고리)를 자기 자신으로 매핑합니다.",
	"\\subsection{Endofunctors}": "\\subsection{Endofunctors(종단함자)}",
	"The first part of the endofunctor is the mapping of types to types. This is done using type constructors, which are type-level functions.": "함수자(Endofunctor)의 첫 번째 부분은 타입을 타입으로 매핑하는 것입니다. 이는 타입 생성자(type constructor)들을 사용하여 이루어지며, 이들은 타입 레벨 함수입니다.",
	"The list type constructor, \\hask{List}, maps an arbitrary type \\hask{a} to the type \\hask{List a}.": "목록 타입 생성자인, \\hask{List}, 는 임의의 타입 \\hask{a}를 타입 \\hask{List a}로 매핑합니다.",
	"The \\hask{Maybe} type constructor maps \\hask{a} to \\hask{Maybe a}.": "The \\hask{Maybe} 타입 생성자(type constructor)는 \\hask{a}를 \\hask{Maybe a}로 매핑합니다.",
	"The second part of an endofunctor is the mapping of arrows. Given a function \\hask{a -> b}, we want to be able to define a function \\hask{List a -> List b}, or \\hask{Maybe a -> Maybe b}. This is the ``functoriality'' property of these data types that we have discussed before. Functoriality lets us \\index{lifting}\\emph{lift} an arbitrary function to a function between transformed types.": "Endofunctor의 두 번째 부분은 화살표를 매핑하는 것입니다. 주어진 함수 \\hask{a -> b}가 있을 때, 우리는 함수 \\hask{List a -> List b} 또는 \\hask{Maybe a -> Maybe b}를 정의할 수 있어야 합니다. 이것이 우리가 이전에 논의한 이 데이터 타입의 \"함자성(functoriality)\" 속성입니다. 함자성(functoriality)은 임의의 함수를 변환된 타입 간의 함수로 \\index{lifting}\\emph{올리는(lift)} 것을 가능하게 합니다.",
	"Functoriality can be expressed in Haskell using a \\index{\\hask{class}}\\emph{typeclass}. In this case, the typeclass is parameterized by a type constructor \\hask{f} (in Haskell we use lower case names for type-constructor variables). We say that \\hask{f} is a \\hask{Functor} if there is a corresponding mapping of functions called \\hask{fmap}:": "함자성을 Haskell에서 \\index{\\hask{class}}\\emph{타입 클래스}(typeclass)를 사용하여 표현할 수 있습니 다. 이 경우, 타입 클래스는 타입 생성자 \\hask{f}에 의해 매개변수화 됩니다 (Haskell에서는 타입 생성자 변수에 소문자 이름을 사용합니 다). 우리는 적절한 대응 함수의 매핑인 \\hask{fmap}이라는 함수가 있으면 \\hask{f}가 \\hask{Functor}(함자)라 말합니다:",
	"The compiler knows that \\hask{f} is a type constructor because it's applied to types, as in \\hask{f a} and \\hask{f b}.": "컴파일러는 \\hask{f}가 타입 생성자(type constructor)라는 것을 압니다. 왜냐하면 그것이 \\hask{f a}와 \\hask{f b}에서와 같이 타입에 적용되기 때문입니다.",
	"To prove to the compiler that a particular type constructor is a \\hask{Functor}, we have to provide the implementation of \\hask{fmap} for it. This is done by defining an \\index{\\hask{instance}}\\emph{instance} of the typeclass \\hask{Functor}. For example:": "컴파일러에게 특정 타입 생성자가 \\hask{Functor}임을 증명하기 위해, 우리는 그에 대한 \\hask{fmap}의 구현을 제공해야 합니다. 이는 타입클래스 \\hask{Functor}의 \\index{\\hask{instance}}\\emph{인스턴스(instance)}를 정의함으로써 가능합니다. 예를 들어:",
	"A functor must also satisfy some laws: it must preserve composition and identity. These laws cannot be expressed in Haskell, but should be checked by the programmer. We have previously seen a definition of \\hask{badMap} that didn't satisfy the identity laws, yet it would be accepted by the compiler. It would define an ``unlawful'' instance of \\hask{Functor} for the list type constructor \\hask{[]}.": "펑터는 몇 가지 법칙을 만족해야 합니다: 이를 합성(composition)과 항등성(identity)을 보존해야 합니다. 이러한 법칙은 Haskell에서 표현할 수 없지만, 프로그래머가 확인해야 합니다. 이전에 항등성 법칙을 만족하지 않은 \\hask{badMap}의 정의를 보았으나, 컴파일러에 의해 허용될 것입니다. 이는 리스트 타입 생성자 \\hask{[]}에 대한 ``불법적인'' \\hask{Functor} 인스턴스를 정의할 것입니다.",
	"There are some elementary functors that might seem trivial, but they serve as building blocks for other functors.": "어떤 기본적인 함자(함자, functors)들이 있을 수 있는데, 이들은 사소해 보일지 몰라도 다른 함자들의 구성 요소로서 작용합니다.",
	"We have the identity endofunctor that maps all objects to themselves, and all arrows to themselves.": "우리는 모든 객체와 모든 사상을 자기 자신으로 매핑하는 항등 자기함자(endofunctor)를 가지고 있니다.",
	"We also have a constant functor $\\Delta_c$ that maps all objects to a single object $c$, and all arrows to the identity arrow on this object. In Haskell, it's a family of functors parameterized by the target object \\hask{c}:": "우리는 또한 모든 객체들을 단일 객체 $c$ 로 매핑하고, 모든 화살(arrows)들을 이 객체의 항등 화살(identity arrow)로 매핑하는 상수 함자(constant functor) $\\Delta_c$ 를 가지고 있습니다. Haskell 에서는, 이는 대상 객체 \\hask{c} 에 의해 매개변수화된 함자들의 집합(family of functors)입니다:",
	"This type constructor ignores its second argument.": "이 타입 생성자는 두 번째 인수를 무시합니다.",
	"\\subsection{Bifunctors}": "\\subsection{이항 함자(Bifunctors)}",
	"We have also seen data constructors that take two types as arguments: the product and the sum. They were functorial as well, but instead of lifting a single function, they lifted a pair of functions. In category theory, we would define these as functors from the product category $\\mathcal{C} \\times \\mathcal{C}$ to $\\mathcal{C}$.": "데이터 생성자가 두 개의 타입을 인자로 받는 경우도 보았습니다: 곱(product)과 합(sum)입니다. 이들은 또한 함자적(functorial)입니다, 하지만 단일 함수를 올리는 대신, 함수 쌍을 올렸습니다. 범주론(category theory)에서, 이것을 $\\mathcal{C} \\times \\mathcal{C}$ 범주(product category)에서 $\\mathcal{C}$ 범주로의 함자(functors)로 정의합니다.",
	"Such functors map a pair of objects to an object, and a pair of arrows to an arrow.": "이러한 함자(functor)는 객체의 쌍을 객체로, 화살표(arrow)의 쌍을 화살표로 매핑합니다.",
	"In Haskell, we treat such functors as members of a separate class called \\hask{Bifunctor}.": "하스켈(Haskell)에서는 이러한 펑터(functor)들을 \\hask{Bifunctor}라고 불리는 별도의 클래스의 구성원으로 취급합니다.",
	"Again, the compiler deduces that \\hask{f} is a two-argument type constructor because it sees it applied to two types, e.g., \\hask{f a b}.": "다시, 컴파일러는 \\hask{f}가 두 인수 타입 생성자(type constructor)라고 추론합니다. 왜냐하면 그것이 두 타입에 적용된 것을 보았기 때문입니다, 예를 들어 \\hask{f a b}.",
	"To prove to the compiler that a particular type constructor is a \\hask{Bifunctor}, we define an instance. For example, bifunctoriality of a pair can be defined as:": "컴파일러에게 특정 타입 생성자가 \\hask{Bifunctor}임을 증명하기 위해 우리는 인스턴스를 정의합니다. 예를 들어, 쌍(pair)의 bifunctoriality는 다음과 같이 정의될 수 있습니다:",
	"\\subsection{Contravariant functors}": "\\subsection{반변 함자(Contravariant functors)}",
	"Functors from the opposite category $\\mathcal{C}^{op}$ are called \\emph{contravariant}. They have the property of lifting arrows that go in the opposite direction. Regular functors are sometimes called \\index{covariant functor}\\emph{covariant}.": "반대 범주(opposite category) $\\mathcal{C}^{op}$에서의 함수자는 \\emph{반변함자(contravariant)}라고 합니다. 이들은 반대 방향으로 가는 화살표를 올리는 성질을 가지고 있습니다. 일반적인 함수자는 때때로 \\index{공변함자(covariant functor)}\\emph{공변함자(covariant)}라고 불립니다.",
	"In Haskell, contravariant functors form the typeclass \\hask{Contravariant}:": "In Haskell, 반변 함자(contravariant functors)들은 타입클래스 \\hask{Contravariant}를 구성합니다:",
	"It's often convenient to think of functors in terms of producers and consumers. In this picture, a (covariant) functor is a producer. You can turn a producer of \\hask{a}'s to a producer of \\hask{b}'s by applying (using \\hask{fmap}) a function \\hask{a->b}. Conversely, to turn a consumer of \\hask{a}'s to a consumer of \\hask{b}'s you need a function going in the opposite direction, \\hask{b->a}.": "자주 functor(함자)를 생산자와 소비자의 관점에서 생각하는 것이 편리합니다. 이 그림에서, (공변) functor(함자)는 생산자입니다. 함수 \\hask{a->b}를 적용하여 (\\hask{fmap}을 사용하여) \\hask{a}의 생산자를 \\hask{b}의 생산자로 바꿀 수 있습니다. 반대로, \\hask{a}의 소비자를 \\hask{b}의 소비자로 바꾸기 위해서는 반대 방향으로 가는 함수, 즉 \\hask{b->a}가 필요합니다.",
	"Example: A predicate is a function returning \\hask{True} or \\hask{False}:": "예시: 술어(predicate)는 \\hask{True} 또는 \\hask{False} 값을 반환하는 함수입니다:",
	"It's easy to see that it's a contravariant functor:": "It's easy to see that it's a contravariant functor(반변 함자) :",
	"The only non-trivial examples of contravariant functors are variations on the theme of function objects.": "유일하게 비자명한 예시들의 반공변 함자(contravariant functors)는 함수 객체(theme of function objects)의 변형입니다.",
	"One way to tell if a given function type is covariant or contravariant in one of the type arguments is by assigning polarities to the types used in its definition. We say that the return type of a function is in a \\emph{positive} position, so it's covariant; and the argument type is in the \\emph{negative} position, so it's contravariant. But if you put the whole function object in the negative position of another function, then its polarities get reversed.": "어떤 주어진 함수 타입이 타입 인자 중 하나에서 공변적(covariant)인지 반공변적(contravariant)인지 알아보는 한 가지 방법은 정의에 사용된 타입들에 극성을 부여하는 것입니다. 함수의 반환 타입은 \\emph{양수} 위치에 있으므로 공변적입니다; 그리고 인자 타입은 \\emph{음수} 위치에 있으므로 반공변적입니다. 그러나 전체 함수 객체를 다른 함수의 음수 위치에 놓으면, 그 극성은 뒤바뀝니다.",
	"Consider this data type:": "이 데이터 타입을 고려해 보세요:",
	"It has \\hask{a} in a double-negative, therefore a positive position. This is why it's a covariant \\hask{Functor}. It's a producer of \\hask{a}'s:": "이것은 이중 부정적(negative) 위치에 \\hask{a}를 갖고 있으므로 긍정적(positive) 위치에 있는 것입니다. 이것이 공변 \\hask{함자(Functor)}인 이유입니다. 이것은 \\hask{a}의 생성자(producer)입니다:",
	"Notice that parentheses are important here. A similar function \\hask{a -> Bool -> Bool} has \\hask{a} in a \\emph{negative} position. That's because it's a function of \\hask{a} returning a function \\hask{(Bool -> Bool)}. Equivalently, you may uncurry it to get a function that takes a pair: \\hask{(a, Bool) -> Bool}. Either way, \\hask{a} ends up in the negative position.": "괄호가 여기서 중요함을 주목하세요. 비슷한 함수 \\hask{a -> Bool -> Bool}는 \\hask{a}가 \\emph{음수의} 위치에 있습니다. 이것은 \\hask{a}의 함수가 \\hask{(Bool -> Bool)} 함수로 반환되기 때문입니다. 동등하게, 이것을 커리-해제(uncurry) 해서 쌍을 받는 함수로 만들 수 있습니다: \\hask{(a, Bool) -> Bool}. 어떠한 경우든 \\hask{a}는 음수 위치에 있습니다.",
	"\\subsection{Profunctors}": "\\subsection{Profunctors (프로펑터)}",
	"We've seen before that the function type is functorial. It lifts two functions at a time, just like \\hask{Bifunctor}, except that one of the functions goes in the opposite direction.": "우리는 이전에 함수형이 함수적(funtorial)이라는 것을 본 적이 있습니다. 이것은 \\hask{Bifunctor}와 마찬가지로 한 번에 두 개의 함수를 들어올리는데, 단 하나의 함수는 반대 방향으로 갑니다.",
	"In category theory this corresponds to a functor from a product of two categories, one of them being the opposite category: it's a functor from $\\mathcal{C}^{op} \\times \\mathcal{C}$. Functors from $\\mathcal{C}^{op} \\times \\mathcal{C}$ to $\\mathbf{Set}$ are called \\emph{profunctors}.": "범주 이론에서 이는 두 범주의 곱의 함자(functor)에 해당합니다. 여기서 하나는 반대 범주(opposite category)입니다: 이는 $\\mathcal{C}^{op} \\times \\mathcal{C}$부터의 함자입니다. $\\mathcal{C}^{op} \\times \\mathcal{C}$로부터 $\\mathbf{Set}$까지의 함자를 \\emph{profunctors}(프로펑터)라고 합니다.",
	"In Haskell, profunctors form a typeclass:": "Haskell에서, 프로펀터들(profunctors)은 하나의 타입클래스를 형성합니다:",
	"You can think of a profunctor as a type that's simultaneously a producer and a consumer. It consumes one type and produces another.": "프로펑터(profunctor)는 동시에 생산자이자 소비자인 유형(type)이라고 생각할 수 있읍니다. 하나의 유형을 소비하고 다른 유형을 생산합니다.",
	"The function type, which can be written as an infix operator \\hask{(->)}, is an instance of \\hask{Profunctor}": "함수 타입(function type)은 \\hask{Profunctor}의 인스턴스(instance)로서 \\hask{(->)}로 표기될 수 있습니다.",
	"This is in accordance with our intuition that a function \\hask{a->b} consumes arguments of the type \\hask{a} and produces results of the type \\hask{b}.": "이는 함수 \\hask{a->b}가 \\hask{a} 타입의 인수를 소모하고 \\hask{b} 타입의 결과를 생성한다는 우리의 직관과 일치합니다.",
	"In programming, all non-trivial profunctors are variations on the function type.": "프로그래밍에서, 모든 비자명한 프로펑터(profunctors)는 함수 타입의 변형입니다.",
	"\\section{The Hom-Functor}": "\\section{Hom-함수자(Hom-Functor)}",
	"Arrows between any two objects form a set. This set is called a hom-set and is usually written using the name of the category followed by the names of the objects:": "두 객체 사이의 모든 화살표는 집합을 이룹니다. 이 집합은 hom-집합(hom-set)이라고 하며 보통 범주(category)의 이름 뒤에 객체의 이름을 붙여서 씁니다:",
	"\\mathcal{C}(a, b)": "\\mathcal{C}(a, b)",
	"We can interpret the hom-set $\\mathcal{C}(a, b)$ as all the ways $b$ can be observed from $a$.": "우리는 hom-집합 $\\mathcal{C}(a, b)$을 $a$로부터 $b$를 관찰할 수 있는 모든 방법으로 해석할 수 있습니 다.",
	"Another way of looking at hom-sets is to say that they define a mapping that assigns a set $\\mathcal{C}(a, b)$ to every pair of objects. Sets themselves are objects in the category $\\mathbf{Set}$. So we have a mapping between categories.": "Another way of looking at hom-sets는 hom-sets(사상집합)을 바라보는 또 다른 방법은 to say that they define a mapping 그것들이 매핑(mapping)을 정의한다는 것입니다 that assigns a set $\\mathcal{C}(a, b)$ 집합 $\\mathcal{C}(a, b)$를 to every pair of objects 모든 객체 쌍에 할당하는. Sets themselves 집합 자체는 are objects in the category $\\mathbf{Set}$ 범주 $\\mathbf{Set}$의 객체입니다. So we have a mapping between categories 그래서 우리는 범주들 간의 매핑(mapping)을 가지고 있습니다.",
	"This mapping is functorial. To see that, let's consider what happens when we transform the two objects $a$ and $b$. We are interested in a transformation that would map the set $\\mathcal{C}(a, b)$ to the set $\\mathcal{C}(a', b')$. Arrows in $\\mathbf{Set}$ are regular functions, so it's enough to define their action on individual elements of a set.": "이 사상(mapping)은 함자적(functorial)입니다. 이를 보기 위해, 두 객체 $a$와 $b$를 변환할 때 발생하는 일을 고려합시다. 우리는 집합 $\\mathcal{C}(a, b)$를 집합 $\\mathcal{C}(a', b')$로 사상하는 변환에 관심이 있습니다. $\\mathbf{Set}$ 내의 화살표(arrows)는 일반적인 함수들이므로 집합의 개별 요소에 대한 그들의 작용을 정의하는 것으로 충분합니다.",
	"An element of $\\mathcal{C}(a, b)$ is an arrow $h \\colon a \\to b$ and an element of $\\mathcal{C}(a', b')$ is an arrow $h' \\colon a' \\to b'$. We know how to transform one into another: we need to pre-compose $h$ with an arrow $g' \\colon a' \\to a$ and post-compose it with an arrow $g \\colon b \\to b'$.": "$\\mathcal{C}(a, b)$의 한 요소는 화살표 $h \\colon a \\to b$이며, $\\mathcal{C}(a', b')$의 한 요소는 화살표 $h' \\colon a' \\to b'$입니다. 하나를 다른 하나로 변환하는 방법은 알고 있습니다: 우리는 $h$를 화살표 $g' \\colon a' \\to a$와 함께 사전 조합(pre-compose)하고 화살표 $g \\colon b \\to b'$와 함께 사후 조합(post-compose)해야 합니다.",
	"In other words, the mapping that takes a pair $\\langle a, b \\rangle$ to the set $\\mathcal{C}(a, b)$ is a \\emph{profunctor}:": "다른 말로, $\\langle a, b \\rangle$ 쌍을 집합 $\\mathcal{C}(a, b)$로 대응시키는 사상(mapping)은 \\emph{프로펑터(profunctor)}입니다.",
	"\\mathcal{C}^{op} \\times \\mathcal{C} \\to \\mathbf{Set}": "\\mathcal{C}^{op} \\times \\mathcal{C} \\to \\mathbf{Set}",
	"Frequently, we are interested in varying only one of the objects, keeping the other fixed. When we fix the source object and vary the target, the result is a functor  that is written as:": "자주 우리는 하나의 객체만 변경하고 다른 하나는 고정하는 것에 관심이 있습니다. 소스 객체를 고정하고 타겟을 변경하면 결과는 다음과 같은 펑터(functor)가 됩니다:",
	"\\mathcal{C}(a, -) \\colon \\mathcal{C} \\to \\mathbf{Set}": "\\mathcal{C}(a, -) \\colon \\mathcal{C} \\to \\mathbf{Set}",
	"The action of this functor on an arrow $g \\colon b \\to b'$ is written as:": "이 함자의 화살표 $g \\colon b \\to b'$에 대한 작용은 다음과 같이 쓴다:",
	"\\mathcal{C}(a, g) \\colon \\mathcal{C}(a, b) \\to \\mathcal{C}(a, b')": "\\mathcal{C}(a, g) \\colon \\mathcal{C}(a, b) \\to \\mathcal{C}(a, b')",
	"and is given by post-composition:": "content:그리고 이는 다음과 같이 주어진다: 후적합(후콤포지션, post-composition)으로:",
	"\\mathcal{C}(a, g) = (g \\circ -)": "\\mathcal{C}(a, g) = (g \\circ -)",
	"Varying $b$ means switching focus from one object to another, so the complete functor $\\mathcal{C}(a, -)$ combines all the arrows emanating from $a$ into a coherent view of the category from the perspective of $a$. It is ``the world according to $a$.''": "$b$를 변화시킨다는 것은 하나의 대상에서 다른 대상으로 초점을 전환하는 것을 의미하므로, 완비 함자 $\\mathcal{C}(a, -)$는 $a$에서 나오는 모든 화살표들을 $a$의 관점에서의 범주에 대한 일관된 관점으로 결합합니다. 이는 \"a에 따른 세계\"입니다.",
	"Conversely, when we fix the target and vary the source of the hom-functor, we get a contravariant functor:": "반대로, 타겟(target)을 고정하고 hom-펑터(hom-functor)의 소스(source)를 변화시키면, 반변 펑터(contravariant functor)를 얻습니다:\n",
	"\\mathcal{C}(-, b) \\colon \\mathcal{C}^{op} \\to \\mathbf{Set}": "\\mathcal{C}(-, b) \\colon \\mathcal{C}^{op} \\to \\mathbf{Set}",
	"whose action on an arrow $g' \\colon a' \\to a$ is written as:": "그 작용이 화살표 $g' \\colon a' \\to a$에 대해 다음과 같이 쓰여집니다:",
	"\\mathcal{C}(g', b) \\colon \\mathcal{C}(a, b) \\to \\mathcal{C}(a', b)": "\\mathcal{C}(g', b) \\colon \\mathcal{C}(a, b) \\to \\mathcal{C}(a', b)",
	"and is given by pre-composition:": "앞서 이루어진 사전 구성에 의해 제공됩니다:",
	"\\mathcal{C}(g', b) = (- \\circ g')": "\\mathcal{C}(g', b) = (- \\circ g')",
	"The functor $\\mathcal{C}(-, b)$ organizes all the arrows pointing at $b$ into one coherent view. It is the picture of $b$ ``as it's seen by the world.''": "함자 $\\mathcal{C}(-, b)$는 모든 화살표를 $b$를 가리키는 방향으로 일관성 있게 조직합니다. 이는 $b$가 \"세상에 의해 바라본 모습\"입니다.",
	"We can now reformulate the results from the chapter on isomorphisms. If two objects $a$ and $b$ are isomorphic, than their hom-sets are also isomorphic. In particular:": "우리는 이제 서로 동형사상들에 관한 장에서의 결과들을 다시 정리할 수 있습니니다. 만약 두 개체 $a$와 $b$가 동형사상(isomorphic)이라면, 그들의 hom-집합(hom-sets) 또한 동형사상입니다. 특히:",
	"\\mathcal{C}(a, x) \\cong \\mathcal{C}(b, x)": "\\mathcal{C}(a, x) \\cong \\mathcal{C}(b, x)",
	"and": "content:그리고",
	"\\mathcal{C}(x, a) \\cong \\mathcal{C}(x, b)": "\\mathcal{C}(x, a) \\cong \\mathcal{C}(x, b)",
	"We'll discuss naturality conditions in the next chapter.": "다음 장에서 자연성 조건(naturality conditions)에 대해 논의하겠습니다.",
	"Another way of looking at the hom-functor $\\cat C(a, -)$ is as an oracle that  provides answers to the question: ``Is $a$ connected to me?'' If the set $\\cat C(a, x)$ is empty, the answer is negative: ``$a$ is not connected to $x$.'' Otherwise, every element of the set $\\cat C(a, x)$ is a proof that such connection exists.": "Another way of looking at the hom-functor $\\cat C(a, -)$ is as an oracle that provides answers to the question: ``Is $a$ connected to me?'' If the set $\\cat C(a, x)$ is empty, the answer is negative: ``$a$는 $x$와 연결되지 않았습니다.'' Otherwise, every element of the set $\\cat C(a, x)$ is a proof that such connection exists.",
	"Conversely, the contravariant functor $\\cat C (-, a)$ answers the question: ``Am I connected to $a$?''": "반대로, 반변 함자(contravariant functor) $\\cat C (-, a)$는 \"나는 $a$에 연결되어 있습니까?\"라는 질문에 답합니다.",
	"Taken together, the profunctor $\\cat C(x, y)$ establishes a \\index{proof-relevant relation}\\emph{proof-relevant} relation between objects. Every element of the set $\\cat C(x, y)$ is a proof that $x$ is connected to $y$. If the set is empty, the two objects are unrelated.": "함께 고려할 때, 프로펑터(profunctor) $\\cat C(x, y)$는 객체들 사이에 \\index{proof-relevant relation}\\emph{증거-관련된(proof-relevant)} 관계를 설정합니다. 집합 $\\cat C(x, y)$의 모든 요소는 $x$가 $y$에 연결되어 있다는 증거입니다. 집합이 비어 있다면, 두 객체는 관련이 없는 것입니다.",
	"\\section{Functor Composition}": "\\section{함자 합성(Functor Composition)}",
	"Just like we can compose functions, we can compose functors. Two functors are composable if the target category of one is the source category of the other.": "마치 함수들을 합성할 수 있는 것처럼, 펑터(functor)들도 합성할 수 있습니다. 두 펑터가 합성 가능하려면 하나의 타겟(target) 범주와 다른 하나의 소스(source) 범주가 같아야 합니다.",
	"On objects, functor composition of $G$ after $F$ first applies $F$ to an object, then applies $G$ to the result; and similarly on arrows.": "대상들(objects)에 대해, 함자(functor) 합성(composition) $G$를 $F$ 뒤에 적용하는 것은 먼저 대 상에 $F$를 적용한 후, 그 결과에 $G$를 적용합니다; 화살표들(arrows)도 마찬가지입니다.",
	"Obviously, you can only compose composable functors. However all \\emph{endofunctors} are composable, since their target category is the same as the source category.": "당연히 합성 가능한 함자들만 합성할 수 있습니다. 그러나 모든 \\emph{내적 함자}(endofunctors)는 합성 가능하니, 그 대상 범주가 출발 범주와 동일하기 때문입니다.",
	"In Haskell, a functor is a parameterized data type, so the composition of two functors is again a parameterized data type. On objects, we define:": "Haskell에서 함자(functor)는 매개변수가 있는 데이터 타입(parameterized data type)입니다, 그래서 두 함자의 합성(composition)은 다시 매개변수가 있는 데이터 타입입니다. 대상(objects)에서는 다음과 같이 정의합니다:",
	"The compiler figures out that \\hask{f} and \\hask{g} must be type constructors because they are applied to types: \\hask{f} is applied to the type parameter \\hask{a}, and \\hask{g} is applied to the resulting type.": "컴파일러가 \\hask{f}와 \\hask{g}가 타입 생성자(type constructors)임을 알아차립니다. 이는 이들이 타입에 적용되기 때문입니다: \\hask{f}는 타입 매개변수(type parameter) \\hask{a}에 적용되고, \\hask{g}는 그 결과 타입에 적용됩니다.",
	"Alternatively, you can tell the compiler that the first two arguments to \\hask{Compose} are type constructors. You do this by providing a \\index{kind signatures}\\emph{kind signature}, which requires a language extension \\hask{KindSignatures} that you put at the top of the source file:": "Alternatively, you can tell the compiler that the first two arguments to \\hask{Compose} are type constructors. You do this by providing a \\index{kind signatures}\\emph{kind signature}, which requires a language extension \\hask{KindSignatures} that you put at the top of the source file:\n\n대신, \\hask{Compose}의 처음 두 인자가 타입 생성자(type constructors)라는 것을 컴파일러에게 알려줄 수 있습니다. 이 작업은 \\index{kind signatures}\\emph{kind signature}(종류 서명)를 제공함으로써 이루어지며, 이는 소스 파일의 맨 위에 \\hask{KindSignatures}라는 언어 확장을 필요로 합니다:",
	"You should also import the \\hask{Data.Kind} library that defines \\hask{Type}:": "다음의 \\hask{Data.Kind} 라이브러리도 가져와야 합니다. 이 라이브러리는 \\hask{Type}을 정의합니다:",
	"A kind signature is just like a type signature, except that it can be used to describe functions operating on types.": "종류 서명(kind signature)는 타입 서명(type signature)과 비슷하지만, 타입에서 작동하는 함수를 설명하는 데 사용될 수 있습니.",
	"Regular types have the kind \\hask{Type}. Type constructors have the kind \\hask{Type -> Type}, since they map types to types.": "정규 타입은 kind \\hask{Type}을 가지니다. 타입 생성자는 \\hask{Type -> Type}을 가지는데, 이는 타입을 타입으로 매핑하기 때문입니다.",
	"\\hask{Compose} takes two type constructors and produces a type constructor, so its kind signature is:": "\\hask{Compose}는 두 개의 타입 생성자(type constructors)를 받아서 하나의 타입 생성자를 생성하므로, 그 종류 서명(kind signature)은:\n",
	"and the full definition is:": "and the full definition is:",
	"Any two type constructors can be composed this way. There is no requirement, at this point, that they be functors.": "어떠한 두 타입 생성자(type constructors)도 이 방식으로 합성될 수 있습니니다. 이 시점에서, 그것들이 펑터(functors)일 필요는 없습니다.",
	"However, if we want to lift a function using the composition of type constructors, \\hask{g} after \\hask{f}, then they must be functors. This requirement is encoded as a constraint in the instance declaration:": "그러나, 타입 생성자의 합성을 사용하여 함수 \\hask{g}를 \\hask{f} 뒤에 들어올리고 싶다면, 이들은 펑터(functor)이어야 합니다. 이 요구사항은 인스턴스 선언에서 제약조건으로 인코딩됩니다:",
	"The constraint \\hask{(Functor g, Functor f)} expresses the condition that both type constructors be instances of the \\hask{Functor} class. The constraints are followed by a double arrow.": "제약 \\hask{(Functor g, Functor f)} 는 두 타입 생성자가 \\hask{Functor} 클래스의 인스턴스란 조건을 표현합니다. 제약 뒤에는 더블 애로우가 옵니다.",
	"The type constructor whose functoriality we are establishing is \\hask{Compose f g}, which is a partial application of \\hask{Compose} to two functors.": "우리가 함수자 속성을 증명하고 있는 타입 생성자는 \\hask{Compose f g}입니다. 이는 두 함수자에 부분적으로 적용된 \\hask{Compose}입니다.",
	"In the implementation of \\hask{fmap}, we pattern match on the data constructor \\hask{Compose}. Its argument \\hask{gfa} is of the type \\hask{g (f a)}. We use one \\hask{fmap} to ``get under'' \\hask{g}. Then we use \\hask{(fmap h)} to get under \\hask{f}. The compiler knows which \\hask{fmap} to use by analyzing the types.": "\\hask{fmap}의 구현에서, 우리는 데이터 생성자 \\hask{Compose}에 대해 패턴 매치를 합니다. 그 인자인 \\hask{gfa}는 타입 \\hask{g (f a)}입니다. 우리는 하나의 \\hask{fmap}를 사용하여 \\hask{g}의 \"하부로 들어갑니다\". 그런 다음 \\hask{(fmap h)}를 사용하여 \\hask{f}의 하부로 들어갑니다. 컴파일러는 타입을 분석하여 어떤 \\hask{fmap}를 사용할지 결정합니다.",
	"You may visualize a composite functor as a container of containers. For instance, the composition of \\hask{[]} with \\hask{Maybe} is a list of optional values.": "한 쪽 합성 함수를 컨테이너들의 컨테이너로 시각화할 수 있습니다. 예를 들어, \\hask{[]}와 \\hask{Maybe}의 합성은 선택적(옵셔널) 값들의 리스트입니다.",
	"\\subsection{Category of categories}": "\\subsection{카테고리들의 카테고리}",
	"We can view functors as arrows between categories. As we've just seen, functors are composable and it's easy to check that this composition is associative. We also have an identity (endo-) functor for every category. So categories themselves seem to form a category, let's call it $\\mathbf{Cat}$.": "함자(functor)들을 범주(category)들 간의 화살로 볼 수 있습니다. 방금 본 것처럼, 함자들은 합성될 수 있으며, 이 합성이 결합법칙(associativity)을 만족하는지 확인하는 것은 쉽습니다. 또한, 모든 범주마다 항등(endo-) 함자가 존재합니다. 따라서 범주들 자체가 범주를 형성하는 것처럼 보이며, 이를 $\\mathbf{Cat}$ 라고 부릅시다.",
	"And this is where mathematicians start worrying about ``size'' issues. It's a shorthand for saying that there are paradoxes lurking around. So the correct incantation is that $\\mathbf{Cat}$ is a category of \\emph{small} categories. But as long as we are not engaged in proofs of existence, we can ignore size problems.": "그리고 여기서 수학자들은 \"크기\" 문제에 대해 걱정하기 시작합니다. 이는 모순이 도사리고 있다는 것을 말하는 약식 표현입니다. 그래서 올바른 표현은 $\\mathbf{Cat}$가 \\emph{작은} 범주(category)의 범주(category)라는 것입니다. 하지만 존재의 증명을 시도하지 않는 한, 크기 문제는 무시해도 됩니다.",
	"\\end{document}": "\\end{document}"
}
