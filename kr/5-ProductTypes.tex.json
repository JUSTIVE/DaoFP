{"We can use sum types to enumerate possible values of a given type, but the encoding can be wasteful. We needed ten constructors just to encode numbers between zero and nine.":"주어진 타입의 가능한 값들을 나열하기 위해 합 타입(sum types)을 사용할 수 있습니니다, 하지만 인코딩이 낭비될 수 있습니니다. 0에서 9까지의 숫자를 인코딩하기 위해 꼬꼬하도록 열 개의 생성자(constructors)가 필요했습니니다.","But if we combine two digits into a single data structure, a two-digit decimal number, we'll be able to encode a hundred numbers. Or, as Lao Tzu would say, with just four digits you can encode ten thousand numbers.":"하지만 두 자릿수를 하나의 데이터 구조로 결합하면, 두 자릿수의 십진수를 통해 백 개의 숫자를 인코딩할 수 있습니니다. 혹은, 노자의 말을 빌리자면, 네 자릿수만 있으면 만 개의 숫자를 인코딩할 수 있습니다.","A data type that combines two types in this manner is called a product, or a \\index{cartesian product}\\emph{cartesian} product. Its defining quality is the elimination rule: there are two arrows coming from $a \\times b$; one called ``$\\text{fst}$'' goes to $a$, and another called ``$\\text{snd}$'' goes to $b$. They are called (cartesian) \\index{cartesian projections}\\emph{projections}. They let us retrieve $a$ and $b$ from the product $a \\times b$.":"두 타입을 이런 방식으로 결합한 데이터 타입을 곱(product) 또는 \\index{cartesian product}\\emph{카테시안 곱}이라 합니다. 그 정의의 중요한 요소는 제거 규칙입니다: $a \\times b$로부터 나오는 두 개의 화살표가 있습니다; 하나는 ``$\\text{fst}$''이라고 불리고 $a$로 가며, 다른 하나는 ``$\\text{snd}$''라고 불리고 $b$로 갑니다. 이들은 (카테시안) \\index{cartesian projections}\\emph{사영}이라고 불립니다. 이를 통해 우리는 곱 $a \\times b$에서 $a$와 $b$를 추출할 수 있습니다.","Suppose that somebody gave you an element of a product, that is an arrow $h$ from the terminal object $1$ to $a \\times b$. You can easily retrieve a pair of elements, just by using composition: an element of $a$ given by":"가정해 봅시다, 누군가 여러분에게 곱의 원소, 즉 종말 대상 $1$에서 $a \\times b$로의 화살표 $h$를 주었다고 합시다. 여러분은 단순히 합성을 사용하여, $a$의 원소와 $b$의 원소 한 쌍을 쉽게 추출할 수 있습니다: $a$의 원소는","x = \\text{fst} \\circ h":"x = \\text{fst} \\circ h","and an element of $b$ given by":"그리고 $b$의 요소는","y = \\text{snd} \\circ h":"y = \\text{snd} \\circ h","In fact, given an arrow from an arbitrary object $c$ to $a \\times b$, we can define, by composition, a pair of arrows $f \\colon c \\to a$ and $g \\colon c \\to b$":"사실, 임의의 객체 $c$에서 $a \\times b$로 가는 화살표가 주어진다면, 합성을 통해 화살표 쌍 $f \\colon c \\to a$와 $g \\colon c \\to b$를 정의할 수 있습니니다.","As we did before with the sum type, we can turn this idea around, and use this diagram to \\emph{define} the product type: We impose the condition that a pair of functions $f$ and $g$ be in one-to-one correspondence with a \\index{mapping in}\\emph{mapping in} from $c$ to $a \\times b$. This is the \\emph{introduction} rule for the product.":"이전에 합 타입과 함께 했던 것처럼, 이 아이디어를 뒤집어 사용하여 이 도표를 제품 타입을 \\emph{정의}하는 데 사용할 수 있습니다: 함수 $f$와 $g$의 쌍이 $c$에서 $a \\times b$로의 \\index{mapping in}\\emph{mapping in}과 일대일 대응 관계에 있음을 조건으로 합니다. 이것이 제품의 \\emph{도입} 규칙입니다.","In particular, the mapping out of the terminal object is used in Haskell to define a product type. Given two elements, \\hask{a :: A} and \\hask{b :: B}, we construct the product":"특히, 터미널 객체(terminal object)로의 사상(mapping out)은 Haskell에서 곱 타입(product type)을 정의하는데 사용됩니다. 두 요소 \\hask{a :: A}와 \\hask{b :: B}가 주어졌을 때, 우리는 그 곱을 구성합니다.","The built-in syntax for products is just that: a pair of parentheses and a comma in between. It works both for defining the product of two types \\hask{(A, B)} and the data constructor \\hask{(a, b)} that takes two elements and pairs them together.":"내장 구문은 단지 그것: 괄호 한 쌍과 중간의 쉼표입니다. 이는 두 타입의 곱 \\hask{(A, B)}를 정의하는 것과 두 요소를 받아서 짝을 짓는 데이터 생성자 \\hask{(a, b)} 모두에 대해 작동합니다.","We should never lose sight of the purpose of programming: to decompose complex problems into a series of simpler ones. We see it again in the definition of the product. Whenever we have to construct a mapping \\emph{into} the product, we decompose it into two smaller tasks of constructing a pair of functions, each mapping into one of the components of the product. This is as simple as saying that, in order to implement a function that returns a pair of values, it's enough to implement two functions, each returning one of the elements of the pair.":"프로그래밍의 목적을 절대 잊어서는 안 됩니다: 복잡한 문제를 일련의 더 간단한 문제로 분해하는 것입니다. 우리는 이를 곱(product)의 정의에서도 다시 볼 수 있습니다. 곱으로 \\emph{매핑(mapping)}을 구성해야 할 때마다, 이를 곱의 요소 중 하나로 매핑하는 두 개의 함수 쌍을 구성하는 작은 작업 두 개로 분해합니다. 이는 두 개의 값을 반환하는 함수를 구현하려면, 쌍(pair)의 요소 각각을 반환하는 두 개의 함수를 구현하는 것으로 충분하다는 말과 같습니다.","In logic, a product type corresponds to logical conjunction. In order to prove $A \\times B$ ($A$ and $B$), you need to provide the proofs of \\emph{both} $A$ and $B$. These are the arrows targeting $A$ and $B$. The elimination rule says that if you have a proof of $A \\times B$, then you automatically get the proof of $A$ (through $\\text{fst}$) and the proof of $B$ (through $\\text{snd}$).":"논리학에서, 곱형(product type)은 논리적 결합(logical conjunction)에 해당합니다. $A \\times B$ ($A$ 와 $B$)를 증명하려면 \\emph{둘 다} $A$ 와 $B$의 증명을 제공해야 합니다. 이것들이 $A$와 $B$를 대상으로 하는 화살표입니다. 소거 규칙(elimination rule)은 $A \\times B$의 증명을 가지고 있다면 자동으로 $A$의 증명($\\text{fst}$를 통해)과 $B$의 증명($\\text{snd}$를 통해)을 얻을 수 있다고 합니다.","As Lao Tzu would say, a product of ten thousand objects is just an object with ten thousand projections.":"노자의 말처럼, 만 가지 물체의 곱(product)은 단지 만 가지 투영으로 이루어진 하나의 물체입니다.","We can form arbitrary products in Haskell using the tuple notation. For instance, a product of three types is written as \\hask{(A, B, C)}. A term of this type can be constructed from three elements: \\hask{(a, b, c)}.":"Haskell에서는 튜플 표기법을 사용해 임의의 곱(product)을 형성할 수 있습니다. 예를 들어, 세 가지 타입의 곱은 \\hask{(A, B, C)}로 작성됩니다. 이 타입의 항(term)은 세 가지 요소로부터 \\hask{(a, b, c)}로 구성될 수 있습니다.","In what mathematicians call ``abuse of notation'', a product of zero types is written as \\hask{()}, an empty tuple, which happens to be the same as the terminal object, or unit type. This is because the product behaves very much like multiplication of numbers, with the terminal object playing the role of one.":"수학자들이 ``표기 악용''이라고 부르는 방식으로, 0개의 타입의 곱은 공튜플(())으로 작성되며, 이는 우연히도 종말 대상(terminal object) 또는 단위 타입(unit type)과 동일합니다. 이는 곱셈이 숫자의 곱셈과 매우 유사하게 작동하기 때문인데, 이때 종말 대상이 1의 역할을 합니다.","In Haskell, rather than defining separate projections for all tuples, we use the pattern-matching syntax. For instance, to extract the third component from a triple we would write":"Haskell에서 우리는 모든 튜플에 대한 별도의 사영을 정의하는 대신 패턴 매칭 문법을 사용합니다. 예를 들어, 트리플에서 세 번째 요소를 추출하기 위해 다음과 같이 작성합니다.","We use wildcards for the components that we want to ignore.":"구성 요소(component) 중 무시하고 싶은 부분에는 와일드카드(wildcard)를 사용합니다.","Lao Tzu said that ``Naming is the origin of all particular things.'' In programming, keeping track of the meaning of the components of a particular tuple is difficult without giving them names. Record syntax allows us to give names to projections. This is the definition of a product written in record style:":"Lao Tzu가 말하길, ``이름 붙이기는 모든 특정한 것들의 기원이다.''라고 했습니다. 프로그래밍에서 특정한 튜플의 구성 요소들의 의미를 파악하기는 이름을 붙이지 않으면 어렵습니다. 레코드(record) 구문을 사용하면 투영(projection)에 이름을 붙일 수 있습니다. 이것이 레코드 스타일로 작성된 곱(product)의 정의입니다:","\\hask{Pair} is the data constructor and \\hask{fst} and \\hask{snd} are the projections.":"\\hask{Pair}는 데이터 생성자(data constructor)이고 \\hask{fst}와 \\hask{snd}는 프로젝션(projections)입니다.","This is how it could be used to declare and initialize a particular pair:":"이것은 특정한 쌍(pair)을 선언하고 초기화하는 방법입니다:","In Haskell, we can define a product of any two types. A category in which all products exist, and the terminal object exists, is called \\emph{cartesian}.":"하스켈(Haskell)에서 우리는 임의의 두 타입의 곱을 정의할 수 있습니다. 모든 곱이 존재하고 끝 대상(terminal object)이 존재하는 범주를 \\emph{cartesian}이라고 합니다.","The identities satisfied by the product can be derived using the mapping-in property. For instance, to show that $a \\times b \\cong b \\times a$ consider the following two diagrams:":"소스와의 대응에 의해 곱이 만족하는 아이덴티티(identity)들을 유도할 수 있습니다. 예를 들어, $a \\times b \\cong b \\times a$를 증명하기 위해 다음 두 개의 다이어그램을 고려하십시오.","They show that, for any object $x$ the arrows to $a \\times b$ are in one-to-one correspondence with arrows to $b \\times a$. This is because each of these arrows is determined by the same pair $f$ and $g$.":"그들은 어떠한 객체 $x$에 대해 $a \\times b$로의 화살표가 $b \\times a$로의 화살표와 일대일 대응 관계에 있음을 보여줍니다. 이는 이러한 화살표 각각이 동일한 쌍 $f$와 $g$에 의해 결정되기 때문입니다.","You can check that the naturality condition is satisfied because, when you shift the perspective using $k \\colon x' \\to x$, all arrows originating in $x$ are shifted by pre-composition $(- \\circ k)$.":"자연성 조건이 충족되는지 확인할 수 있는데, 이는 $k \\colon x' \\to x$를 사용하여 관점을 이동할 때, $x$에서 시작하는 모든 화살표들이 사전 구성 $(- \\circ k)$에 의해 이동되기 때문입니다.","In Haskell, this isomorphism can be implemented as a function which is its own inverse:":"Haskell에서, 이러한 동형사상(isomorphism)은 자기 자신의 역함수(inverse)인 함수로 구현될 수 있습니  다:","Here's the same function written using pattern matching:":"Here's the same function written using pattern matching:여기 패턴 매칭을 사용하여 작성된 같은 함수가 있습니다:","It's important to keep in mind that the product is symmetric only ``up to isomorphism.'' It doesn't mean that swapping the order of pairs won't change the behavior of a program. Symmetry means that the information content of a swapped pair is the same, but access to it needs to be modified.":"제품이 대칭적임을 명심하는 것이 중요합니다. 이는 ``동형사상 (isomorphism)만큼만'' 대칭적이라는 뜻입니다. 순서쌍의 순서를 바꾸어도 프로그램의 동작이 변하지 않는다는 의미는 아닙니다. 대칭성은 바뀐 순서쌍의 정보 내용이 동일하다는 것을 의미하지만, 접근 방식은 수정이 필요합니다.","The terminal object is the unit of the product, $1 \\times a \\cong a$. The arrow that witnesses the isomorphism between $1 \\times a$ and $a$ is called the \\emph{left unitor}:":"단말 객체는 곱(Product)의 단위(unit)로, $1 \\times a \\cong a$를 만족합니다. $1 \\times a$와 $a$ 사이의 동형사상을 증명하는 화살표(arrow)를 \\emph{좌단위원(left unitor)}이라고 합니다.","\\lambda \\colon 1 \\times a \\to a":"\\lambda \\colon 1 \\times a \\to a","It can be implemented as $\\lambda = \\text{snd}$. Its inverse $\\lambda^{-1}$ is defined as the unique arrow in the following diagram:":"다음과 같이 구현할 수 있습니다: $\\lambda = \\text{snd}$. 그것의 역함수 \\(\\lambda^{-1}\\)는 다음 다이어그램에서 유일한 화살표로 정의됩니다:","The arrow from $a$ to $1$ is called \\index{!}$!$ (pronounced, \\emph{bang}). This indeed shows that":"$a$에서 $1$로 가는 화살표는 \\index{!}$!$ (발음은, \\emph{뱅})이라고 불립니다. 이는 정말로","\\text{snd} \\circ \\lambda^{-1} = \\text{id}":"\\text{snd} \\circ \\lambda^{-1} = \\text{id}","We still have to prove that $\\lambda^{-1}$ is the left inverse of $\\text{snd}$. Consider the following diagram:":"우리는 $\\lambda^{-1}$가 $\\text{snd}$의 왼쪽 역원이라는 것을 증명해야 합니다. 다음의 다이어그램을 고려하세요:","It obviously commutes for $h = id$. It also commutes for $h = \\lambda^{-1}  \\circ  \\text{snd}$, because we have:":"당연히 $h = id$에 대해 교환합니다. $h = \\lambda^{-1}  \\circ  \\text{snd}$에 대해서도 교환합니다. 왜냐하면 우리는 다음과 같습니다:","\\text{snd} \\circ \\lambda^{-1}  \\circ  \\text{snd} = \\text{snd}":"\\text{snd} \\circ \\lambda^{-1}  \\circ  \\text{snd} = \\text{snd}","Since $h$ is supposed to be unique, we conclude that:":"$h$가 유일하다고 가정하기 때문에, 우리는 다음과 같이 결론을 내립니다:","\\lambda^{-1}  \\circ  \\text{snd} = id":"\\lambda^{-1}  \\circ  \\text{snd} = id","This kind of reasoning with universal constructions is pretty standard.":"이러한 보편적 구성(universal constructions)으로의 추론(reasoning)은 매우 일반적입니다.","Here are some other isomorphisms written in Haskell (without proofs of having the inverse). This is associativity:":"다음은 Haskell로 작성된 몇 가지 다른 동형사상입니다 (역함수를 가지는 증명 없이). 이는 결합 법칙입니다:","And this is the right unit":"그리고 이것은 오른쪽 유닛(unit)입니다.","These two functions correspond to the \\index{associator}\\emph{associator}":"이 두 함수는 \\index{associator}\\emph{결합자}에 해당합니다.","\\alpha \\colon (a \\times b) \\times c \\to a \\times (b \\times c)":"\\alpha \\colon (a \\times b) \\times c \\to a \\times (b \\times c)","and the \\index{unitor}\\emph{right unitor}:":"and the \\index{단위자}\\emph{오른쪽 단위자}:","\\rho \\colon a \\times 1 \\to a":"\\rho \\colon a \\times 1 \\to a","Suppose that we have arrows that map $a$ and $b$ to some $a'$ and $b'$:":"화살표가 $a$와 $b$를 각각 $a'$와 $b'$로 사상한다고 가정하면:","The composition of these arrows with the projections $\\text{fst}$ and $\\text{snd}$, respectively, can be used to define the mapping $h$ between the products:":"이 화살표들은 각각 $\\text{fst}$와 $\\text{snd}$ 투영(projection)과 합성(composition)하여 곱셈(product) 사이의 매핑(mapping) $h$를 정의하는 데 사용할 수 있습니다:","The shorthand notation for this diagram is:":"이 다이어그램을 나타내는 축약 표기법은:","a \\times b \\xrightarrow{f \\times g} a' \\times b'":"a \\times b \\xrightarrow{f \\times g} a' \\times b'","This property of the product is called \\emph{functoriality}. You can imagine it as allowing you to transform the two objects \\emph{inside} the product to get the new product. We also say that functoriality lets us \\index{lifting}\\emph{lift} a pair of arrows in order to operate on products.":"This property of the product is called \\emph{함자성(functoriality)}. You can imagine it as allowing you to transform the two objects \\emph{곱(product)} 내에서 새로운 곱을 얻기 위해 변환시키는 것처럼 상상할 수 있다. We also say that \\index{lifting}\\emph{함자성}은 우리가 곱에 대해 작용하는 화살표(pair of arrows)를 \\emph{들어올리게(lift)} 한다고 말한다.","When a child sees an arrow, it knows which end points at the source, and which points at the target":"아이(Child)가 화살표(arrow)를 보면, 어느 쪽 끝이 출발점(source)을 가리키고 어느 쪽이 목표점(target)을 가리키는지 알게 됩니다.","a \\to b":"a \\to b","But maybe this is just a preconception. Would the Universe be very different if we called $b$ the source and $a$ the target?":"하지만 아마도 이것은 단지 편견일 것입니다. 만약 우리가 $b$를 원천(source)이라고 부르고 $a$를 목표(target)라고 부른다면, 우주는 매우 다를까요?","We would still be able to compose this arrow with this one":"우리는 여전히 이 화살표를 저 화살표와 합성할 수 있습니다.","b \\to c":"b \\to c","whose ``target'' $b$ is the same as the same as the ``source'' of $a \\to b$, and the result would still be an arrow":"``대상(target)'' $b$가 $a \\to b$의 ``원천(source)''과 동일한 경우, 그 결과는 여전히 하나의 화살표일 것입니다","a \\to c":"a \\to c","only now we would say that it goes from $c$ to $a$.":"지금에서야 우리는 그것이 $c$에서 $a$로 간다고 말할 것입니다.","In this dual Universe, the object that we call ``initial'' would be called ``terminal,'' because it's the ``target'' of unique arrows coming from all objects. Conversely, the terminal object would be called initial.":"이 이중 우주에서는 우리가 ``초기''라고 부르는 객체는 모든 객체로부터 오는 유일한 화살표의 ``목적지''이기 때문에 ``최종''이라고 불립니다. 반대로 최종 객체는 초기라고 불립니다.","Now consider this diagram that we used to define the sum object:":"이제 우리가 합 객체(sum object)를 정의하기 위해 사용한 이 도표를 고려해 보십시오:","In the new interpretation, the arrow $h$ would go ``from'' an arbitrary object $c$ ``to'' the object we call $a + b$. This arrow is uniquely defined by a pair of arrows $(f, g)$ whose ``source'' is $c$. If we rename $\\text{Left}$ to $\\text{fst}$ and $\\text{Right}$ to $\\text{snd}$, we will get  the defining diagram for a product.":"새로운 해석에서는, 화살표 $h$가 임의의 객체 $c$ ``로부터'' 우리가 $a + b$라고 부르는 객체 ``까지'' 이어지는 것으로 봅니다. 이 화살표는 ``출발점''이 $c$인 화살표 $(f, g)$ 쌍에 의해 고유하게 정의됩니다. 만약 $\\text{Left}$를 $\\text{fst}$로, $\\text{Right}$를 $\\text{snd}$로 바꾸면, 우리는 곱(product)의 정의 도표를 얻게 됩니다.","A product is the sum with arrows reversed.":"곱은 화살표가 반대로 된 합입니다.","Conversely, a sum is the product with arrows reversed.":"반대로, 합(sum)은 화살표가 반대인 곱(product)입니다.","Every construction in category theory has its dual.":"모든 구성(Construction)은 범주 이론(Category Theory)에서 그 이중(Dual)을 가집니다.","If the direction of arrows is just a matter of interpretation, then what makes sum types so different from product types, in programming? The difference goes back to one assumption we made at the start: There are no incoming arrows to the initial object (other than the identity arrow). This is in contrast with the terminal object having lots of outgoing arrows, arrows that we used to define (global) elements. In fact, we assume that every object of interest has elements, and the ones that don't are isomorphic to \\hask{Void}.":"화살표 방향이 단지 해석의 문제라면, 프로그래밍에서 합 타입(영문: sum types)과 곱 타입(영문: product types)의 차이는 무엇인가요? 그 차이는 우리가 처음에 가정한 한 가지 가정으로 돌아갑니다: 초기 객체(영문: initial object)에는 (동일성 화살표 외에) 들어오는 화살표가 없다는 것입니다. 이는 종단 객체(영문: terminal object)에는 많은 나가는 화살표가 있다는 것과 대조됩니다. 우리는 이러한 나가는 화살표들을 (전역) 요소 정의에 사용했습니다. 사실, 우리는 관심 있는 모든 객체가 요소를 가지며, 가지지 않는 것들은 \\hask{Void}와 동형(영문: isomorphic)이라고 가정합니다.","We'll see an even deeper difference when we talk about function types.":"함수 타입에 대해 이야기할 때 더 깊은 차이점을 보게 될 것입니다.","We have seen that the product satisfies these simple rules:":"우리는 그 곱이 다음의 간단한 규칙들을 만족함을 보았습니다:","and is functorial.":"그리고 이는 함자적(functorial)입니다.","A category in which an operation with these properties is defined is called \\emph{symmetric monoidal}\\footnote{Strictly speaking, a product of two objects is defined up to isomorphism, whereas the product in a monoidal category must be defined on the nose. But we can get a monoidal category by making a choice of a product}. We've seen a similar structure before, when working with sums and the initial object.":"이러한 성질을 가진 연산이 정의된 범주를 \\emph{대칭 모노이드 범주}(symmetric monoidal)라고 합니다\\footnote{엄밀히 말하면, 두 객체의 곱은 동형사상에 따라서 정의되지만, 모노이드 범주에서의 곱은 정확히 정의되어야 합니다. 하지만 우리는 하나의 곱을 선택함으로써 모노이드 범주를 얻을 수 있습니다}. 우리는 합과 초기 객체를 다룰 때 유사한 구조를 본 적이 있습니다.","A category can have multiple monoidal structures at the same time. When you don't want to name your monoidal structure, you replace the plus sign or the product sign with a tensor sign, and the neutral element with the letter $I$. The rules of a symmetric monoidal category can then be written as:":"카테고리는 동시에 여러 모노이드 구조를 가질 수 있습니다. 모노이드 구조에 이름을 붙이고 싶지 않을 때는 더하기 기호(+)나 곱하기 기호(×)를 텐서 기호(⊗)로 대체하고, 중립 원소를 문자 $I$로 대체합니다. 대칭 모노이드 카테고리의 규칙들은 다음과 같이 쓸 수 있습니다:","These isomorphisms are often written as families of invertible arrows called \\index{associator}associators and \\index{unitor}unitors. If the monoidal category is not symmetric, there is a separate left and right unitor.":"이 이성질체(isomorphisms)들은 종종 \\index{associator}결합자(associators) 및 \\index{unitor}단위자(unitors)라는 가역적인 화살표의 집합으로 작성됩니다. 모노이달 카테고리가 대칭이지 않다면, 왼쪽 단위자와 오른쪽 단위자가 분리되어 있습니다.","The symmetry is witnessed by:":"대칭은 다음과 같이 드러납니다:","\\gamma \\colon a \\otimes b \\to b \\otimes a":"\\gamma \\colon a \\otimes b \\to b \\otimes a","Functoriality lets us \\emph{lift} a pair of arrows:":"함자성(Functoriality)은 우리가 쌍의 화살표들을 \\emph{끌어올릴} 수 있게 해줍니다:","to operate on tensor products:":"텐서 곱에 대해 작용하기:","a \\otimes b \\xrightarrow{f \\otimes g} a' \\otimes b'":"a \\otimes b \\xrightarrow{f \\otimes g} a' \\otimes b'","If we think of morphisms as actions, their tensor product corresponds to performing two actions in parallel. Contrast this with the serial composition of morphisms, which suggests their temporal ordering.":"사상들을 동작으로 생각해 본다면, 이들의 텐서곱(tensor product)은 두 동작이 병렬로 수행되는 것에 해당합니다. 이는 사상들의 연속적 합성(serial composition)과 대조되며, 이는 시간적 순서를 암시합니다.","You may think of a tensor product as the lowest common denominator of product and sum. It still has an introduction rule, which requires both objects $a$ and $b$; but it has no elimination rule. Once created, a tensor product ``forgets'' how it was created. Unlike a cartesian product, it has no projections.":"텐서곱(tensor product)을 곱(product)과 합(sum)의 최소 공약수로 생각할 수 있습니 다. 여전히 소개 규칙( introduction rule)을 가지며, 이는 두 객체(object) $a$ 와 $b$ 를 필요로 합니다; 그러나 제거 규칙(elimination rule)은 없습니다. 한 번 생성되면, 텐서곱은 어떻게 생성되었는지를 ``잊어버립니다.'' 데카르트 곱(cartesian product)과는 달리, 투영(projections)이 없습니다.","Some interesting examples of tensor products are not even symmetric.":"일부 텐서곱(tensor products)에는 대칭(symmetry)이 없는 흥미로운 예들이 있습니니다.","Monoids are very simple structures equipped with a binary operation and a unit. Natural numbers with addition and zero form a monoid. So do natural numbers with multiplication and one.":"Monoids는 이항 연산 및 유닛을 갖춘 매우 간단한 구조입니다. 덧셈과 0을 갖는 자연수는 \\textit{monoid}를 형성합니다. 곱셈과 1을 갖는 자연수도 마찬가지입니다.","The intuition is that a monoid lets you combine two things to get another thing. There is also one special thing, such that combining it with anything else gives back the same thing. That's the unit. And the combining must be associative.":"직관적으로 설명하자면, 모노이드(monoid)는 두 개의 것을 결합하여 또 다른 것을 얻을 수 있게 합니다. 또한 하나의 특별한 것이 있어서, 그것을 다른 어떤 것과 결합해도 원래의 같은 것을 반환합니다. 그것이 유닛(unit)입니다. 그리고 결합 연산은 결합 법칙(associative)을 따라야 합니다.","What's not assumed is that the combining is symmetric, or that there is an inverse element.":"조합이 대칭적이라는 것과 역원(역원, inverse element)이 존재한다는 것은 가정되지 않습니다.","The rules that define a monoid are reminiscent of the rules of a category. The difference is that, in a monoid, any two things are composable, whereas in a category this is usually not the case: You can only compose two arrows if the target of one is the source of another. Except, that is, when the category contains only one object, in which case all arrows are composable.":"모노이드를 정의하는 규칙들은 범주의 규칙들을 연상케 합니다. 차이점은, 모노이드에서는 어떤 두 개의 것이라도 합성 가능하지만, 범주에서는 일반적으로 그렇지 않다는 점입니다: 하나의 화살표의 목표(target)가 다른 하나의 출발지(source)일 때만 두 개의 화살표를 합성할 수 있습니다. 범주에 오직 하나의 객체(object)만 포함되어 있는 경우를 제외하면, 이 때는 모든 화살표들이 합성 가능합니다.","A category with a single object is called a monoid. The combining operation is the composition of arrows and the unit is the identity arrow.":"하나의 객체(object)만 가진 범주(category)는 모노이드(monoid)라고 합니다. 결합 연산은 화살표(arrows)의 합성(composition)이고, 단위원(unit)은 항등 화살표(identity arrow)입니다.","This is a perfectly valid definition. In practice, however, we are often interested in monoids that are embedded in larger categories. In particular, in programming, we want to be able to define monoids inside the category of types and functions.":"이는 완벽히 유효한 정의입니다. 그러나 실제로는 더 큰 카테고리에 포함된 모노이드에 관심이 있는 경우가 많습니다. 특히 프로그래밍에서는 타입과 함수의 카테고리 내에서 모노이드를 정의할 수 있기를 원합니다.","However, in a category, rather than looking at individual elements, we prefer to define operations in bulk. So we start with an object $m$. A binary operation is a function of two arguments. Since elements of a product are pairs of elements, we can characterize a binary operation as an arrow from a product $m \\times m$ to $m$:":"그러나, 카테고리 이론에서는 개별 요소들보다는 일괄적으로 연산을 정의하는 것을 선호합니다. 따라서 우리는 객체 $m$으로 시작합니다. 이항 연산은 두 개의 인자를 가지는 함수입니다. 곱셈의 요소는 두 요소의 쌍이기 때문에, 이항 연산은 $m \\times m$에서 $m$으로의 화살(arrow)로 특징지을 수 있습니다:","\\mu \\colon m \\times m \\to m":"\\mu \\colon m \\times m \\to m","The unit element can be defined as an arrow from the terminal object $1$:":"단위 원소는 종점 객체 $1$에서 화살표로 정의될 수 있습니:","\\eta \\colon 1 \\to m":"\\eta \\colon 1 \\to m","We can translate this description directly to Haskell by defining a \\index{type class}class of types equipped with two methods, traditionally called \\hask{mappend} and \\hask{mempty}:":"우리는 이 설명을 Haskell에 직접 변환할 수 있습니다. 두 가지 메서드를 갖춘 유형(type) \\index{type class}클래스를 정의하여, 전통적으로 \\hask{mappend}와 \\hask{mempty}라고 불립니다:","The two arrows $\\mu$ and $\\eta$ have to satisfy monoid laws but, again, we have to formulate them in bulk, without any recourse to elements.":"두 사상 $\\mu$와 $\\eta$는 모노이드 법칙을 만족해야 하지만, 다시 한 번, 우리는 요소에 의지하지 않고 일괄적으로 이를 공식화해야 합니다.","To formulate the left unit law, we first create the product $1 \\times m$. We then use $\\eta$ to ``pick the unit element in $m$'' or, in terms of arrows, turn $1$ into $m$. Since we are operating on a product $1 \\times m$, we have to lift the pair $\\langle \\eta, id_m \\rangle$, which ensures that we ``do not touch'' the $m$. Finally we perform the ``multiplication'' using $\\mu$.":"왼쪽 단위원 법칙을 제정하기 위해, 먼저 곱 $1 \\times m$을 만듭니다. 그런 다음 $\\eta$를 사용하여 \"m에서 단위원 요소를 선택\"하거나, 화살표(arrow)로 표현하면 $1$을 $m$으로 바꿉니다. 곱 $1 \\times m$에서 작동하고 있으므로, $\\langle \\eta, id_m \\rangle$ 쌍을 들어 올려서 $m$을 \"터치하지 않도록\" 해야 합니다. 마지막으로 $\\mu$를 사용하여 \"곱셈\"을 수행합니다.","We want the result to be the same as the original element of $m$, but without mentioning elements. So we just use the left unitor $\\lambda$ to go from $1 \\times m$ to $m$ without ``stirring things up.''":"우리는 결과가 원래의 $m$ 요소와 동일하길 원하지만 요소를 언급하지 않길 원합니다. 그래서 우리는 아무 것도 건드리지 않고 $1 \\times m$에서 $m$으로 가기 위해 좌단위자 $\\lambda$를 사용합니다.","Here is the analogous law for the right unit:":"다음은 오른쪽 단위에 대한 유사한 법칙입니다:","To formulate the law of associativity, we have to start with a triple product and act on it in bulk. Here, $\\alpha$ is the associator that rearranges the product without ``stirring things up.''":"결합 법칙(associativity 법칙)을 공식화하려면, 우리는 세 곱셈 항에서 시작하여 전체적으로 작용해야 합니다. 여기서, $\\alpha$는 곱셈을 ``섞지 않고(stirring things up)'' 재배열하는 결합자(associator)입니다.","Notice that we didn't have to assume a lot about the categorical product that we used with the objects $m$ and $1$. In particular we never had to use projections. This suggests that the above definition will work equally well for a tensor product in an arbitrary monoidal category. It doesn't even have to be symmetric. All we have to assume is that: there is a unit object, that the product is functorial, and that it satisfies the unit and associativity laws up to isomorphism.":"우리가 객체 $m$과 $1$과 함께 사용한 범주적곱(categorical product)에 대해 많은 것을 가정할 필요가 없었다는 것을 주의하세요. 특히 사영(projections)을 사용할 필요가 없었습니다. 이는 위 정의가 임의의 모노이달 범주에 있는 텐서곱(tensor product)에도 동일하게 잘 작동할 것이라는 것을 시사합니다. 대칭적일 필요도 없습니다. 우리가 가정해야 할 것은: 단위 객체가 있으며, 곱이 함자적이고(functorial), 단위와 결합 법칙이 동형사상까지 만족한다는 것입니다.","Thus if we replace $\\times$ with $\\otimes$ and $1$ with $I$, we get a definition of a monoid in an arbitrary monoidal category.":"따라서 $\\times$를 $\\otimes$로, $1$을 $I$로 대체하면 임의의 모노이드 범주에서 모노이드의 정의를 얻게 됩니다.","A \\index{monoid}\\emph{monoid} in a monoidal category is an object $m$ equipped with two morphisms:":"A \\index{모노이드}\\emph{모노이드}는 모노이달 범주에서 두 가지 사상과 함께 주어지는 객체 $m$입니다:","\\mu \\colon m \\otimes m \\to m":"\\mu \\colon m \\otimes m \\to m","\\eta \\colon I \\to m":"\\eta \\colon I \\to m","satisfying the unit and associativity laws:":"단위(unit)와 결합 법칙(associativity laws)을 만족시키면서:","We used the functoriality of $\\otimes$ to lift pairs of arrows, as in $\\eta \\otimes id_m$, $\\mu \\otimes id_m$, etc.":"우리는 $\\otimes$의 함자성(functoriality) 덕분에 화살의 쌍을 들어 올렸습니다. 예를 들어 $\\eta \\otimes id_m$, $\\mu \\otimes id_m$ 등입니다."}