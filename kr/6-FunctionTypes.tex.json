{"\\chapter{Function Types}":"\\chapter{함수 타입(Function Types)}","There is another kind of composition that is at the heart of functional programming. It happens when you pass a function as an argument to another function. The outer function can then use this argument as a pluggable part of its own machinery. It lets you implement, for instance, a generic sorting algorithm that accepts an arbitrary comparison function.":"다른 종류의 합성(composition)이 있는데, 이는 함수형 프로그래밍(functional programming)의 핵심입니다. 이는 하나의 함수를 다른 함수의 인자로 전달할 때 발생합니다. 외부 함수는 이 인자를 자신의 기계 장치(mechanism)의 플러그 가능한 부분으로 사용할 수 있습니다. 이를 통해 임의의 비교 함수(comparison function)를 받아들이는 일반적인 정렬 알고리즘(sorting algorithm)을 구현할 수 있습니다.","If we model functions as arrows between objects, then what does it mean to have a function as an argument?":"만약 우리가 함수들을 객체들 사이의 화살표(arrows)로 모델링한다면, 함수가 인수(argument)로 있다는 것은 무엇을 의미할까요?","We need a way to objectify functions in order to define arrows that have an ``object of arrows'' as a source or as a target. A function that takes a function as an argument or returns a function is called a \\emph{higher-order} function. Higher-order functions are the work-horses of functional programming.":"함수들을 객체화하는 방법이 필요합니다. 왜냐하면 화살표(arrow)들의 대상으로 ``화살표의 객체(object of arrows)''가 되는 것을 정의하기 위해서입니다. 함수를 인자로 받거나 함수를 반환하는 함수는 \\emph{고차 함수}(higher-order function)라고 부릅니다. 고차 함수들은 함수형 프로그래밍의 일꾼들입니다.","\\subsection{Elimination rule}":"\\subsection{제거 규칙(Elimination rule)}","The defining quality of a function is that it can be applied to an argument to produce the result. We have defined function application in terms of composition:":"함수의 정의 특징은 인수를 적용하여 결과를 생성할 수 있다는 것입니다. 우리는 구성을 통해 함수 적용을 정의했습니다:","Here $f$ is represented as an arrow from $a$ to $b$, but we would like to be able to replace $f$ with an element of the object of arrows or, as mathematicians call it, the exponential object $b^a$; or as we call it in programming, a function type \\hask{a->b}.":"여기서 $f$는 $a$에서 $b$로 가는 화살표로 표현되었지만, 우리는 $f$를 화살표 객체의 요소로 대체하거나, 수학자들이 말하는 지수 객체 $b^a$로 대체하고 싶습니다; 또는 프로그래밍에서 함수형 \\hask{a->b}이라고 부릅니다.","Given an element of $b^a$ and an element of $a$, function application should produce an element of $b$. In other words, given a pair of elements:":"$b^a$의 한 요소와 $a$의 한 요소가 주어지면 함수 적용(function application)은 $b$의 한 요소를 생성해야 합니다. 다시 말해, 한 쌍의 요소가 주어지면:","it should produce an element:":"그것은 하나의 요소(element)를 생성해야 합니다.\n","y \\colon 1 \\to b":"y \\colon 1 \\to b","Keep in mind that, here, $f$ denotes an element of $b^a$. Previously, it was an arrow from $a$ to $b$.":"여기서 $f$는 $b^a$의 요소를 나타냅니다. 이전에는 $a$에서 $b$로 가는 화살표였습니다.","We know that a pair of elements $(f, x)$ is equivalent to an element of the product $b^a \\times a$. We can therefore define function application as a single arrow:":"우리는 $(f, x)$ 쌍의 요소가 곱셈 $b^a \\times a$의 요소와 동등함을 알고 있습나다. 따라서 함수 적용을 하나의 화살표로 정의할 수 있습니다:","\\varepsilon_{a b} \\colon b^a \\times a \\to b":"\\varepsilon_{a b} \\colon b^a \\times a \\to b","This way $y$, the result of the application, is defined by this commuting diagram:":"이 방식으로 $y$, 적용의 결과가 아래의 가환 도표에 의해 정의됩니다:","Function application is the \\emph{elimination rule} for function type.":"함수 적용은 함수 타입을 위한 \\emph{제거 규칙}(elimination rule)입니다.","When somebody gives you an element of the function object, the only thing you can do with it is to apply it to an element of the argument type using $\\varepsilon$.":"누군가가 당신에게 함수 객체의 원소를 주면, 할 수 있는 유일한 일은 그것을 $\\varepsilon$을 사용해 인수 타입의 원소에 적용하는 것입니다.","\\subsection{Introduction rule}":"\\subsection{소개 규칙(Introduction rule)}","To complete the definition of the function object, we also need the introduction rule.":"함수 객체(function object)의 정의를 완성하기 위해, 우리는 또한 도입 규칙(introduction rule)이 필요합니다.","First, suppose that there is a way of constructing a function object $b^a$ from some other object $c$. It means that there is an arrow":"먼저, 어떤 다른 객체 $c$로부터 함수 객체 $b^a$를 구성하는 방법이 있다고 가정하겠음니다. 이는 화살표가 있다는 것을 의미함니다","h \\colon c \\to b^a":"h \\colon c \\to b^a","We know that we can eliminate the result of $h$ using $\\varepsilon_{a b}$, but we have to first multiply it by $a$. So let's first multiply $c$ by $a$ and the use functoriality to map it to $b^a \\times a$.":"우리는 $\\varepsilon_{a b}$을 사용하여 $h$의 결과를 제거할 수 있다는 것을 알고 있지만, 먼저 $a$를 곱해야 합니다. 따라서 먼저 $c$에 $a$를 곱한 다음 함자성을 사용하여 이를 $b^a \\times a$로 매핑합시다.","Functoriality lets us apply a pair of arrows to a product to get another product. Here, the pair of arrows is $(h, id_a)$ (we want to turn $c$ into $b^a$, but we're not interested in modifying $a$)":"함자성(Functoriality)은 우리가 곱(product)에 화살표쌍을 적용하여 또 다른 곱을 얻을 수 있게 해줍니다. 여기서 화살표쌍은 $(h, id_a)$입니다 (우리는 $c$를 $b^a$로 변환하려고 하지만, $a$를 수정하는 것에는 관심이 없습니다).","c \\times a \\xrightarrow{h \\times id_a} b^a \\times a":"c \\times a \\xrightarrow{h \\times id_a} b^a \\times a","We can now follow this with function application to get to $b$":"우리는 이제 함수 적용을 따라가 $b$에 도달할 수 있습니다.","c \\times a \\xrightarrow{h \\times id_a} b^a \\times a \\xrightarrow{\\varepsilon_{a b}} b":"c \\times a \\xrightarrow{h \\times id_a} b^a \\times a \\xrightarrow{\\varepsilon_{a b}} b","This composite arrow defines a mapping we'll call $f$:":"이 합성 화살표(composite arrow)는 우리가 $f$라고 부를 매핑(mapping)을 정의합니다:","f \\colon c \\times a \\to b":"f \\colon c \\times a \\to b","Here's the corresponding diagram":"다음은 대응 다이어그램입니다.","This commuting diagram tells us that, given an $h$, we can construct an $f$; but we can also demand the converse: Every mapping out, $f \\colon c \\times a \\to b$, should uniquely define a mapping into the exponential, $h \\colon c \\to b^a$.":"이 교환 도표(commuting diagram)는, 주어진 $h$가 있을 때, $f$를 구성할 수 있음을 알려줍니다; 또한 우리는 역도 요구할 수 있습니다: 모든 출발하는 사상(mapping out), $f \\colon c \\times a \\to b$는 지수함수로의 사상(mapping into the exponential), $h \\colon c \\to b^a$를 유일하게 정의해야 합니다.","We can use this property, this one-to-one correspondence between two sets of arrows, to define the exponential object. This is the \\emph{introduction rule} for the function object $b^a$.":"이 속성을 사용할 수 있습니다. 화살표 두 집합 사이의 일대일 대응을 사용하여 지수 객체를 정의할 수 있습니다. 이것은 함수 객체 $b^a$에 대한 \\emph{도입 규칙}입니다.","We've seen that product was defined using its mapping-in property. Function application, on the other hand, is defined as a \\emph{mapping out} of a product.":"우리는 곱(product)이 그 사상-인(mapping-in) 속성을 사용하여 정의된 것을 보았습니다. 반면에 함수 적용(function application)은 곱의 \\emph{사상-아웃(mapping out)}으로 정의됩니다.","\\subsection{Currying}":"\\subsection{커링(Currying)}","There are several ways of looking at this definition. One is to see it as an example of currying.":"이 정의를 보는 여러 가지 방법이 있습니\n다. 하나는 이를 커링(currying)의 예로 보는 것입니다.","So far we've been only considering functions of one argument. This is not a real limitation, since we can always implement a function of two arguments as a (single-argument) function from a product. The $f$ in the definition of the function object is such a function:":"지금까지 우리는 하나의 인수를 갖는 함수만을 고려해 왔습니다. 이것은 실제 한계가 아닙니다. 왜냐하면 우리는 항상 두 개의 인수를 갖는 함수를 하나의 인수만을 갖는 함수로 구현할 수 있기 때문입니다. 함수 객체(function object)의 정의에서 $f$는 그러한 함수입니다:","\\hask{h} on the other hand is a function that returns a function:":"\\hask{h} 반면에 함수( function )를 반환하는 함수( function )입니다:","Currying is the isomorphism between these two sets of arrows.":"Currying은 화살표 집합 사이의 동형사상(isomorphism)입니다.","This isomorphism can be represented in Haskell by a pair of (higher-order) functions. Since, in Haskell, currying works for any types, these functions are written using type variables---they are \\emph{polymorphic}:":"이 동형사상(isomorphism)은 한 쌍의 (고차) 함수들로 Haskell에서 표현될 수 있습니 다. Haskell에서는 커링(currying)이 어떤 타입에도 적용될 수 있기 때문에, 이 함수 들은 타입 변수들을 사용하여 작성됩니다. 다시 말해, 이 함수들은 \\emph{다형성(polymorphic)}를 가집니다:","In other words, the $h$ in the definition of the function object can be written as":"다시 말해, 함수 객체의 정의에 있는 $h$는 다음과 같이 쓸 수 있습니다","h = curry\\, f":"h = 커리(curry)\\, f","Of course, written this way, the types of \\hask{curry} and \\hask{uncurry} correspond to function objects rather than arrows. This distinction is usually glossed over because there is a one-to-one correspondence between the \\emph{elements} of the exponential and the \\emph{arrows} that define them. This is easy to see when we replace the arbitrary object $c$ with the terminal object. We get:":"물론, 이렇게 작성할 경우, \\hask{curry}와 \\hask{uncurry}의 타입(types)은 화살표(arrow)보다는 함수 객체(function objects)에 해당됩니 다. 이 구분은 일반적으로 신경 쓰지 않는데, 이는 지수(exponential)의 \\emph{원소(elements)}와 그것을 정의하는 \\emph{화살표(arrow)} 간의 일대일 대응이 있기 때문입니다. 이는 임의의 객체 $c$를 말단 객체(terminal object)로 대체할 때 쉽게 이해할 수 있습니다. 우리는 다음과 같이 얻습니다:","In this case, $h$ is an element of the object $b^a$, and $f$ is an arrow from $1 \\times a$ to $b$. But we know that $1 \\times a$ is isomorphic to $a$ so, effectively, $f$ is an arrow from $a$ to $b$.":"이 경우, $h$는 객체(object) $b^a$의 요소이고, $f$는 $1 \\times a$에서 $b$로 가는 화살표(arrow)입니다. 그러나 $1 \\times a$는 $a$와 동형(isomorphic)임을 알고 있으므로, $f$는 사실상 $a$에서 $b$로 가는 화살표입니다.","Therefore, from now on, we'll call an arrow \\hask{->} an arrow $\\to$, without making much fuss about it. The correct incantation for this kind of phenomenon is to say that the category is self-enriched.":"따라서, 이제부터 화살표 \\hask{->}를 화살표 $\\to$라고 부르겠습니다, 이에 대해 더 이상 신경 쓰지 않겠습니다. 이러한 현상에 대한 정확한 표현은 카테고리가 자기-강화(self-enriched)되었다고 말하는 것입니다.","We can write $\\varepsilon_{a b}$ as a Haskell function \\hask{apply}:":"$\\varepsilon_{a b}$를 Haskell 함수 \\hask{apply}로 작성할 수 있습니 다:","but it's just a syntactic trick: function application is built into the language: \\hask{f x} means \\hask{f} applied to \\hask{x}. Other programming languages require the arguments to a function to be enclosed in parentheses, not so in Haskell.":"하지만 이것은 단지 구문적인 요령일 뿐입니다: 함수 적용(function application)은 언어에 내장되어 있습니다: \\hask{f x}는 \\hask{f}가 \\hask{x}에 적용됨을 의미합니다. 다른 프로그래밍 언어는 함수의 인수(arguments)가 괄호로 둘러싸여 있어야 하지만, Haskell에서는 그렇지 않습니다.","Even though defining function application as a separate function may seem redundant, Haskell library does provide an infix operator \\hask{$} for that purpose:":"비록 함수 적용을 별도의 함수로 정의하는 것이 중복적으로 보일 수 있지만, Haskell 라이브러리는 이를 위한 접두사 연산자 \\hask{$}(달러 기호)를 제공합니다:","The trick, though, is that regular function application binds to the left, e.g., \\hask{f x y} is the same as \\hask{(f x) y}; but the dollar sign binds to the right, so that":"그러나 요령은 정규 함수 적용은 왼쪽으로 결합되지만, 예를 들어, \\hask{f x y}는 \\hask{(f x) y}와 동일합니다; 그러나 달러 기호는 오른쪽으로 결합되기 때문에","is the same as \\hask{f (g x)}. In the first example, \\hask{f} must be a function of (at least) two arguments; in the second, it could be a function of one argument.":"는 \\hask{f (g x)}와 동일합니다. 첫 번째 예제에서 \\hask{f}는 (최소한) 두 개의 인수를 가지는 함수여야 합니다; 두 번째 예제에서는 하나의 인수를 가지는 함수일 수 있습니다.","In Haskell, currying is ubiquitous. A function of two arguments is almost always written as a function returning a function. Because the function arrow \\hask{->} binds to the right, there is no need to parenthesize such types. For instance, the pair constructor has the signature:":"Haskell에서 커링(currying)은 어디에서나 보편적입니다. 두 인자의 함수는 거의 항상 함수를 반환하는 함수로 작성됩니다. 함수 화살표 \\hask{->}가 오른쪽으로 묶이기 때문에 이러한 타입을 괄호로 묶을 필요가 없습니다. 예를 들어, 쌍 생성자는 다음과 같은 시그니처를 갖습니다:","You may think of if as a function of two arguments returning a pair, or a function of one argument returning a function of one argument, \\hask{b->(a, b)}. This way it's okay to partially apply such a function, the result being another function. For instance, we can define:":"이를 두 개의 인수를 받아 쌍을 반환하는 함수나, 하나의 인수를 받아 하나의 인수를 반환하는 함수라고 생각할 수 있니다, \\hask{b->(a, b)}. 이렇게 하면 그러한 함수를 부분적으로 적용해도 괜찮고, 결과는 또 다른 함수가 됩니. 예를 들어, 우리는 다음과 같이 정의할 수 있습니:","\\subsection{Relation to lambda calculus}":"\\subsection{람다 계산법(lambda calculus)과의 관계}","Another way of looking at the definition of the function object is to interpret $c$ as the type of the environment in which $f$ is defined. In that case it's customary to call the environment $\\Gamma$. The arrow is interpreted as an expression that uses the variables defined in $\\Gamma$.":"함수를 객체로 정의하는 또 다른 방법은 $c$를 $f$가 정의된 환경의 타입으로 해석하는 것입니다. 그런 경우 환경을 $\\Gamma$로 부르는 것이 일반적입니다. 화살표는 $\\Gamma$에 정의된 변수를 사용하는 표현으로 해석됩니다.","Consider a simple example, the expression:":"단순한 예제, 표현식을 고려해 봅시다:","a x^2 + b x + c":"a x^2 + b x + c","You may think of it as being parameterized by a triple of real numbers $(a, b, c)$ and a variable $x$, taken to be, let's say, a complex number. The triple is an element of a product $\\mathbb{R} \\times \\mathbb{R} \\times \\mathbb{R}$. This product is the environment $\\Gamma$ for our expression.":"이를 실수 세 수 $(a, b, c)$의 삼중항과 변수 $x$로 매개변수화된 것으로 생각할 수 있습니디, 여기서 변수 $x$는 복소수라고 가정합시다. 이 삼중항은 곱집합 $\\mathbb{R} \\times \\mathbb{R} \\times \\mathbb{R}$의 한 요소입니다. 이 곱집합은 우리 표현식의 환경 $\\Gamma$입니다.","The variable $x$ is an element of $\\mathbb{C}$. The expression is an arrow from the product $\\Gamma \\times \\mathbb{C}$ to the result type (here, also $\\mathbb{C}$)":"변수 $x$는 $\\mathbb{C}$의 원소입니다. 이 표현은 제품 $\\Gamma \\times \\mathbb{C}$에서 결과 타입(여기서는 또한 $\\mathbb{C}$입니다)으로의 화살표입니다.","f \\colon \\Gamma \\times \\mathbb{C} \\to \\mathbb{C}":"f \\colon \\Gamma \\times \\mathbb{C} \\to \\mathbb{C}","This is a mapping-out from a product, so we can use it to construct a function object  $\\mathbb{C}^{\\mathbb{C}}$ and define a mapping $h \\colon \\Gamma \\to \\mathbb{C}^{\\mathbb{C}}$":"이것은 곱(product)으로부터의 매핑이므로, 함숫값 객체(function object) $\\mathbb{C}^{\\mathbb{C}}$를 구성하기 위해 이를 사용할 수 있으며 매핑 $h \\colon \\Gamma \\to \\mathbb{C}^{\\mathbb{C}}$를 정의할 수 있습니.","This new mapping $h$ can be seen as a constructor of the function object. The resulting function object represents all functions from $\\mathbb{C}$ to $\\mathbb{C}$ that have access to the environment $\\Gamma$; that is, to the triple of parameters $(a, b, c)$.":"이 새로운 매핑 $h$는 함수 객체의 생성자로 볼 수 있습니다. 결과적인 함수 객체는 $\\mathbb{C}$에서 $\\mathbb{C}$로의 모든 함수들을 나타내며, 이는 환경 $\\Gamma$에 접근할 수 있습니다. 즉, 파라미터의 삼중 $(a, b, c)$에 접근할 수 있습니다.","Corresponding to our original expression $a x^2 + b x + c$ there is a particular function in $\\mathbb{C}^{\\mathbb{C}}$ that we write as:":"우리의 원래 표현 $a x^2 + b x + c$ 에 해당하는 $\\mathbb{C}^{\\mathbb{C}}$ 안에는 다음과 같이 쓸 수 있는 특정 함수가 있습니다:","\\lambda x . \\,a x^2 + b x + c":"\\lambda x . \\,a x^2 + b x + c","or, in Haskell, with the \\index{backslash}backslash replacing $\\lambda$,":"또는, 하스켈(Haskell)에서는 $\\lambda$를 대체하는 \\index{backslash}백슬래시(backslash)를 사용하여,","The arrow $h \\colon \\Gamma \\to \\mathbb{C}^{\\mathbb{C}}$ is uniquely determined by the arrow $f$. This mapping produces a function that we call $\\lambda x . f$.":"화살표 $h \\colon \\Gamma \\to \\mathbb{C}^{\\mathbb{C}}$는 화살표 $f$에 의해 고유하게 결정됩니다. 이 매핑은 우리가 $\\lambda x . f$라고 부르는 함수를 생성합니다.","In general, the defining diagram for the function object becomes:":"일반적으로, 함수 객체(function object)에 대한 정의 다이어그램은 다음과 같습니다:","The environment $\\Gamma$ that provides free parameters for the expression $f$ is a product of multiple objects representing the types of the parameters (in our example, it was $\\mathbb{R} \\times \\mathbb{R} \\times \\mathbb{R}$).":"환경 $\\Gamma$ 는 표현식 $f$ 에 대해 자유 파라미터(프리 파라미터)들을 제공하며, 이는 파라미터들의 타입을 나타내는 여러 객체들의 곱이다 (우리의 예시에서는, 그것이 $\\mathbb{R} \\times \\mathbb{R} \\times \\mathbb{R}$ 이었다).","An empty environment is represented by the terminal object $1$, the unit of the product. In that case, $f$ is just an arrow $a \\to b$, and $h$ simply picks an element from the function object $b^a$ that corresponds to $f$.":"빈 환경은 곱의 단위인 종단 객체 $1$에 의해 표현됩니다. 이 경우 $f$는 단순히 화살표 $a \\to b$이며, $h$는 $f$에 대응하는 함수 객체 $b^a$에서 원소를 선택합니다.","It's important to keep in mind that, in general, a function object represents functions that depend on external parameters. Such functions are called \\index{closure}\\emph{closures}. Closures are functions that capture values from their environment.":"일반적으로 함수 객체는 외부 매개변수에 의존하는 함수를 나타낸다는 점을 염두에 두는 것이 중요합니다. 이러한 함수는 \\index{closure}\\emph{클로저(closures)}라고 불립니다. 클로저는 환경으로부터 값을 포착하는 함수입니다.","Here's our example translated to Haskell. Corresponding to $f$ we have an expression:":"다음은 Haskell로 번역된 우리의 예시입니다. $f$에 대응하는 표현식이 있습니다:","If we use \\hask{Double} to approximate $\\mathbb{R}$, our environment is a product \\hask{(Double, Double, Double)}. The type \\hask{Complex} is parameterized by another type---here we used \\hask{Double} again:":"만약 \\hask{Double}을(를) 사용하여 $\\mathbb{R}$을(를) 근사한다면, 우리의 환경은 \\hask{(Double, Double, Double)} 의 곱(product)입니다. \\hask{Complex} 타입은 다른 타입에 의해 매개변수화됩니다(parameterized)---여기서 우리는 다시 \\hask{Double}을(를) 사용했습니다:","The conversion from \\hask{Double} to \\hask{C} is done by setting the imaginary part to zero, as in \\hask{(a :+ 0)}.":"\\hask{Double}에서 \\hask{C}로의 변환은 허수 부분을 0으로 설정하여 수행됩니다. 예를 들어 \\hask{(a :+ 0)}와 같이 합니다.","The corresponding arrow $h$ takes the environment and produces a closure of the type \\hask{C -> C}:":"대응하는 화살표 $h$는 환경을 받아 \\hask{C -> C} 타입의 클로저를 생성합니다:","\\subsection{Modus ponens}":"\\subsection{Modus ponens (모두스 포넨스)}","In logic, the function object corresponds to an implication. An arrow from the terminal object to the function object is the proof of that implication. Function application $\\varepsilon$ corresponds to what logicians call \\emph{modus ponens}: if you have a proof of the implication $A \\Rightarrow B$ and a proof of $A$ then this constitutes the proof of $B$.":"논리학에서 함수 객체(function object)는 함의(implication)에 해당합니다. 최종 객체(terminal object)에서 함수 객체로의 화살표는 그 함의의 증명입니다. 함수 적용 $\\varepsilon$은 논리학자들이 \\emph{modus ponens}라고 부르는 것에 해당합니다: 만약 $A \\Rightarrow B$의 증명과 $A$의 증명을 가지고 있다면 이는 $B$의 증명을 구성합니다.","\\section{Sum and Product Revisited}":"\\section{합과 곱 재검토}","When functions gain the same status as elements of other types, we have the tools to directly translate diagrams into code.":"함수들이 다른 유형의 요소들과 동일한 지위를 가지게 되면, 다이어그램(diagram)을 코드로 직접 변환할 수 있는 도구들을 가지게 됩니다.","\\subsection{Sum types}":"\\subsection{합 타입(Sum types)}","Let's start with the definition of the sum.":"합의 정의(Definition of the sum)부터 시작합시다.","We said that the pair of arrows $(f, g)$ uniquely determines the mapping $h$ out of the sum. We can write it concisely using a higher-order function:":"우리는 화살표(f, g)의 쌍이 합에서의 사상 h를 고유하게 결정한다고 말했다. 이를 고차 함수(higher-order function)를 사용하여 간결하게 쓸 수 있습니다:","where:":"어디:","This function takes a pair of functions as an argument and it returns a function.":"이 함수는 두 함수의 쌍을 인수로 받아들여 하나의 함수를 반환합니다.","First, we pattern-match the pair \\hask{(f, g)} to extract \\hask{f} and \\hask{g}. Then we construct a new function using a lambda. This lambda takes an argument of the type \\hask{Either a b}, which we call \\hask{aorb}, and does the case analysis on it. If it was constructed using \\hask{Left}, we apply \\hask{f} to its contents, otherwise we apply \\hask{g}.":"먼저, 우리는 쌍 \\hask{(f, g)}을 패턴 매칭하여 \\hask{f}와 \\hask{g}를 추출합니다. 그런 다음 람다를 사용하여 새로운 함수를 구성합니다. 이 람다는 \\hask{Either a b} 타입의 인수 \\hask{aorb}를 받아서 케이스 분석을 수행합니다. 만약 \\hask{Left}를 사용하여 구성되었다면, 그 내용에 \\hask{f}를 적용하고, 그렇지 않으면 \\hask{g}를 적용합니다.","Note that the function we are returning is a closure. It captures \\hask{f} and \\hask{g} from its environment.":"함수가 클로저(closure)로 반환된다는 점에 유의하십시오. 이는 환경에서 \\hask{f}와 \\hask{g}를 캡처합니다.","The function we have implemented closely follows the diagram, but it's not written in the usual Haskell style. Haskell programmers prefer to curry functions of multiple arguments. Also, if possible, they prefer to eliminate lambdas.":"우리가 구현한 함수는 다이어그램을 충실히 따르고 있으나, 일반적인 Haskell 스타일로 작성되지는 않았습니다. Haskell 프로그래머들은 여러 개의 인수를 갖는 함수들을 커리(curry)하는 것을 선호합니다. 또한, 가능하다면 람다(lambda)도 제거하는 것을 선호합니다.","Here's the version of the same function taken from the Haskell standard library, where it goes under the name (lower-case) \\hask{either}:":"다음은 Haskell 표준 라이브러리에서 \\hask{either}(이더)라는 이름으로 제공되는 동일한 함수의 버전입니다:","The other direction of the bijection, from $h$ to the pair $(f, g)$, also follows the arrows of the diagram.":"다른 방향의 전단사(bijection), $h$에서 쌍 $(f, g)$로의 경우 또한 도표의 화살표를 따릅니다.","\\subsection{Product types}":"\\subsection{곱 타입(Product types)}","Product types are dually defined by their mapping-in property.":"곱형(product types)은 그들의 매핑-인 속성(mapping-in property)에 의해 이중적으로 정의됩니다.","Here's the direct Haskell reading of this diagram":"다음은 이 도표의 직접적인 Haskell 읽기입니다","And this is the stylized version written in Haskell style as an infix operator \\hask{&&&}":"그리고 이것은 Haskell 스타일로 인피스(infix) 연산자로 작성된 스타일 버전 \\hask{&&&}입니다.","The other direction of the bijection is given by:":"다른 방향의 전단사 함수(bijection)는 다음과 같이 주어집니다:","which also closely follows the reading of the diagram.":"이는 또한 다이어그램의 읽기와 매우 밀접하게 관련됩니다.","\\subsection{Functoriality revisited}":"\\subsection{함자성(Functoriality) 재검토}","Both sum and product are functorial, which means that we can apply functions to their contents. We are ready to translate those diagrams into code.":"합과 곱은 함수적(functorial)입니다. 이는 우리가 해당 내용(content)들에 함수를 적용할 수 있음을 의미합니다. 우리는 이제 이러한 다이어그램을 코드로 변환할 준비가 되었습니다.","This is the functoriality of the sum type:":"이는 합 타입(선형형식)의 함자성(functoriality)입니다:","Reading this diagram we can immediately write $h$ using \\hask{either}:":"이 다이어그램을 읽으면 즉시 $h$를 \\hask{either}(또는) 사용하여 쓸 수 있습니니다:","Or we could expand it and call it \\hask{bimap}:":"아니면 이를 확장하여 \\hask{bimap}이라고 부를 수 있습니다:","Similarly for the product type:":"유사하게, 곱(product) 타입에 대해:","$h$ can be written as:":"$h$를 다음과 같이 쓸 수 있습니 다:","Or it could be expanded to":"혹은 그것을 확장하여","In both cases we call this higher-order function \\hask{bimap} since, in Haskell, both the sum and the product are instances of a more general class called \\hask{Bifunctor}.":"두 경우 모두, 이 고차 함수(higher-order function)를 \\hask{bimap}이라고 부릅니다. 왜냐하면 Haskell에서 합(sum)과 곱(product) 모두 \\hask{Bifunctor}라고 불리는 더 일반적인 클래스의 인스턴스이기 때문입니다.","\\section{Functoriality of the Function Type}":"\\section{함수형 타입의 함자성(Functoriality of the Function Type)}","The function type, or the exponential, is also functorial, but with a twist. We are interested in a mapping from $b^a$ to $b'^{a'}$, where the primed objects are related to the non-primed ones through some arrows---to be determined.":"함수형, 또는 지수형도 함자적(functiorial)입니다, 그러나 약간의 변형이 있습니다. 우리는 $b^a$에서 $b'^{a'}$로의 매핑(mapping)에 관심이 있으며, 여기서 1차 표시된 객체들은 비 1차 표시된 객체들과 몇 가지 화살(arrow)들에 의해 연결됩니다---이를 결정해야 합니다.","The exponential is defined by it's mapping-in property, so if we're looking for":"지수 함수는 그 함수의 매핑-인 속성(mapping-in property)으로 정의됩니다. 그래서 우리가 찾고 있는 것이","k \\colon b^a \\to b'^{a'}":"k \\colon b^a \\to b'^{a'}","we should draw the diagram that has $k$ as a mapping into $b'^{a'}$. We get this diagram from the original definition by substituting $b^a$ for $c$ and primed objects for the non-primed ones:":"다이어그램을 그려야 합니다. 이 다이어그램은 $k$를 $b'^{a'}$로 매핑하는 것으로, $b^a$를 $c$로 대체하고 비-프라임 객체를 프라임 객체로 대체하여 원래 정의에서 얻습니다.","The question is: can we find an arrow $g$ to complete this diagram?":"질문은: 이 도형을 완성하기 위해 화살표 $g$를 찾을 수 있는가?","g \\colon b^a \\times a' \\to b'":"g \\colon b^a \\times a' \\to b'","If we find such a $g$, it will uniquely define our $k$.":"만약 우리가 그러한 $g$를 찾는다면, 그것은 우리의 $k$를 고유하게 정의할 것입니다.","The way to think about this problem is to consider how we would implement $g$. It takes the product $b^a \\times a'$ as its argument. Think of it as a pair: an element of the function object from $a$ to $b$ and an element of $a'$. The only thing we can do with the function object is to apply it to something. But $b^a$ requires an argument of type $a$, and all we have at our disposal is $a'$. We can't do anything unless somebody gives us an arrow $a' \\to a$. This arrow applied to $a'$ will generate the argument for $b^a$. However, the result of the application is of type $b$, and $g$ is supposed to produce a $b'$. Again, we'll need an arrow $b \\to b'$ to complete our assignment.":"이 문제를 생각하는 방법은 $g$를 어떻게 구현할 것인지 고려하는 것입니다. 이는 $b^a \\times a'$의 곱(product)을 인수로 가집니다. 이를 쌍(pair)으로 생각해 보세요: $a$에서 $b$로 가는 함수 개체(function object)의 요소와 $a'$의 요소입니다. 함수 개체로 할 수 있는 유일한 일은 이를 다른 것에 적용하는 것입니다. 그러나 $b^a$는 타입 $a$의 인수가 필요하며, 우리가 사용할 수 있는 것은 $a'$뿐입니다. 누군가가 우리에게 $a' \\to a$ 화살표(arrow)를 주지 않는 한 우리는 아무것도 할 수 없습니다. 이 화살표를 $a'$에 적용하면 $b^a$의 인수를 생성합니다. 그러나 적용 결과는 타입 $b$이며, $g$는 $b'$를 생성해야 합니다. 다시 말해, 과제를 완료하기 위해서는 $b \\to b'$ 화살표가 필요합니다.","This may sound complicated, but the bottom line is that we require two arrows between the primed and non-primed objects. The twist is that the first arrow goes from $a'$ to $a$, which feels backward from the usual functoriality considerations. In order to map $b^a$ to $b'^{a'}$ we need a pair of arrows:":"이것은 복잡하게 들릴 수 있지만, 요점은 우리는 첨자(primed)된 객체와 비첨자(non-primed)된 객체 사이에 두 개의 화살표가 필요하다는 것입니다. 여기서의 반전은 첫 화살표가 $a'$에서 $a$로 가는데, 이는 보통의 함자성(functoriality) 고려와는 반대 방향으로 느껴진다는 점입니다. $b^a$를 $b'^{a'}$로 매핑하기 위해 저희는 한 쌍의 화살표가 필요합니다:","This is somewhat easier to explain in Haskell. Our goal is to implement a function \\hask{a' -> b'}, given a function \\hask{h :: a -> b}.":"이것은 Haskell에서 설명하기가 더 쉽습니다. 우리의 목표는 \\hask{h :: a -> b} 함수를 주어진 \\hask{a' -> b'} 함수를 구현하는 것입니다.","This new function takes an argument of the type \\hask{a'} so, before we can pass it to \\hask{h}, we need to convert \\hask{a'} to \\hask{a}. That's why we need a function \\hask{f :: a' -> a}.":"이 새로운 함수는 \\hask{a'} 타입의 인수를 받습니다. 그러므로 \\hask{h}에 전달하기 전에 \\hask{a'}를 \\hask{a}로 변환해야 합니다. 그래서 우리는 \\hask{f :: a' -> a}라는 함수가 필요합니다.","Since \\hask{h} produces a \\hask{b}, and we want to return a \\hask{b'}, we need another function \\hask{g :: b -> b'}. All this fits nicely into one higher-order function:":"\\hask{h}는 \\hask{b}를 생성하고, 우리는 \\hask{b'}를 반환하고자 하므로, 다른 함수 \\hask{g :: b -> b'}가 필요합니다. 이 모든 것은 하나의 고차 함수에 잘 맞습니다:","Similar to \\hask{bimap} being an interface to the typeclass \\hask{Bifunctor}, \\hask{dimap} is a member of the typeclass \\hask{Profunctor}.":"\\hask{bimap}이 \\hask{Bifunctor} 타입 클래스(typeclass)의 인터페이스인 것과 유사하게, \\hask{dimap}은 \\hask{Profunctor} 타입 클래스의 멤버입니다.","\\section{Bicartesian Closed Categories}":"\\section{이중 데카르트 닫힌 범주(Bicartesian Closed Categories)}","A category in which both the product and the exponential is defined for any pair of objects, and which has a terminal object, is called \\emph{cartesian closed}. The idea is that hom-sets are not something alien to the category in question: the category is ``closed'' under the operation of forming hom-sets.":"카테고리 안의 객체 쌍에 대해 곱(product)과 지수(exponential)가 정의되어 있고 끝 객체(terminal object)가 있는 카테고리를 \\emph{데카르트 닫힌}(\\emph{cartesian closed}) 카테고리라고 합니다. 이는 hom-집합(hom-sets)이 해당 카테고리에 속하고, hom-집합을 형성하는 연산에 대해 ``닫혀 있다''는 것을 의미합니다.","If the category also has sums (coproducts) and the initial object, it's called \\emph{bicartesian closed}.":"만약 범주가 합(공소산, coproduc​ts)과 초기 대상(initial object)을 갖는다면, 이를 \\emph{이중 카르테지안 닫힌 범주(bicartesian closed)}라고 합니다.","This is the minimum structure for modeling programming languages.":"이것은 프로그래밍 언어를 모델링하기 위한 최소한의 구조입니다.","Data types constructed using these operations are called \\emph{algebraic data types}. We have addition, multiplication, and exponentiation (but not subtraction or division) of types; with all the familiar laws we know from high-school algebra. They are satisfied up to isomorphism. There is one more algebraic law that we haven't discussed yet.":"이러한 연산을 사용하여 구성된 데이터 타입들은 \\emph{대수적 데이터 타입들}(algebraic data types)이라고 합니다. 우리는 타입들의 덧셈, 곱셈, 거듭제곱(하지만 뺄셈이나 나눗셈은 아님)을 가지고 있습니다; 우리가 고등학교 대수학에서 알던 모든 친숙한 법칙들이 있습니다. 이들은 동형성(isomorphism)까지 만족합니다. 아직 논의하지 않은 또 하나의 대수적 법칙이 있습니다.","\\subsection{Distributivity}":"\\subsection{분배법칙(Distributivity)}","Multiplication of numbers distributes over addition. Should we expect the same in a bicartesian closed category?":"숫자의 곱셈은 덧셈에 대해 분배된다. 우리는 이와 동일한 것이 이연계 닫힌 범주(bicartesian closed category)에서도 기대되어야 할까요?","b \\times a + c \\times a \\cong (b + c) \\times a":"b \\times a + c \\times a \\cong (b + c) \\times a","The left to right mapping is easy to construct, since it's simultaneously a mapping out of a sum and a mapping into a product. We can construct it by gradually decomposing it into simpler mappings. In Haskell, this means implementing a function":"왼쪽에서 오른쪽으로의 매핑(mapping)은 구성하기 쉽습니다. 이는 합(sum)에서의 매핑이자 곱(product)으로의 매핑이 동시에 이루어지기 때문입니다. 우리는 이를 점진적으로 더 단순한 매핑들로 분해함으로써 구성할 수 있습니다. Haskell에서는 이것이 함수를 구현하는 것을 의미합니다.","A mapping out of the sum on the left is given by a pair of arrows:":"왼쪽의 합에 대한 사상(mapping)은 화살표 쌍으로 제공됩니다:","We write it in Haskell as:":"Haskell로 다음과 같이 작성합니다:","The \\index{\\hask{where}}\\hask{where} clause is used to introduce the definitions of sub-functions.":"\\index{\\hask{where}}\\hask{where} 절(clause)은 서브 함수(sub-functions)의 정의를 도입하는 데 사용됩니다.","Now we need to implement $f$ and $g$. They are mappings into the product, so each of them is equivalent to a pair of arrows. For instance, the first one is given by the pair:":"이제 $f$와 $g$를 구현해야 합니다. 이들은 곱(product)으로 향하는 사상들이므로 각각의 사상은 화살표(arrow)의 쌍과 동일합니다. 예를 들어, 첫 번째는 다음 쌍으로 주어집니다:","In Haskell:":"하스켈(Haskell)에서:","The first arrow can be implemented by projecting the first component $b$ and then using $\\text{Left}$ to construct the sum. The second is just the projection $\\text{snd}$:":"첫 번째 화살표(arrow)는 첫 번째 구성 요소(component) $b$를 투사한 다음 $\\text{Left}$를 사용하여 합(sum)을 구성함으로써 구현할 수 있습니다. 두 번째는 그냥 투사(projection) $\\text{snd}$입니다:","Similarly, we decompose $g$ into a pair $g'$ and $g''$:":"유사하게, 우리는 $g$를 $g'$와 $g''$의 쌍으로 분해합니다:","Combining all these together, we get:":"이 모든 것을 결합하면, 우리는 다음을 얻습니다:","These are the type signatures of the helper functions:":"이들은 보조 함수들의 타입 서명(signatures)입니다:","They can also be inlined to produce this terse form:":"이것들은 짧은 형태로 인라인(inline)될 수 있습니다:","This style of programming is called \\emph{point free} because it omits the arguments (points). For readability reasons, Haskell programmers prefer a more explicit style. The above function would normally be implemented as:":"이 스타일의 프로그래밍은 인수(점)를 생략하기 때문에 \\emph{point free}라고 합니다. 가독성의 이유로, Haskell 프로그래머들은 더 명시적인 스타일을 선호합니다. 위의 함수는 일반적으로 다음과 같이 구현됩니다:","Notice that we have only used the definitions of sums and products. The other direction of the isomorphism requires the use of the exponential, so it's only valid in a bicartesian \\emph{closed} category. This is not immediately clear from the straightforward Haskell implementation:":"우리가 합(sum)과 곱(product)의 정의만을 사용했음을 주목해 주세요. 동형사상의 다른 방향은 지수함수(exponential)를 사용해야 하므로, 이는 쌍대카테시안 \\emph{폐형} 범주에서만 유효합니다. 이는 단순한 Haskell 구현에서는 즉시 명확하지 않습니다.","but that's because currying is implicit in Haskell.":"하지만 그것은 커링(currying)이 하스켈(Haskell)에서는 암묵적이기 때문입니다.","Here's the point-free version of this function:":"다음은 이 함수의 포인트 프리(point-free) 버전입니다:","This may not be the most readable implementation, but it underscores the fact that we need the exponential: we use both \\hask{curry} and \\hask{uncurry} to implement the mapping.":"이 구현이 가장 읽기 쉬운 것은 아닐지 몰라도, 지수 함수(exponential)의 필요성을 강조합니다: 우리는 매핑을 구현하기 위해 \\hask{curry}와 \\hask{uncurry}를 모두 사용합니다.","We'll come back to this identity later, when we are equipped with more powerful tools: adjunctions.":"더 강력한 도구인 수반(adjunction)들로 무장했을 때, 이 항등식으로 다시 돌아오겠습니다.","\\end{document}":"\\end{document}"}